{"meta":{"title":"Ranshi","subtitle":null,"description":null,"author":"Ranshi","url":""},"pages":[{"title":"about","date":"2020-11-05T14:14:36.000Z","updated":"2024-02-24T12:27:19.238Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[Renaissance.のRanshi] 与&nbsp; ranshi&nbsp; （ RS ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2024-02-24T12:27:19.238Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2024-02-24T12:27:19.239Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2024-02-24T12:27:19.239Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2024-02-24T12:27:19.239Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2024-02-24T12:27:19.240Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2024-02-24T12:27:19.239Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2024-02-24T12:27:19.239Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2024-02-24T12:27:19.239Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2024-02-24T12:27:19.240Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2024-02-24T12:27:19.240Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2024-02-24T12:27:19.240Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"LRU和LFU","slug":"LRU和LFU","date":"2024-03-20T06:27:15.000Z","updated":"2024-03-20T09:16:24.009Z","comments":true,"path":"2024/03/20/LRU和LFU/","link":"","permalink":"/2024/03/20/LRU和LFU/","excerpt":"","text":"LRULRU(最近最少使用) 置换算法, 一般用于固定大小的缓冲区中, 选择最近使用的数据保留在缓冲区中. 这样是建立在最近使用的数据可能最近还会再次使用的假设上, 来减少耗时的读取次数. 为了尽可能快地实现 LRU, 就需要看在 LRU 算法中需要进行哪些操作: Get(key), 通过 Get 函数去获取缓冲区中对应的 value. 在访问过后, 应该需要记录这个键是最近被访问的, 因此不能仅仅是返回 value, 还要对数据的顺序进行处理. Put(key, value), 通过 Put 函数去加入新的键值对. 在加入后, 应该将其设置为最近被访问的 key. 当达到最大容量后, 需要推出最久未使用的键值对. 因此, 我的做法是通过哈希表和双向链表来实现. 这又有这些好处: 通过哈希表存储数据, 能够在 O(1)的时间复杂度下访问到数据. 通过双向链表存储顺序, 能够在 O(1)的时间复杂度下删除中间的元素, 并在 O(1)的时间复杂度下将元素加入在头节点后. Code: import java.util.HashMap; import java.util.Map; class Node { int val; int key; Node pre; Node next; public Node() { } public Node(int key, int val, Node pre, Node next) { this.key = key; this.val = val; this.pre = pre; this.next = next; } } class DoubleLinkList { Node head; int size; public DoubleLinkList() { Node node = new Node(); node.pre = node; node.next = node; this.head = node; } void add(Node n) { // 头节点插入 n.pre = head; n.next = head.next; head.next.pre = n; head.next = n; size++; } Node remove(Node n) { // 删除某个节点 n.pre.next = n.next; n.next.pre = n.pre; n.next = null; n.pre = null; size--; return n; } Node poll() { // head.pre就是最久未使用的节点, 因此直接调用remove删除. Node n = head.pre; remove(n); return n; } } class LRUBuffer { private int cap; private int size; Map&lt;Integer, Node&gt; nodeMap; DoubleLinkList list; public LRUBuffer(int capacity) { this.cap = capacity; this.nodeMap = new HashMap&lt;&gt;(); this.list = new DoubleLinkList(); } public int get(int key) { if (!nodeMap.containsKey(key)) { return -1; } Node n = nodeMap.get(key); list.remove(n); list.add(n); return n.val; } public void put(int key, int value) { if (nodeMap.containsKey(key)) { Node n = nodeMap.get(key); n.val = value; get(n.key); return; } Node node = new Node(key, value, null, null); list.add(node); nodeMap.put(key, node); size++; // 容量满了就删除最久未使用的数据 if (size &gt; cap) { Node n = list.poll(); nodeMap.remove(n.key); size--; } } } LFULFU(最不经常使用) 算法, 也是为了解决 LRU 相同的问题. 但是它所假设的是, 当一个数据使用次数最少, 那么就假设它之后的使用次数也最少, 因此将其从缓冲区移除能够最大地减少读取次数.因此, LFU 的核心是记录每个数据的使用次数, 并在缓冲区容量满的时候移除使用次数最少的数据. 如果有多个数据的使用次数都为最小. 那么就移除其中最久未访问的数据. 根据描述中, 我们可以知道 LFU 是建立在 LRU 之上的. 其主要的操作也和 LRU 相似, 主要区别在于淘汰数据的方式不一样. 因此, 我在 LRU 算法的基础上, 添加了一个哈希表来记录相同访问次数的数据的双向链表. 这样有这些好处: 能够很好地记录相同访问次数数据的先后次序问题. 并且维持顺序的时间复杂度为 O(1) 使用哈希表记录, 能够较好地节约内存, 因为次数可能会很大, 并且不连续. 如果使用数组存储的话, 会消耗内存; 如果使用链表存储的话, 需要线性时间去查找匹配的访问次数. 同样使用哈希表去记录键值对, 能够在 O(1)时间复杂度下进行访问. 至于当前最小的频率是多少, 只需要维护 minFreq. 当新插入值当时候, 直接设置为 1. 当某一个频率的链表大小为 0 时, 并且该频率==minFreq 时, 代表最小频率的链表里面已经没有数据了. 也需要将 minFreq++. Code: import java.util.HashMap; import java.util.LinkedHashMap; import java.util.Map; class Node { int key, val, freq; Node pre, next; public Node(int key, int val, int freq, Node pre, Node next) { this.key = key; this.val = val; this.next = next; this.pre = pre; this.freq = freq; } } class LinkList { Node head; int size; public LinkList() { Node node = new Node(-1, -1, -1, null, null); node.pre = node; node.next = node; this.head = node; } void add(Node n) { n.pre = head; n.next = head.next; head.next.pre = n; head.next = n; size++; } Node remove(Node n) { n.pre.next = n.next; n.next.pre = n.pre; n.next = null; n.pre = null; size--; return n; } Node poll() { Node n = head.pre; remove(n); return n; } } class LFUBuffer { Map&lt;Integer, LinkList&gt; freqMap; Map&lt;Integer, Node&gt; nodeMap; int cap; int size; int minFreq; public LFUBuffer(int capacity) { freqMap = new HashMap&lt;&gt;(); nodeMap = new LinkedHashMap&lt;&gt;(); cap = capacity; size = 0; } public int get(int key) { if (!nodeMap.containsKey(key)) { return -1; } Node node = nodeMap.get(key); LinkList preList = freqMap.get(node.freq); preList.remove(node); if (preList.size == 0) { if (minFreq == node.freq) { minFreq++; } freqMap.remove(node.freq); } node.freq++; if (!freqMap.containsKey(node.freq)) { freqMap.put(node.freq, new LinkList()); } LinkList idxList = freqMap.get(node.freq); idxList.add(node); return node.val; } public void put(int key, int value) { if (nodeMap.containsKey(key)) { Node node = nodeMap.get(key); node.val = value; this.get(key); return; } else if (size == cap) { Node n = freqMap.get(minFreq).poll(); nodeMap.remove(n.key); size--; } Node node = new Node(key, value, 1, null, null); nodeMap.put(key, node); minFreq = 1; if (!freqMap.containsKey(1)) { freqMap.put(1, new LinkList()); } LinkList list = freqMap.get(1); list.add(node); size++; } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"/tags/操作系统/"},{"name":"coding","slug":"coding","permalink":"/tags/coding/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"TCP中的三次握手和四次挥手","slug":"TCP三次握手四次挥手","date":"2024-03-06T09:55:06.000Z","updated":"2024-03-07T15:04:13.444Z","comments":true,"path":"2024/03/06/TCP三次握手四次挥手/","link":"","permalink":"/2024/03/06/TCP三次握手四次挥手/","excerpt":"","text":"TCP 的信息传输TCP 是面向连接的传输层协议, 因此在传输数据之前要先建立连接. 连接是一个很抽象的概念. 从广义上来说, 连接是指将两个个体按照某种方式建立联系的过程. 而在 TCP 协议中, 由于需要进行数据传输, 因此此时的个体即为 TCP 的客户端和服务端, 而建立的联系即为信息传输的通道. 连接建立即然是信息传输的通道, 那么就需要确保连接的双方都能够从通道中读取信息和写入信息. 并且对于双方来说, 都需要知道对方是有写入和读取这两种能力的. 换句话来说, 如果客户端和服务端都知道对方具有读取和写入的能力, 这个连接就算建立了. 以上就是常见的 TCP 建立的三次握手的逻辑图. 接下来我们将客户端和服务端拟人化, 并以报文的形式, 来逐步分析这三次信息传输. 在最开始的时候, 服务端是不知道有人会写信过来的, 而客户端是主动的那一个. 因此, 最初的状态是: 我 对方能读取嘛? 对方能写入嘛? 服务端 我不到啊 😧 我不到啊 😧 客户端 我不到啊 😧 我不到啊 😧 第一次握手此时客户端发送第一个报文给服务端. 其中报文中的 SYN 标志符设置为 1, 表示想要建立连接. 并且生成一个 client_isn, 发送给服务端. 而服务端接收到这个报文后, 就明白有一个客户端想要和自己建立连接, 并且知道这个客户端能够写入信息. 所以现在的连接状态如下: 我 对方能读取嘛? 对方能写入嘛? 服务端 我不到啊 😧 😎👌 客户端 我不到啊 😧 我不到啊 😧 第二次握手当服务端接收到连接建立的报文时, 就需要向客户端发送报文来让对方看看自己的实力了 😎 因此服务端也将 SYN 标志符设置为 1, 表示想要建立连接. 并且将 ACK 设置为 1, 表示自己有应答的信息, 应答的信息写入成 client_isn+1. 并且自己生成了一个 server_isn, 发送给客户端. 而当客户端接收到这个报文后, 自然明白服务端能够写入信息. 在此基础上, 发现在应答的信息正好为 client_isn+1, 这不是说明服务端读取到了自己发送的报文嘛, 那说明服务端能够读取到信息嘛. 所以现在的连接状态如下: 我 对方能读取嘛? 对方能写入嘛? 服务端 我不到啊 😧 😎👌 客户端 😎👌 😎👌 第三次握手这个时候, 客户端也知道了就剩自己还没证明自己的读信息的能力了. 并且客户端觉得, 反正我已经知道你可以读写了, 不如简单一点, 直接开始传输信息吧, 我就当连接已经创建了. 于是设置 ACK 为 1 并将获取到的 server_isn+1 写入到应答, 并直接传输想要发送的数据. 而当服务端接收到第三次传输的信息后, 就知道自己的 server_isn 也被客户端获取到了. 这才放心地进入连接状态. 所以现在的连接状态如下: 我 对方能读取嘛? 对方能写入嘛? 服务端 😎👌 😎👌 客户端 😎👌 😎👌 此时, 连接就算建立完成了. 连接断开而在连接断开的时候, 需要连接的双方知道对方都不会再接收和发送任何消息. 这样, 双方就都可以结束这次连接了. 以上就是常见的 TCP 连接断开的四次挥手逻辑图. 可以很明显地看出来, 这四次挥手, 可以分为两次 FIN 请求和 ACK 回应和最后的等待时间. 我们将继续使用拟人化的形式, 来分析这四次挥手的逻辑. 由于在开始的时候, 连接还是存在的, 所以双方的连接状态是: 我 对方结束发送数据了嘛? 对方结束接收了嘛? 结束请求方 我不到啊 😧 我不到啊 😧 结束响应方 我不到啊 😧 我不到啊 😧 第一次 FIN-ACK在连接建立状态时, 若我们将想要结束连接的一方称为结束请求方, 另一方为结束响应方. 在结束请求方想要结束这段连接时, 会将 FIN 标记为 1, 并发送生成的序列号. 而请求响应方接收到这个报文后, 就会知道对方已经不会再发送数据了, 那么我也赶紧发送完了就结束吧. 并为了让对方得知自己收到的信息, 将 ACK 标记为 1, 并将接收报文的序列号+1 写入到回应序列号中. 这样, 当回应报文被结束请求方接收到后, 就知道自己的结束决定已经被对方接收到了, 就可以开始等待对方的结束决定了. 因此, 这时的连接状态就是: 我 对方结束发送数据了嘛? 对方结束接收了嘛? 结束请求方 我不到啊 😧 我不到啊 😧 结束响应方 😎👌 我不到啊 😧 第二次 FIN-ACK在请求接收方回应对方的结束决定后, 自己在发送完最后一个数据包后, 也会开始着手结束发送了. 于是, 请求接收方如第一次 FIN-ACK 一样, 将 FIN 标记为 1, 并发送生成的序列号. 同样的, 在结束请求方接收到这个报文后, 也会给予回应, 告知自己已经接收到了, 所以将 ACK 标记为 1, 并将接收报文的序列号+1 写入到回应序列号中. 这样, 当请求结束方接收到回应报文后, 就可以结束发送和接收了. 因此, 此时的连接状态是: 我 对方结束发送数据了嘛? 对方结束接收了嘛? 结束请求方 😎👌 我不到啊 😧 结束响应方 😎👌 😎👌 等待时间而在结束请求方发送完回应报文之后, 需要确认两件要求: 尽量确保对方收到了我的回应 确保自己断开接收后, 自己就要搬家了, 别人可能会住进我的地址, 别人不会收到对方的信件. 由于我们已知, 一个报文在网络中最长存活的时间是 MSL, 在 Linux 中一般是 30s, 而超时重传的时间一般在毫秒级别. 所以需要考虑的最坏情况就是: 自己的 ACK 报文在接近 MSL 的时间才被接收到, 而在接收到的时间点前几毫秒, 触发了超时重传. 这时就会有最后一个 FIN 报文还在网络中. 因此, 还需要 1 个 MSL 时间才会时期过期. 因此, 当结束请求方等待了 2 个 MSL 后, 就能够确保两种情况: 对方已经接收到了 ACK, 并且所有的 FIN 报文已经过期了 网络实在不好, 也不强求对方接收 ACK 包了, 并且对方大概率已经超过重传次数了. 而且此时所有的报文已经过期了. 这两种情况下, 都能对第二个要求有了保证. 所以, 结束请求方也就可以关闭确认对方关闭接收了. 因此, 此时的状态是: 我 对方结束发送数据了嘛? 对方结束接收了嘛? 结束请求方 😎👌 😎👌 结束响应方 😎👌 😎👌 此时, 就算是连接断开完成了.","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"/tags/TCP/"},{"name":"计算机网络","slug":"计算机网络","permalink":"/tags/计算机网络/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"使用银行家算法解决哲学家就餐问题","slug":"哲学家问题-银行家算法解决","date":"2024-03-05T06:27:15.000Z","updated":"2024-03-05T06:58:36.583Z","comments":true,"path":"2024/03/05/哲学家问题-银行家算法解决/","link":"","permalink":"/2024/03/05/哲学家问题-银行家算法解决/","excerpt":"","text":"哲学家就餐问题「哲学家就餐问题」是一个非常经典的线程同步互斥以及死锁问题, 问题描述如下: 有 5 个哲学家围坐在一个圆桌上思考. 相邻的两个哲学家中间有一个叉子, 所以一共有 5 个叉子. 而当一个哲学家饿了, 他需要拿起左右两个叉子才可以进餐. 哲学家在进餐完成后会放下叉子, 继续思考, 直到他再次饿了. 在这个问题描述中, 我们发现了一个可能会造成死锁的情况, 那就是当所有的哲学家都只拿到了左边/右边的叉子, 就会导致没有一个人能够进餐, 并且也没有叉子会被放下. 为了解决这个问题, 可以有非常多种办法. 但是从抽象层面来说, 叉子其实就是一种资源, 为了解决资源的缺乏而导致的死锁问题. 这里我们使用银行家算法解决哲学家就餐问题. 银行家算法银行家算法的本质是, 系统只会确认进程所需的最大资源, 在确认分配最大资源后不会发生死锁的情况下才会对一个进程分配资源. 因此, 系统需要在分配资源之前就知道进程所需的最大资源是多少才能使用该算法. 而恰好在「哲学家就餐问题」中, 我们很明确每个哲学家最多只需要他左右两个叉子. 因此, 系统只需要判断左右两个资源(叉子)是否可用, 即可判断是否会发生死锁. 以下是使用 Go 语言对该算法进行的一个模拟: package main import ( &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot; ) var ( mutex = make(chan bool, 1) N = 100 forks []chan struct{} eatCount = make([]int, N) randTime = func() time.Duration { return time.Duration(rand.Intn(5)) * time.Microsecond } ) func init() { forks = make([]chan struct{}, N) for i := 0; i &lt; N; i++ { forks[i] = make(chan struct{}, 1) } } func thinking() { time.Sleep(randTime()) } func takeFork(i int) { leftFork, rightFork := (i-1+N)%N, (i+1)%N for { // have chance to take fork mutex &lt;- true if len(forks[leftFork]) == 0 &amp;&amp; len(forks[rightFork]) == 0 { forks[leftFork] &lt;- struct{}{} forks[rightFork] &lt;- struct{}{} // take two forks &lt;-mutex return } // take zero forks &lt;-mutex } } func eat(i int) { eatCount[i]++ fmt.Printf(&quot;philosopher %v is eating %v times\\n&quot;, i, eatCount[i]) time.Sleep(randTime()) } func putFork(i int) { leftFork, rightFork := (i-1+N)%N, (i+1)%N &lt;-forks[leftFork] &lt;-forks[rightFork] } func philosopher(i int) { for { // spend random time thinking() // take two forks takeFork(i) // spend random time eat(i) // put two forks putFork(i) } } func main() { for i := 0; i &lt; N; i++ { go philosopher(i) } startTime := time.Now() for { time.Sleep(5 * time.Microsecond) flag := true for i := 0; i &lt; N; i++ { if eatCount[i] &lt; 200 { flag = false break } } if flag { fmt.Println(time.Since(startTime)) return } } } 由于需要保证在分配资源时, 不会发生同时分配资源的情况. 因此我们需要一个锁来保证同一时间仅有一个哲学家可以申请叉子.","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"线程安全","slug":"线程安全","permalink":"/tags/线程安全/"},{"name":"银行家算法","slug":"银行家算法","permalink":"/tags/银行家算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Rust中的所有权系统","slug":"rust中的所有权系统","date":"2023-02-07T09:55:06.000Z","updated":"2024-03-07T15:04:13.449Z","comments":true,"path":"2023/02/07/rust中的所有权系统/","link":"","permalink":"/2023/02/07/rust中的所有权系统/","excerpt":"","text":"对于所有的编程语言, 都必须要考虑的一件事就是管理内存. 对于这件事, 各种语言是八仙过海, 各显神通. C/C++ 将内存的管理交给程序员, 这样就的好处就是能够细致化地优化程序, 但弊端则是十分难以维护. 往往会出现野指针、指针悬挂等问题, 导致程序出现 bug 或者内存没有得到释放. 而高级语言(Java, Python, Go)则使用 GC(Garbage collection)机制. 这个机制会收集分配的内存, 并统一释放. 因此其能大大降低程序出现 Bug 的概率, 并提高程序员的工作效率. 但其也存在一定的弊端, 就是在释放内存时会出现 STW(Stop The World)时间, 在这段时间中程序中的所有线程都会被挂起, 并专心进行垃圾收集操作, 这对于非常追求效率的程序来说是无法容忍的. 而 Rust 选择了另外一种方式来管理内存. Rust 程序是没有 GC 的, 但是其也不需要程序员专门去释放内存, 而是通过一种特殊的系统————所有权系统来保证内存不会泄漏. 这种系统不会影响到编译后的二进制程序, 是因为其通过优秀的编译器, 在程序编译阶段就将大部分的会造成内存泄漏的问题都考虑到了. 这就相当于一个能够完美考虑 C/C++代码中的 Bug 的大神在给你的程序做 Debug. 这种方法即能降低程序员的压力也能兼顾到程序的运行效率. 所有权简述所有权移动fn main() { let a = 20; let mut b = a; b = b - 7; println!(&quot;a={}&quot;, a); println!(&quot;b={}&quot;, b); } // a=20 // b=13 fn main() { let a = &quot;Hello&quot;.to_string(); let mut b = a; b.push(&#39;!&#39;); println!(&quot;a={}&quot;, a); println!(&quot;b={}&quot;, b); } | 2 | let a = &quot;Hello&quot;.to_string(); | - move occurs because `a` has type `String`, which does not implement the `Copy` trait 3 | let mut b = a; | - value moved here 4 | b.push(&#39;!&#39;); 5 | println!(&quot;a={}&quot;, a); | ^ value borrowed here after move 这两个程序一个正常运行, 一个报错. 这是因为在第一个程序中的 a 和 b 都是一个 i32 类型的变量, 其大小是固定的, 因此其是存放在栈内存中的. 而第二个程序中的字符串是可变长度的, 因此无法保证其在栈中能够合理地存放(如果需要扩容则需要全部重新在栈上分配内存), 因此其是存放在堆内存中的. 因此这两个程序的内存分布如下图所示: 变量在堆内存和在栈内存上有什么区别呢? 除了访问速度以外, 最主要的区别是栈内存是能够通过变量的生命周期自动释放的, 而堆内存则需要通过程序员手动释放或者由 GC 释放. 另外, 可以明显从内存分布中看到, 在第一个程序中的 a 和 b 没有共享任何内存, 因此它们是不会进行相互影响的. 而在第二个程序中, a 和 b 共享了字符串在堆中的内存, 因此其必须考虑到各种情况下的内存安全. 在 C/C++代码中, 如果堆内存被两个指针使用, 则可能出现二次释放的错误. 因此在这个 rust 程序中, a 已经失去了堆内存的所有权, 而 b 获得了堆内存的所有权. 这种情况就称为所有权转移(move), 因无法再通过 a 访问到堆内存中的字符串了. 因此得这样写: fn main() { let a = &quot;Hello&quot;.to_string(); let mut b = a; b.push(&#39;!&#39;); println!(&quot;b={}&quot;, b); } // b=Hello! Copy 与 Clone但是如想要创建一个全新的变量 b, 其拥有一个全新的堆内存该怎么办呢? Rust 针对不同的类型设计了不同的拷贝方式. 对于 Rust 中分配在栈内存中的大小可知的变量, 其实现了 copy 函数, 其能够在拷贝时自动将栈内存复制给新变量. 而对于分配在堆内存中的变量, Rust 实现了 clone 函数, 其将重新在堆上分配内存给新的变量. fn main() { let a = &quot;Hello&quot;.to_string(); let mut b = a.clone(); b.push(&#39;!&#39;); println!(&quot;b={}&quot;, b); println!(&quot;a={}&quot;, a); } // b=Hello! // a=Hello 可以看到这样就不会出现之前的问题. 则是因为 b 所指向的字符串是在堆上重新分配的, 因此 a 的并没有失去原先内存的所有权. 其内存分布如图: 需要注意的是, 由于 b 增加了一个字符, 导致容量不够容纳这么多字符, 因此容量会进行翻倍. 多分配了 4 个容量给 b 变量. 这样有利于减少内存分配的次数. 所有权借用读取但存在这么一种情况, 需要将变量 a 传入到一个函数中, 在函数返回时有需要对 a 进行访问. 由于函数传参的机制, 如果使用所有权移动, 则会导致在函数结束后无法访问. fn print_str(b: String) { println!(&quot;str={}&quot;, b); } fn main() { let a = &quot;Hello&quot;.to_string(); print_str(a); println!(&quot;a={}&quot;, a); } | 6 | let a = &quot;Hello&quot;.to_string(); | - move occurs because `a` has type `String`, which does not implement the `Copy` trait 7 | print_str(a); | - value moved here 8 | println!(&quot;a={}&quot;, a); | ^ value borrowed here after move 这时, 就需要使用所有权借用. 所有权借用就是将所有权暂时借用给另一个变量, 并且改变量会在未来的某一时刻将其交还给其原来的主人. 具体来说, 使用以下格式进行所有权借用. fn print_str(b: &amp;String) { println!(&quot;str={}&quot;, b); } fn main() { let a = &quot;Hello&quot;.to_string(); print_str(&amp;a); println!(&quot;a={}&quot;, a); } // str=Hello // a=Hello 所有权借用的内存分布如图: 其实, 由于借用只是为了读取原变量的值, 因此可以将其所有权借用给多个变量. fn print_str(b: &amp;String) { println!(&quot;str={}&quot;, b); } fn main() { let a = &quot;Hello&quot;.to_string(); let c = &amp;a; print_str(&amp;a); println!(&quot;c={}&quot;, c); println!(&quot;a={}&quot;, a); } // str=Hello // c=Hello // a=Hello 修改在特殊情况下, 需要在函数中对传入的存储在堆内存的变量进行修改, 还能使用原先的做法吗? fn print_str(b: &amp;mut String) { b.push(&#39;!&#39;); println!(&quot;str={}&quot;, b); } fn main() { let mut a = &quot;Hello&quot;.to_string(); let c = &amp;a; print_str(&amp;mut a); println!(&quot;c={}&quot;, c); println!(&quot;a={}&quot;, a); } | 8 | let c = &amp;a; | -- immutable borrow occurs here 9 | print_str(&amp;mut a); | ^^^^^^ mutable borrow occurs here 10 | println!(&quot;c={}&quot;, c); | - immutable borrow later used here 会发现, 这也遇到了问题. 根据提示, 这种情况出现的问题是在使用可变借用时还有不可变借用存在, 即在对变量进行修改操作时, 还在对其进行读取操作. 这在 rust 中是不被允许的. 但这意味着必须删除 c 变量吗? 其实不是的, 可以看到最后一个提示, “immutable borrow later used here” 这是不是意味着只要在不可变借用的生命周期中不存在可变借用, 就能够避免错误呢? fn print_str(b: &amp;mut String) { b.push(&#39;!&#39;); println!(&quot;str={}&quot;, b); } fn main() { let mut a = &quot;Hello&quot;.to_string(); let c = &amp;a; println!(&quot;c={}&quot;, c); print_str(&amp;mut a); println!(&quot;a={}&quot;, a); } // c=Hello // str=Hello! // a=Hello! 确实是这样的, 这表示. 在同一时间, 只能存在多个不可变借用(只读)或者一个可变借用(可读可写). 而如果一个借用在之后没有使用, 其生命周期在其最后一次使用时就结束了, 也就不对其他借用造成影响了.","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"rust","slug":"rust","permalink":"/tags/rust/"},{"name":"所有权类型","slug":"所有权类型","permalink":"/tags/所有权类型/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"旅游——温彻斯特","slug":"旅游-温彻斯特","date":"2022-10-30T14:09:15.000Z","updated":"2024-03-07T15:04:13.444Z","comments":true,"path":"2022/10/30/旅游-温彻斯特/","link":"","permalink":"/2022/10/30/旅游-温彻斯特/","excerpt":"","text":"突发奇想去南安普顿的周边城市，温彻斯特玩了一转。其实最初的打算是去一个教堂去看看，增长自己的见识。再加上室友也想出去看看，所以约好一起去。 由于是临时起意，没有多做准备，吃完午饭之后就出发了。从南安普顿到温彻斯特教堂并不远，坐蓝色的 bluestar 1 号就能直接到达。但是令人可惜的是，由于这一趟车的终点站并不在南安普顿范围内，所以无法时候 unilink 的二维码，而是要花 2 磅购买车票。 乘坐 Bluestar 1 到 St. Thomas Church 后, 可以在富有年代气息的建筑间隙中远远看见温彻斯特教堂. 不得不说感觉比南安普顿有气氛多了, 南安普顿感觉就像是一个有点现代化的城市, 而 Winchester 则像《刺客信条》里面小镇的感觉, 果然《刺客信条》是旅游模拟器. 穿过建筑群, 在教堂前的是一片公园. 树荫下有许多游客坐在椅凳上, 聊着天. 而与我们不一样的是, 这里有许多墓碑, 听说在英国人的观念中, 不会有阴气这种概念, 反而觉得这是一种很好的地方. 特别是在墓地旁的房子往往可以买得高价(我租的公寓旁就是一片墓地). 这就是明显的文化差异吧. 在草坪后, 就是温彻斯特大教堂. 记得上次了解教堂是巴黎圣母院被烧毁的时候, 趁着新闻报道了解了一些它的大致结构. 这次算是我第一次见到真实的教堂, 从建筑学的方面来说(虽然我完全不懂建筑学), 这个教堂基本全部使用的是大型的石块, 让人感觉非常沉重和庄重. 灰白色的表面上斑驳的痕迹也让人看出其历史的厚重. 我和我室友在其周围逛了一圈后, 教堂开始迎客了, 我们也就一起进入参观了. 教堂的参观票并不贵, 大概 12 磅左右. 如果是学生的话, 提供学生证作为证明, 还可以有很高的优惠. 只需要出 6.5 磅, 即可一年内无限次参观. 在我和室友购买完票后, 即开始了正式参观. 刚进入教堂时我们处于中殿. 我第一眼看到的就是天花板上的房梁, 我感觉这种规则形的样式非常美丽, 并且其让我想到了《刺客信条: 大革命》里面与 boss 战斗在巴黎圣母院的情景. 回头看过来就是教堂的“西窗”, 听说是在 1660 年使用教堂中的碎玻璃重建的. 多彩斑斓的颜色以及破碎的样式非常令人震撼. 随后一次参观了教堂的南耳堂、司祭席、后堂区以及北耳堂. 看到了非常多的雕塑作品, 各个都栩栩如生. 特别是主祭坛后的巨大屏风, 让人感叹其工作量和精细程度. 最后, 我们在中殿北侧找到了《傲慢与偏见》的作者——简·奥斯汀的碑文. 其也出现在 10 英镑纸币上. 在游玩一天后, 也有许多对温彻斯特的感触. 对这个城市的第一感受就是古朴但又熟悉. 这里的建筑都不高, 平均在 3 层左右, 而且街道也不是很宽, 非常符合我印象中的英国小镇的形象. 可以看出, 这个城市虽然不算经济发展中心, 但是拥有着非常深厚的历史底蕴. 对于温彻斯特大教堂, 我的第一感觉和温彻斯特一样, 都是古朴但熟悉, 可能是我在游戏中见过一些教堂的缘故, 我并没有太多的惊讶. 但参观期间我试着用手触摸那厚重的墙壁, 才真正感受到了它的厚重.","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"游记","slug":"游记","permalink":"/tags/游记/"},{"name":"英国","slug":"英国","permalink":"/tags/英国/"},{"name":"温彻斯特","slug":"温彻斯特","permalink":"/tags/温彻斯特/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"自己用Go实现一个进度条库","slug":"go实现自己的cli进度条","date":"2022-01-17T03:02:15.000Z","updated":"2024-03-02T16:13:04.422Z","comments":true,"path":"2022/01/17/go实现自己的cli进度条/","link":"","permalink":"/2022/01/17/go实现自己的cli进度条/","excerpt":"","text":"进度条的显示结构对于一个进度条来说，最重要的应该是显示进度。对于进度的显示，可以有多种形式： 用一个长条来表示，随着任务的逐渐完成，长条逐渐被填满。因为人类对于形象的信息接受地更快，所以形象的长条状能够很好地让使用者认识到当前进度以及还差多少。 使用百分比来显示。直观展现还剩多少，已经完成了多少。 已完成的任务数/总共的任务数。当数据量较大的时候，单个任务的完成可能导致前两种形式无法展示。而该种形式能够让使用者明白任务正在进行。 大致计划成品如下： 定义数据结构根据进度条的显示结构，我们可以知道一个进度条类型的结构如下： type Progress struct { percent int64 current int64 total int64 startTime time.Time rate float64 line string graph string lock *sync.Mutex } 同时可以写出其的初始化函数： func InitProgress(total int64) *Progress { return &amp;Progress{ current: 0, total: total, line: &quot;&quot;, graph: &quot;#&quot;, percent: 0.0, startTime: time.Now(), rate: 0.0, lock: &amp;sync.Mutex{}, } } 实现功能初步构想的是和 Python 的 alive_progress 库一样，先用一个函数定义了一个对象，然后在完成一个任务之后调用该对象的方法，即可刷新进度条。 那么用以下形式实现。 func (p *Progress) Complete() { p.lock.Lock() p.current += 1 currentPercent := p.GetPercent() if currentPercent != p.percent &amp;&amp; currentPercent%2 == 0 { p.line += string(p.graph) } p.line = strings.Repeat(string(p.graph), int(p.percent/2)) fmt.Printf(&quot;\\r[%-50s] %3d%% %6d/%d(tasks)&quot;, p.line, p.percent, p.current, p.total) if p.current == p.total { duration := time.Since(p.startTime).Seconds() fmt.Printf(&quot;\\nAll tasks have been completed, taking a total of %.2f seconds.\\n&quot;, duration) } p.lock.Unlock() } 并且为了保证并行安全，为该对象加了锁，保证每次只有一个协程/线程正在给进度条+1。 代码package progress import ( &quot;fmt&quot; &quot;strings&quot; &quot;sync&quot; &quot;time&quot; ) // @Time : 2022/01/17 14:11 // @Author : Ranshi // @File : main.go // @Doc : 自己编写的cli进度条库 type Progress struct { percent int64 current int64 total int64 startTime time.Time rate float64 line string graph string lock *sync.Mutex } func InitProgress(total int64) *Progress { return &amp;Progress{ current: 0, total: total, line: &quot;&quot;, graph: &quot;#&quot;, percent: 0.0, startTime: time.Now(), rate: 0.0, lock: &amp;sync.Mutex{}, } } func (p *Progress) SetGraph(ch byte) { p.graph = string(ch) } func (p *Progress) GetPercent() int64 { return (p.current * 100) / p.total } func (p *Progress) Complete() { p.lock.Lock() p.current += 1 currentPercent := p.GetPercent() if currentPercent != p.percent &amp;&amp; currentPercent%2 == 0 { p.line += string(p.graph) } p.line = strings.Repeat(string(p.graph), int(p.percent/2)) fmt.Printf(&quot;\\r[%-50s] %3d%% %6d/%d(tasks)&quot;, p.line, p.percent, p.current, p.total) if p.current == p.total { duration := time.Since(p.startTime).Seconds() fmt.Printf(&quot;\\nAll tasks have been completed, taking a total of %.2f seconds.\\n&quot;, duration) } p.lock.Unlock() }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Go","slug":"Go","permalink":"/tags/Go/"},{"name":"progress","slug":"progress","permalink":"/tags/progress/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"初步探索Go中间件","slug":"初步探索Go中间件","date":"2022-01-15T08:18:15.000Z","updated":"2024-03-02T16:13:05.076Z","comments":true,"path":"2022/01/15/初步探索Go中间件/","link":"","permalink":"/2022/01/15/初步探索Go中间件/","excerpt":"","text":"什么是中间件？中间件通常是一小部分代码，能够在后端处理请求之前或者之后，对请求和响应作出处理。这就要求了中间件的体量不能过大，并且职责要求尽量单一，便于接藕。 一个很简单的例子，如果我们打算记录每个请求被响应的总时间，那么我们可以在最外层套一层中间件。这样就可以得知从收到请求到返回响应的总时间了。 根据上图中，外层的处理代码就是中间件，内层的代码就是应用的核心功能。 怎么编写中间件？在 Go 语言中，我们可以将函数嵌套起来，构成一个中间件。 比如一下代码，就是一个用来验证请求 Method 是否合法的中间件。 // http.HandlerFunc 是将一类具有相同的函数签名的函数定义为这个类型。 // 也就是说，这种类型的实例是一个函数，该函数的的参数是http.ResponseWriter, 和http.Request的指针。 // 而Middleware类型是将一类函数定义为Middleware，这类函数接收一个http.HandlerFunc类型， // 并返回一个http.HandlerFunc类型 type Middleware func(http.HandlerFunc) http.HandlerFunc // 该中间件是用于检测请求是否为合法的 HTTP Method，不是则返回 400 Bad Request func CheckMethod(m string) Middleware { // 返回一个Middleware类型， return func(hf http.HandlerFunc) http.HandlerFunc { // 返回一个http.HandlerFunc类型， return func(rw http.ResponseWriter, r *http.Request) { if r.Method != m { http.Error(rw, http.StatusText(http.StatusBadRequest), http.StatusBadRequest) return } // 调用下一个中间件或者最终处理的handler程序 hf(rw, r) } } } 其中 CheckMethod 是用于返回一个 Middleware 类型的函数。为啥不直接定义一个 Middleware 类型的函数呢，而要定义一个返回 Middleware 类型的函数呢？其实上面这个函数就是一个很好的例子。因为 Middleware 类型有固定的函数签名，因此无法给中间件添加参数，比如该函数中的参数 m，就是指的是应该的 Method 类型。如果单独定一个 Middleware 类型的函数，则无法实现。 其中return func(hf http.HandlerFunc) http.HandlerFunc是返回 http.HandlerFunc 类型的函数，http.HandlerFunc 类型其实就是指的有着func(ResponseWriter, *Request)签名的函数类型。而接收一个该类型的函数，又返回一个该类型的函数，也就可以根据链式调用将核心功能一层一层的包裹在中间件之中。 其中return func(rw http.ResponseWriter, r *http.Request)则是编写中间件核心处理功能的函数。需要在该函数中实现中间件的功能，并调用下一层的中间件或核心功能的函数。 调用中间件根据上图中我们可以看出来，想要添加新的中间件，只需要在外层多加几层就能达到目的了。那么可以写一个链式调用的函数，将核心功能一层一层套起来。 func Chain(f http.HandlerFunc, middlewares ...Middleware) http.HandlerFunc { for _, middleware := range middlewares { f = middleware(f) } return f } 例子package main import ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; &quot;time&quot; ) // http.HandlerFunc 是将一类具有相同的函数签名的函数定义为这个类型。 // 也就是说，这种类型的实例是一个函数，该函数的的参数是http.ResponseWriter, 和http.Request的指针。 // 而Middleware类型是将一类函数定义为Middleware，这类函数接收一个http.HandlerFunc类型， // 并返回一个http.HandlerFunc类型 type Middleware func(http.HandlerFunc) http.HandlerFunc // 该中间件是用来记录URL请求的执行时长的 func Logging() Middleware { // 返回一个Middleware类型， return func(hf http.HandlerFunc) http.HandlerFunc { // 返回一个http.HandlerFunc类型， return func(rw http.ResponseWriter, r *http.Request) { start := time.Now() defer func() { log.Println(r.URL.Path, time.Since(start)) }() // 调用下一个中间件或者最终处理的handler程序 hf(rw, r) } } } // 该中间件是用于检测请求是否为合法的 HTTP Method，不是则返回 400 Bad Request func CheckMethod(m string) Middleware { // 返回一个Middleware类型， return func(hf http.HandlerFunc) http.HandlerFunc { // 返回一个http.HandlerFunc类型， return func(rw http.ResponseWriter, r *http.Request) { if r.Method != m { http.Error(rw, http.StatusText(http.StatusBadRequest), http.StatusBadRequest) return } // 调用下一个中间件或者最终处理的handler程序 hf(rw, r) } } } func Chain(f http.HandlerFunc, middlewares ...Middleware) http.HandlerFunc { for _, middleware := range middlewares { f = middleware(f) } return f } func Hello(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, &quot;hello world&quot;) } func main() { http.HandleFunc(&quot;/&quot;, Chain(Hello, CheckMethod(&quot;GET&quot;), Logging())) http.ListenAndServe(&quot;localhost:8000&quot;, nil) }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Go","slug":"Go","permalink":"/tags/Go/"},{"name":"Middleware","slug":"Middleware","permalink":"/tags/Middleware/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"2021.10.5的一份日记","slug":"2021.10.5的一份日记","date":"2021-10-05T07:43:14.000Z","updated":"2024-03-02T16:13:05.026Z","comments":true,"path":"2021/10/05/2021.10.5的一份日记/","link":"","permalink":"/2021/10/05/2021.10.5的一份日记/","excerpt":"","text":"七月份的尾巴 你是狮子座, 八月份的前奏 你是狮子座, 相遇的时候 如果是个意外, 离别的时候 意外的看不开 今天在看一部小说的时候, 看见女主对男主说: “这就是我的全部了”. 让我想起了战场原在化物语的最后一集, 躺在草坪上、看着星空、对垃圾君说:“这就是全部了, 这些就是我拥有的一切了”. 不知不觉, 看化物语的我已经是 7 年前的我了, 那个时候的我只记得这个场景很美, 很动人, 很令我印象深刻.记得第一次回想起这个场景是在谈恋爱的第一天, 我拿出这段场景的视频给我女朋友看. 这差不多可以说明, 在家庭中未能充分形成的恋爱观, 在这个场景让我学到到了很多吧. 今天想起来后重新去看了一遍化物语最后一集, 不得不感叹西尾老贼太懂了. 当年啥都不懂的我只是在看一对恋人看星空. 现在却能看到战场原的那份傲娇底下的温柔, 冰冷下的真诚 . 原来我也长大了呀. 有时间的话, 再去看一遍物语系列好了, 感觉会和当初稚嫩的高中时代的我有很大不同吧. 巧合的是, 音乐播放器突然播放了曾轶可的《狮子座》, 初听感觉有些一般, 但多听几遍并看过歌词以后, 才发现这真是一首好歌. 歌颂了这一段回忆和现阶段的一段恋情, 让我更加明了如何去爱一个人. 最近可能会循环一段时间了吧.","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"《狮子座》","slug":"《狮子座》","permalink":"/tags/《狮子座》/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"Python常用库——string","slug":"python常用库——string","date":"2021-09-26T07:15:36.000Z","updated":"2024-03-02T16:13:57.378Z","comments":true,"path":"2021/09/26/python常用库——string/","link":"","permalink":"/2021/09/26/python常用库——string/","excerpt":"","text":"string 库是一个 Python 标准库, 主要包含字符常量和Formatter, 这里我们主要了解 Formatter. 字符常量不过多解释啦, 都是某一类字符组成的字符串. # 小写字母组成的字符串 print(f&quot;All lowercase letters characters: {list(string.ascii_lowercase)}&quot;) # 大写字母组成的字符串 print(f&quot;All uppercase letters characters: {list(string.ascii_uppercase)}&quot;) # 英文字母组成的字符串 ascii_letters = ascii_lowercase + ascii_uppercase print(f&quot;All letters characters: {list(string.ascii_letters)}&quot;) # 十进制数字 print(f&quot;All digits number characters: {list(string.digits)}&quot;) # 十六进制数字 print(f&quot;All hexdigits number characters: {list(string.hexdigits)}&quot;) # 八进制数字 print(f&quot;All octdigits number characters: {list(string.octdigits)}&quot;) # 标点符号 print(f&quot;All punctuation characters: {list(string.punctuation)}&quot;) # 空白符号 print(f&quot;All whitespace characters: {list(string.whitespace)}&quot;) # 所有可打印的字符 printable = digits + ascii_letters + punctuation + whitespace print(list(string.printable)) # All lowercase letters characters: abcdefghijklmnopqrstuvwxyz # All uppercase letters characters: ABCDEFGHIJKLMNOPQRSTUVWXYZ # All letters characters: abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ # All digits number characters: 0123456789 # All hexdigits number characters: 0123456789abcdefABCDEF # All octdigits number characters: 01234567 # All punctuation characters: !&quot;#$%&amp;&#39;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~ # All whitespace characters: [&#39; &#39;, &#39;\\t&#39;, &#39;\\n&#39;, &#39;\\r&#39;, &#39;\\x0b&#39;, &#39;\\x0c&#39;] # [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;, &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;!&#39;, &#39;&quot;&#39;, &#39;#&#39;, &#39;$&#39;, &#39;%&#39;, &#39;&amp;&#39;, &quot;&#39;&quot;, &#39;(&#39;, &#39;)&#39;, &#39;*&#39;, &#39;+&#39;, &#39;,&#39;, &#39;-&#39;, &#39;.&#39;, &#39;/&#39;, &#39;:&#39;, &#39;;&#39;, &#39;&lt;&#39;, &#39;=&#39;, &#39;&gt;&#39;, &#39;?&#39;, &#39;@&#39;, &#39;[&#39;, &#39;\\\\&#39;, &#39;]&#39;, &#39;^&#39;, &#39;_&#39;, &#39;`&#39;, &#39;{&#39;, &#39;|&#39;, &#39;}&#39;, &#39;~&#39;, &#39; &#39;, &#39;\\t&#39;, &#39;\\n&#39;, &#39;\\r&#39;, &#39;\\x0b&#39;, &#39;\\x0c&#39;] [ 因为空白字符的打印在命令行不便查看, 使用列表将其变为字符形式 ] Formatter基础使用Formatter 是 string.py 包中定义的一个类, 其中定义了一个用于格式化字符串的方法: format(这是我们主要使用的 API), 这是一个简单的例子: f = string.Formatter() morning = &quot;Good morning&quot; print(f.format(&quot;{greet}, {name}&quot;, name=&quot;Ranshi&quot;, greet=morning)) # output: # Good morning, Ranshi 根据输出结果可以看出, 两个字符串被拼接起来了. 但是这种形式看起来并不是非常优雅, 因为我们还需要定义一个 string.Formatter 的对象, 然后才调用 format 方法. 其实, Python 针对 str 对象就实现了 format 方法,我们可以直接调用一个 str 对象的 format 方法. morning = &quot;Good morning&quot; print(&quot;{greet}, {name}&quot;.format(name=&quot;Ranshi&quot;, greet=morning)) # output: # Good morning, Ranshi 而在 python3.6 之后, 引入了 f-string 写法, 进一步地简化了格式化字符串的使用. morning = &quot;Good morning&quot; print(f&quot;{morning}, {&#39;Ranshi&#39;}&quot;) # output: # Good morning, Ranshi 相比起来是不是非常简单, 下文中我们就都用这种形式来书写格式化字符串. 在{}中可以使用”格式规格”, 用于定义单个值如果格式到字符串中. 如果未指定则默认调用str()函数. 一般形式如下: [[fill]align][sign][#][0][width][grouping_option][.precision][type] 定位格式化字符串有两种定位方式. 一种是将 format 函数接收的参数当作一个列表, 然后依次显示在每个{}中, 而{}中也可以携带数字, 表示替换的是列表中的第几个元素. print(&quot;{0}, {1}, {2}&quot;.format(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) print(&quot;{}, {}, {}&quot;.format(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) print(&quot;{0}, {0}, {1}&quot;.format(&quot;a&quot;, &quot;b&quot;)) print(&quot;{1}, {0}, {2}&quot;.format(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) # output: # a, b, c # a, b, c # a, a, b # b, a, c 第二种是将 format 函数接收的字典参数, 然后对应在相应健的位置. print(&quot;{greet}, {name}&quot;.format(greet=&quot;goodbye&quot;, name=&quot;Ranshi&quot;)) # output: # goodbye, Ranshi 由于传入的参数是一个解包的列表或字典, 因此也可以将列表或字典解包后作为 format 函数的参数. lst = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] print(&quot;{1}, {0}, {2}&quot;.format(*lst)) d = {&quot;greet&quot;: &quot;goodbye&quot;, &quot;name&quot;: &quot;Ranshi&quot;} print(&quot;{greet}, {name}&quot;.format(**d)) # output: # b, a, c # goodbye, Ranshi 格式化参数转换符在{}中, 可以设置转换符, 设置后表达式结果会先转换, 再格式化. 转换符一共有 s | r | a 三种, 分别表示调用str(), repr(), ascii(). 在转换符前使用 !表示需要转换. greet = &quot;你好,\\tRanshi&quot; print(f&quot;{greet}&quot;) print(f&quot;{greet!s}&quot;) print(f&quot;{greet!r}&quot;) print(f&quot;{greet!a}&quot;) # output: # 你好, Ranshi # 你好, Ranshi # &#39;你好,\\tRanshi&#39; # &#39;\\u4f60\\u597d,\\tRanshi&#39; 由此可见, 默认是调用str()方法. = 格式化在 Python 3.8 版本中, 可以使用 = 来进行格式化. 可以将变量格式化成 s=str(s) 的字符串. 并且可以在其中任意位置加入字符串. result = 15 * 32 print(f&quot;{result=}!&quot;) print(f&quot;{ result=}!&quot;) print(f&quot;{result =}!&quot;) # output: # result=480! # result=480! # result =480! 对齐官方文档写的比我详细多了. 例子: x = 158 print(f&quot;#{x:~&lt;10}#&quot;) print(f&quot;#{x:~&lt;+10}#&quot;) print(f&quot;#{x:~&lt; 10}#&quot;) print(f&quot;#{-x:~&lt;+10}#&quot;) print(f&quot;#{x:~^10}#&quot;) print(f&quot;#{x:~&gt;10}#&quot;) # output: # #158~~~~~~~# # #+158~~~~~~# # # 158~~~~~~# # #-158~~~~~~# # #~~~158~~~~# # #~~~~~~~158# 进制转换可以使用字符表示数字的进制. b =&gt; 二进制 c =&gt; 字符, 将帧数转换为 unicode 字符 d =&gt; 十进制 o =&gt; 八进制 x =&gt; 十六进制 n =&gt; 数字, 与 ‘d’ 相似, 当会使用当前区域来插入适当的数字分隔符. num = 105 print(f&quot;{num:b}&quot;) print(f&quot;{num:c}&quot;) print(f&quot;{num:d}&quot;) print(f&quot;{num:o}&quot;) print(f&quot;{num:x}&quot;) print(f&quot;{num:n}&quot;) # output: # 1101001 # i # 105 # 151 # 69 # 105 特殊表示千位分隔符: num = 1316513216513216513 print(f&quot;{num:,}&quot;) # output: # 1,316,513,216,513,216,513 时间格式化: d = datetime.datetime.now() print(f&quot;{d:%Y-%m-%d %H:%M:%S}&quot;) # output: # 2021-09-26 13:51:05 百分比转换 per = 0.35 print(f&quot;{per:%}&quot;) # output: # 35.000000%","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"Python stl","slug":"Python-stl","permalink":"/tags/Python-stl/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"我的vscode自定义化过程","slug":"我的vscode自定义化过程","date":"2021-08-05T02:33:15.000Z","updated":"2024-03-02T16:13:04.422Z","comments":true,"path":"2021/08/05/我的vscode自定义化过程/","link":"","permalink":"/2021/08/05/我的vscode自定义化过程/","excerpt":"","text":"前言终于开始折腾编辑器了，就怕最后折腾完又回到起点。 我之前一直是使用 idea+python 插件+golang 插件+rust 插件作为日常使用的，然后使用 ide-eval-resetter 插件逃票(⁎⁍̴̛ᴗ⁍̴̛⁎)，因为实在是负担不起那高昂的费用，也懒得去注册学生账号。然后 vscode 仅仅作为日常的 markdown 编写（因为在曾经在知乎上看到了有人关于 idea 和 vscode 的讨论，普遍认为 vscode 不适合作为大型工程的编辑器使用，而工作后为了效率总会回归 idea 的怀抱的 ♪(´ε ｀ )）所以一直没有去尝试将 vscode 作为主力使用的编辑器。 那么是什么原因导致我抛弃 idea 了呢？主要原因是我想写 c++代码，仅仅作为考研的算法题目编写。而在 idea 上这似乎非常困难。具体有一下几点让我有动力去体验 vscode。 idea 上的 C/C++插件不适用与当前版本（2021.2），于是想要编写 C/C++就需要下载 CLion，而总所周知，JB 系列每个 ide 都超级巨大（至少有 1G 吧），而我的 Mac mini 只有 256G 存储(T ^ T)。而且感觉仅仅为了编写算法题就下载一个专门的编辑器，有种高射炮打蚊子的感觉。 我也曾使用过 CLion，但总感觉 CMake 很难用，至少和以前的使用过习惯非常不同（我仅仅只是想写个算法题，用得着这么麻烦嘛！(╯‵□′)╯︵┻━┻） 为啥 idea 上总会有那么多的 Java 元素，我又不用 Java。为啥不能出一个啥语言预设都没有，可以自定义安装插件的平台呢？我懂，因为那样卖的钱就少了，唉(´Д` ) vscode 上 C/C++还挺好配置的，首先 Mac 上本身就有 gcc 编译器，只用下载一个 C/C++插件就完全够用了！ε-(´∀ ｀; )，非常适合我这种怕麻烦，还患有“pc 存储恐惧症 ”的患者。 有着一点点私心的极客想法，觉得开源超帅！自定义超帅！所以慢慢地从“以后 C/C++代码就在 vscode 上写吧”到“vscode 就是我家，idea 滚出我的电脑！”，逐渐极端化了呢 ╮(╯▽╰)╭ 大致上就是以上的这些原因，总而言之，并不是 idea 不香，而是 vscode 更适合我！（这种无从得出的结论，为了不引战我还真的说得出口呀）。但现在回顾整个配置过程，觉得 vscode 的自定义化之旅并不容易，但一点都不无聊，反而让我感到快乐。所以在此分享我的配置过程(((o(ﾟ ▽ ﾟ)o))) 配置不说废话了，先贴出我的 setting.json { // 单独文件设置 &quot;[go]&quot;: { &quot;editor.codeActionsOnSave&quot;: { &quot;source.organizeImports&quot;: true }, &quot;editor.formatOnSave&quot;: true, &quot;editor.insertSpaces&quot;: true }, &quot;[html]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[http]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;, &quot;editor.quickSuggestions&quot;: { &quot;comments&quot;: false, &quot;other&quot;: true, &quot;strings&quot;: true }, &quot;editor.tabSize&quot;: 2 }, &quot;[javascript]&quot;: { &quot;editor.codeActionsOnSave&quot;: { &quot;source.fixAll&quot;: true, &quot;source.organizeImports&quot;: true }, &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;, &quot;editor.detectIndentation&quot;: false, &quot;editor.tabSize&quot;: 2 }, &quot;[javascriptreact]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[json]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;, &quot;editor.detectIndentation&quot;: false, &quot;editor.tabSize&quot;: 2 }, &quot;[jsonc]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[markdown]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, &quot;[python]&quot;: { &quot;editor.codeActionsOnSave&quot;: { &quot;source.fixAll&quot;: true, &quot;source.organizeImports&quot;: true } }, &quot;[rust]&quot;: { &quot;editor.codeActionsOnSave&quot;: { &quot;source.fixAll&quot;: true, &quot;source.organizeImports&quot;: true }, &quot;editor.defaultFormatter&quot;: &quot;rust-lang.rust&quot; }, &quot;[vue]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;, &quot;editor.detectIndentation&quot;: false, &quot;editor.tabSize&quot;: 2 }, &quot;[yaml]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }, // python 生成文档 &quot;autoDocstring.startOnNewLine&quot;: true, // 彩色注释 &quot;better-comments.highlightPlainText&quot;: true, &quot;better-comments.tags&quot;: [ { &quot;backgroundColor&quot;: &quot;transparent&quot;, &quot;bold&quot;: true, &quot;color&quot;: &quot;#FF8C00&quot;, &quot;italic&quot;: false, &quot;strikethrough&quot;: false, &quot;tag&quot;: &quot;todo&quot;, &quot;underline&quot;: false }, { &quot;backgroundColor&quot;: &quot;transparent&quot;, &quot;bold&quot;: false, &quot;color&quot;: &quot;#3498DB&quot;, &quot;italic&quot;: false, &quot;strikethrough&quot;: false, &quot;tag&quot;: &quot;@&quot;, &quot;underline&quot;: false } ], &quot;bracketPairColorizer.consecutivePairColors&quot;: [&quot;()&quot;, &quot;[]&quot;, &quot;{}&quot;, [&quot;Cyan&quot;], &quot;Red&quot;], &quot;bracketPairColorizer.forceUniqueOpeningColor&quot;: true, &quot;breadcrumbs.enabled&quot;: false, // C++格式化 &quot;C_Cpp.autocompleteAddParentheses&quot;: true, &quot;C_Cpp.clang_format_fallbackStyle&quot;: &quot;Google&quot;, &quot;C_Cpp.clang_format_sortIncludes&quot;: true, &quot;C_Cpp.clang_format_style&quot;: &quot;Google&quot;, // code runner &quot;code-runner.executorMap&quot;: { &quot;applescript&quot;: &quot;osascript&quot;, &quot;bat&quot;: &quot;cmd /c&quot;, &quot;c&quot;: &quot;cd $dir &amp;&amp; gcc $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;csharp&quot;: &quot;scriptcs&quot;, &quot;dart&quot;: &quot;dart&quot;, &quot;fsharp&quot;: &quot;fsi&quot;, &quot;go&quot;: &quot;cd $dir &amp;&amp; go run $fileName&quot;, &quot;groovy&quot;: &quot;groovy&quot;, &quot;haskell&quot;: &quot;runhaskell&quot;, &quot;java&quot;: &quot;cd $dir &amp;&amp; javac $fileName &amp;&amp; java $fileNameWithoutExt&quot;, &quot;javascript&quot;: &quot;node&quot;, &quot;julia&quot;: &quot;julia&quot;, &quot;less&quot;: &quot;cd $dir &amp;&amp; lessc $fileName $fileNameWithoutExt.css&quot;, &quot;lisp&quot;: &quot;sbcl --script&quot;, &quot;lua&quot;: &quot;lua&quot;, &quot;nim&quot;: &quot;nim compile --verbosity:0 --hints:off --run&quot;, &quot;objective-c&quot;: &quot;cd $dir &amp;&amp; gcc -framework Cocoa $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;php&quot;: &quot;php&quot;, &quot;powershell&quot;: &quot;powershell -ExecutionPolicy ByPass -File&quot;, &quot;python&quot;: &quot;python3 -u $fullFileName&quot;, &quot;r&quot;: &quot;Rscript&quot;, &quot;ruby&quot;: &quot;ruby&quot;, &quot;rust&quot;: &quot;cd $dir &amp;&amp; rustc $fileName &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;sass&quot;: &quot;sass --style expanded&quot;, &quot;scala&quot;: &quot;scala&quot;, &quot;scss&quot;: &quot;scss --style expanded&quot;, &quot;shellscript&quot;: &quot;bash&quot;, &quot;swift&quot;: &quot;swift&quot;, &quot;typescript&quot;: &quot;ts-node&quot; }, &quot;code-runner.ignoreSelection&quot;: true, &quot;code-runner.runInTerminal&quot;: true, &quot;code-runner.saveFileBeforeRun&quot;: true, &quot;customizeUI.activityBar&quot;: &quot;bottom&quot;, // vscode advanced 界面 &quot;customizeUI.font.monospace&quot;: &quot;JetBrains Mono&quot;, &quot;customizeUI.font.regular&quot;: &quot;JetBrains Mono&quot;, &quot;customizeUI.fontSizeMap&quot;: { &quot;12px&quot;: &quot;14px&quot;, &quot;13px&quot;: &quot;15px&quot;, &quot;menu&quot;: &quot;13px&quot;, &quot;monospace&quot;: &quot;15px&quot;, &quot;tab-title&quot;: &quot;14px&quot;, &quot;window-title&quot;: &quot;14px&quot; }, &quot;customizeUI.listRowHeight&quot;: 25, &quot;customizeUI.moveStatusbar&quot;: true, &quot;customizeUI.titleBar&quot;: &quot;frameless&quot;, // debug界面 &quot;debug.allowBreakpointsEverywhere&quot;: true, &quot;debug.console.fontFamily&quot;: &quot;JetBrains Mono&quot;, &quot;debug.console.fontSize&quot;: 16, &quot;debug.inlineValues&quot;: true, &quot;debug.showBreakpointsInOverviewRuler&quot;: true, &quot;diffEditor.codeLens&quot;: true, // editor &quot;editor.acceptSuggestionOnEnter&quot;: &quot;on&quot;, &quot;editor.cursorBlinking&quot;: &quot;solid&quot;, &quot;editor.cursorSmoothCaretAnimation&quot;: true, &quot;editor.cursorWidth&quot;: 2, &quot;editor.detectIndentation&quot;: false, &quot;editor.foldingImportsByDefault&quot;: true, &quot;editor.fontFamily&quot;: &quot;JetBrains Mono&quot;, &quot;editor.fontLigatures&quot;: true, &quot;editor.fontSize&quot;: 19, &quot;editor.formatOnSave&quot;: true, &quot;editor.formatOnType&quot;: true, &quot;editor.hover.delay&quot;: 20, &quot;editor.inlayHints.fontFamily&quot;: &quot;JetBrains Mono&quot;, &quot;editor.inlineSuggest.enabled&quot;: true, &quot;editor.linkedEditing&quot;: true, &quot;editor.minimap.enabled&quot;: false, &quot;editor.quickSuggestions&quot;: true, &quot;editor.quickSuggestionsDelay&quot;: 5, &quot;editor.renderControlCharacters&quot;: true, &quot;editor.renderLineHighlightOnlyWhenFocus&quot;: true, &quot;editor.scrollbar.horizontalScrollbarSize&quot;: 10, &quot;editor.scrollbar.vertical&quot;: &quot;visible&quot;, &quot;editor.scrollbar.verticalScrollbarSize&quot;: 10, &quot;editor.scrollBeyondLastColumn&quot;: 0, &quot;editor.showFoldingControls&quot;: &quot;always&quot;, &quot;editor.smoothScrolling&quot;: true, &quot;editor.suggest.insertMode&quot;: &quot;replace&quot;, &quot;editor.suggest.snippetsPreventQuickSuggestions&quot;: false, &quot;editor.suggestSelection&quot;: &quot;first&quot;, &quot;editor.tabSize&quot;: 4, // 错误后缀显示 &quot;errorLens.fontWeight&quot;: &quot;bold&quot;, &quot;errorLens.onSaveTimeout&quot;: 2000, &quot;errorLens.statusBarColorsEnabled&quot;: true, // 资源管理器 &quot;explorer.confirmDelete&quot;: false, &quot;explorer.confirmDragAndDrop&quot;: false, &quot;explorer.incrementalNaming&quot;: &quot;smart&quot;, // 插件扩展 &quot;extensions.closeExtensionDetailsOnViewChange&quot;: true, // 文件 &quot;files.associations&quot;: { &quot;*.cjson&quot;: &quot;jsonc&quot;, &quot;*.wxs&quot;: &quot;javascript&quot;, &quot;*.wxss&quot;: &quot;css&quot; }, &quot;files.autoSave&quot;: &quot;afterDelay&quot;, &quot;files.autoSaveDelay&quot;: 500, &quot;files.defaultLanguage&quot;: &quot;markdown&quot;, &quot;files.eol&quot;: &quot;auto&quot;, &quot;files.exclude&quot;: { &quot;**.DS_Store&quot;: true, &quot;**/__pycache__&quot;: true, &quot;**/.classpath&quot;: true, &quot;**/.factorypath&quot;: true, &quot;**/.project&quot;: true, &quot;**/.settings&quot;: true }, &quot;files.insertFinalNewline&quot;: true, &quot;files.simpleDialog.enable&quot;: true, &quot;files.trimFinalNewlines&quot;: true, &quot;files.trimTrailingWhitespace&quot;: true, // git &quot;git.confirmSync&quot;: false, &quot;git.enableSmartCommit&quot;: true, &quot;git.path&quot;: &quot;/usr/bin/git&quot;, // Go &quot;go.autocompleteUnimportedPackages&quot;: true, &quot;go.docsTool&quot;: &quot;guru&quot;, &quot;go.formatTool&quot;: &quot;default&quot;, &quot;go.gocodePackageLookupMode&quot;: &quot;go&quot;, &quot;go.gotoSymbol.includeImports&quot;: true, &quot;go.toolsManagement.autoUpdate&quot;: true, &quot;go.useCodeSnippetsOnFunctionSuggest&quot;: true, &quot;go.useCodeSnippetsOnFunctionSuggestWithoutType&quot;: true, &quot;go.useLanguageServer&quot;: false, &quot;hediet.vscode-drawio.local-storage&quot;: &quot;eyIuZHJhd2lvLWNvbmZpZyI6IntcImxhbmd1YWdlXCI6XCJcIixcImN1c3RvbUZvbnRzXCI6W3tcIm5hbWVcIjpcIuaJi+acreS9ky3nroBcIn1dLFwibGlicmFyaWVzXCI6XCJnZW5lcmFsXCIsXCJjdXN0b21MaWJyYXJpZXNcIjpbXCJMLnNjcmF0Y2hwYWRcIl0sXCJwbHVnaW5zXCI6W10sXCJyZWNlbnRDb2xvcnNcIjpbXSxcImZvcm1hdFdpZHRoXCI6XCIyNDBcIixcImNyZWF0ZVRhcmdldFwiOmZhbHNlLFwicGFnZUZvcm1hdFwiOntcInhcIjowLFwieVwiOjAsXCJ3aWR0aFwiOjMzMDAsXCJoZWlnaHRcIjo0NjgxfSxcInNlYXJjaFwiOnRydWUsXCJzaG93U3RhcnRTY3JlZW5cIjp0cnVlLFwiZ3JpZENvbG9yXCI6XCIjZDBkMGQwXCIsXCJkYXJrR3JpZENvbG9yXCI6XCIjNmU2ZTZlXCIsXCJhdXRvc2F2ZVwiOnRydWUsXCJyZXNpemVJbWFnZXNcIjpudWxsLFwib3BlbkNvdW50ZXJcIjowLFwidmVyc2lvblwiOjE4LFwidW5pdFwiOjEsXCJpc1J1bGVyT25cIjpmYWxzZSxcInVpXCI6XCJcIn0ifQ==&quot;, // jupyter &quot;jupyter.magicCommandsAsComments&quot;: true, // lua &quot;Lua.color.mode&quot;: &quot;SemanticEnhanced&quot;, &quot;Lua.completion.callSnippet&quot;: &quot;Both&quot;, &quot;Lua.completion.displayContext&quot;: 3, &quot;Lua.hint.enable&quot;: true, // markdown &quot;markdown.extension.italic.indicator&quot;: &quot;_&quot;, &quot;markdown.preview.breaks&quot;: true, &quot;markdown.preview.fontFamily&quot;: &quot;JetBrains Mono&quot;, &quot;markdown.preview.fontSize&quot;: 20, &quot;notebook.cellToolbarVisibility&quot;: &quot;hover&quot;, &quot;prettier.printWidth&quot;: 120, // prettier &quot;prettier.proseWrap&quot;: &quot;always&quot;, // Python &quot;python.analysis.completeFunctionParens&quot;: true, &quot;python.analysis.typeCheckingMode&quot;: &quot;off&quot;, &quot;python.autoComplete.addBrackets&quot;: true, &quot;python.defaultInterpreterPath&quot;: &quot;/opt/homebrew/Caskroom/miniforge/base/envs/rs/bin/python&quot;, &quot;python.formatting.blackArgs&quot;: [&quot;--line-length=100&quot;], &quot;python.formatting.blackPath&quot;: &quot;/opt/homebrew/Caskroom/miniforge/base/bin/black&quot;, &quot;python.formatting.provider&quot;: &quot;black&quot;, &quot;python.formatting.yapfPath&quot;: &quot;/opt/homebrew/Caskroom/miniforge/base/bin/yapf&quot;, &quot;python.languageServer&quot;: &quot;Default&quot;, &quot;python.linting.enabled&quot;: true, &quot;python.linting.flake8Args&quot;: [ &quot;--ignore=E402, E225, E501, E124, W504, E125, W503, E203, E306, E302, E401, E722, F401&quot; ], &quot;python.linting.flake8Enabled&quot;: true, &quot;python.linting.flake8Path&quot;: &quot;/opt/homebrew/Caskroom/miniforge/base/bin/flake8&quot;, &quot;python.linting.mypyEnabled&quot;: false, &quot;python.linting.pylintEnabled&quot;: false, &quot;python.linting.pylintPath&quot;: &quot;/opt/homebrew/Caskroom/miniforge/base/bin/pylint&quot;, &quot;python.pythonPath&quot;: &quot;/opt/homebrew/Caskroom/miniforge/base/envs/rs/bin/python&quot;, &quot;python.terminal.activateEnvironment&quot;: false, &quot;redhat.telemetry.enabled&quot;: true, &quot;scm.alwaysShowActions&quot;: true, &quot;scm.alwaysShowRepositories&quot;: true, &quot;scm.defaultViewMode&quot;: &quot;tree&quot;, // 搜索 &quot;search.actionsPosition&quot;: &quot;auto&quot;, &quot;search.collapseResults&quot;: &quot;auto&quot;, &quot;search.followSymlinks&quot;: false, &quot;search.maxResults&quot;: 100, &quot;search.quickOpen.includeSymbols&quot;: true, &quot;search.smartCase&quot;: true, &quot;security.workspace.trust.enabled&quot;: false, // 安全性 &quot;security.workspace.trust.untrustedFiles&quot;: &quot;open&quot;, // 终端 &quot;terminal.external.osxExec&quot;: &quot;/Applications/iTerm.app&quot;, &quot;terminal.integrated.cursorStyle&quot;: &quot;line&quot;, &quot;terminal.integrated.cursorWidth&quot;: 2, &quot;terminal.integrated.defaultProfile.osx&quot;: &quot;zsh&quot;, &quot;terminal.integrated.defaultProfile.windows&quot;: &quot;C:\\\\Windows\\\\System32\\\\cmd.exe&quot;, &quot;terminal.integrated.fontSize&quot;: 16, &quot;terminal.integrated.gpuAcceleration&quot;: &quot;auto&quot;, &quot;terminal.integrated.inheritEnv&quot;: false, &quot;terminal.integrated.tabs.hideCondition&quot;: &quot;never&quot;, &quot;terminal.integrated.tabs.showActions&quot;: &quot;never&quot;, &quot;terminal.integrated.tabs.showActiveTerminal&quot;: &quot;always&quot;, // 窗口界面 &quot;window.nativeTabs&quot;: true, &quot;window.titleBarStyle&quot;: &quot;native&quot;, &quot;workbench.colorTheme&quot;: &quot;Monokai Pro (Filter Spectrum)&quot;, &quot;workbench.commandPalette.history&quot;: 10, &quot;workbench.editor.decorations.colors&quot;: true, &quot;workbench.editorAssociations&quot;: { &quot;*.ipynb&quot;: &quot;jupyter-notebook&quot;, &quot;*.woff&quot;: &quot;default&quot; }, &quot;workbench.fontAliasing&quot;: &quot;auto&quot;, &quot;workbench.hover.delay&quot;: 1000, &quot;workbench.iconTheme&quot;: &quot;Monokai Pro (Filter Spectrum) Icons&quot;, &quot;workbench.list.smoothScrolling&quot;: true, &quot;workbench.sash.size&quot;: 1, &quot;workbench.settings.editor&quot;: &quot;json&quot;, &quot;workbench.startupEditor&quot;: &quot;none&quot;, &quot;workbench.tree.renderIndentGuides&quot;: &quot;always&quot;, &quot;workbench.view.alwaysShowHeaderActions&quot;: true } 有需要的人可以直接拿走，但接下来我就来说明一下各种配置详情吧！ 主题/图标设置主题我使用的主题是 Monokai Pro 个人比较喜欢这种暗色的主题. 图标我使用的是“Material Icon Theme”，相比于“vscode-icons”，颜色更鲜明，不同种类的文件夹颜色不同。而且灰色的初始文件夹感觉还不错。 语言设置C++&quot;C_Cpp.clang_format_fallbackStyle&quot;: &quot;Google&quot; 仅仅只需要一行，是不是很简单，而且这个还是指定的代码格式化风格。（我个人比较喜欢将左括号放在上面的） Gogo 语言的设置也挺简单的，但在我这出现了一些问题，由于我的 gopls 总是安装不成功，老是显示 XXX 不再 GOROOT 内，所以使用的是 go 的工具链。 在安装完 vscode 的 Go 插件后，只需要在搜索栏敲下 Go: Install/Update Tools 命令，并将所有 go tools 勾选并下载就可以了！ 剩下的就是关于格式化和自动导包的问题了，这些问题使用我配置中的“go 设置”就可以完成。 不过需要注意的是，刚配置完成，可能并不会起效果，可能需要重启 vscode 才会发挥作用。 python说实话，python 的配置是我话费最长时间的（可能和我主要使用 python 有关吧，总有许多痛点看似解决了，但又没解决…） 首先，我使用 Pylance 作为语言服务，相比于“Microsoft”，我认为其提示得更全面，而且有些库在提示显示后按 tab 可以自动导包。 然后是 linting，我选用导是 flake8，因为其设置非常方便，有些规则我不想使用，可以在 args 中忽略。 最后是 format，这个我非常纠结，在 black 和 yapf 中抉择了很长一段时间，最后选择 yapf 了。具体原因嘛，我认为 yapf 自定义更方便，既然追求自定义，那就贯彻到底吧。 然后就是其他的一些设置。 使用“Python Docstring Generator”插件来生成注释字符串。 使用“Python Indent”插件来处理 python 换行的缩进问题。 使用“TabOut”插件，可以按 tab 跳转至括号后 界面进阶设置由于我是用的是 2K 的外接屏幕，而对于 Mac mini m1 来说，这种屏幕完全没办法开启 hidqi，所以使用 vscode 时侧边栏的字体会显示的特别小，而且非常不好看。 为了解决这个问题，我使用“Customize UI”插件来设置 vscode 页面。 相关设置，可以查看插件介绍 总结vscode 是真的不错，以后再也不用下载庞大的 ide 了，还可以支持所有的语言！而且配置环境只需要开启“设置同步”就可以完美创建一个属于你的自定义编辑器啦！(´▽ ｀)","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"/tags/vscode/"},{"name":"工具","slug":"工具","permalink":"/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"苏州大学2017年872试题","slug":"苏州大学2017年试题","date":"2021-08-02T02:33:15.000Z","updated":"2024-03-02T16:13:04.362Z","comments":true,"path":"2021/08/02/苏州大学2017年试题/","link":"","permalink":"/2021/08/02/苏州大学2017年试题/","excerpt":"","text":"数据结构线性表用顺序存储结构实现线性表时, 在线性表中查找等于 x 的元素, 通常先在线性表尾部添加一个等于 x 的元素, 这样做可以加快查找速度, 为什么? 用单链表实现线性表时, 能否加快速度, 为什么? 之所以可以加快查找速度, 是因为如果不添加一个等于 x 的元素, 就需要在每次循环中判断数组是否越界. 而添加了一个等于 x 的元素后, 最后一定能找到等于 x 的元素, 因此就无需判断是否越界. 从而减少了每次循环的判断越界的 CPU 计算, 因此加快了查找速度. 而在用单链表实现的线性表中, 由于链表若是要在尾部添加一个等于 x 的元素, 就需要完全遍历一遍链表. 回消耗大量的时间, 因此无法加快查找速度. 基数排序用基数排序堆关键字序列 012,321,234,543,456,765,678,987,890,109 从小到大排序,写出各趟排序结果. 第一趟: 890, 321, 012, 543, 234, 765, 456, 987, 678, 109 第二趟: 109, 012, 321, 234, 543, 456, 765, 678, 987, 890 第三趟: 012, 109, 234, 321, 456, 543, 678, 765, 890, 987 最小的 100 个数def less_nums(n: int) -&gt; List[int]: &quot;&quot;&quot; 一个序列有如下性质: 1. 1 在序列中. 2. 如果x在序列中, 那么2*x, 3*x, 5*x也在序列中. 求这个序列中最小的n个数字. Args: n (int): 输入. Returns: List[int]: 序列中最小的n个数字. &quot;&quot;&quot; res = [1] def dfs(idx: int): if any(not idx % item for item in [2, 3, 5]): res.append(idx) nonlocal n n -= 1 if n != 1: dfs(idx + 1) dfs(1) return res 排序树中第 k 大元素def max_k(node: Optional[SearchTree], k: int) -&gt; Optional[SearchTree]: &quot;&quot;&quot; 求一个二叉排序树中第K大的元素. 每个结点有一个特殊的属性r_size, r_size = 右子树的结点 个数 + 1. 可以根据 r_size 求解. 对于每个节点, 可以求得右子树中比它本身大的个数, 那么就可以根据 二叉排序树的性质进行递归求解了. Args: node (Optional[SearchTree]): 二叉排序树根结点. k (int): 第K大的数. Returns: Optional[SearchTree]: 返回第K大的结点. &quot;&quot;&quot; if not node: return None if node.r_size == k: return node elif node.r_size &lt; k: return max_k(node.left, k - node.r_size) else: return max_k(node.right, k) 邻接表的广度有限搜索算法def bfs(ad_list: AdjacencyList, start: int, end: int)-&gt;bool: &quot;&quot;&quot; 使用广度优先算法搜索用邻接表实现的有向图是否存在一条从 start 出发, 到 end 结束的路径. 简单的广度优先搜索, 比较困难的反而是构建数据结构并初始化一个图. Args: ad_list (AdjacencyList): 用邻接表实现的有向图. start (int): 出发点. end (int): 终点. Returns: bool: 是否存在这样一条路径. &quot;&quot;&quot; from collections import deque dq = deque() dq.appendleft(start) path = set() while dq: idx = dq.pop() if idx == end: return True next_node = ad_list.get_next_node(idx) while next_node: if next_node not in path: dq.appendleft(next_node.val) path.add(next_node) next_node = next_node.next return False 操作系统判断题 操作系统实现双模式需要硬件支持. 正确, 操作系统切换用户态和内核态需要通过中断、异常、陷入机制. 都需要硬件支持. 操作系统通过人机接口和系统程序为用户提供服务. 错误, 通过程序接口和操作接口. 一个系统有 n 个进程, 最多有一个进程处于运行状态. 错误, 多核操作系统可以使多个进程处于运行状态. 线程是资源分配的基本单位。 错误, 线程是 CPU 调度的最小单位, 进程时资源分配的最小单位. 在有 m 个进程的系统中产生死锁时, 死锁进程的个数 k 满足条件 1&lt;k&lt;m. 错误, 死锁进程的个数 k 满足条件 1&lt;k&lt;=m. 触摸屏是个输出设备 错误, 屏幕可以显示画面, 是输出设备, 而触摸可以进行操作, 是输入设备. 因此触摸屏即是输出设备又是输入设备. 一个 1200RPM 磁盘的平均旋转延迟时间是 5ms 错误, 平均旋转延迟为 60*1000/1200/2 = 2.5ms. 磁盘上存储的文件一般组织为顺序文件. 正确. 产生颠簸的原因是内存中的进程太多. 错误, 运行进程的大部分时间用于进行页面的换入和换出, 而几乎不能完成任何有效的工作, 称这时的进程处于“抖动”状态, 也称为系统颠簸. 因此产生颠簸的原因是可用内存过小, 内存中的进程太多仅仅是可能的一个因素. 树形目录和无环图目录无法实现文件共享. 错误, 树形目录只是不便于实现文件的共享. 无环图目录在树形目录的基础上, 更加方便的实现了多个用户间的文件共享. PV 操作使用管程来实现读者优先的读写者问题, 并写出管程的伪代码以及读写者的伪代码. 定义管程代码段 定义过程 start_read() 定义过程 end_read() 定义过程 start_write() 定义过程 end_write() monitor RW{ // 定义管程的过程 int read_count = 0; bool is_writing = false; condition r, w; void start_read(){ if(is_writing){ wait(r); } read_count++; signal(r); } void end_read(){ read_count--; if(read_count==0){ signal(w); } } void start_write(){ if(read_count!=0 || is_writing){ wait(w); } is_writing = true; } void end_write(){ is_writing = false; signal(r); } } 读写者代码段 void reader(){ while(1){ RW.start_read(); // 读取文件操作 RW.end_read(); } } void writer(){ while(1){ RW.start_write(); // 写入文件操作 RW.end_write(); } } 逻辑地址和物理地址一个进程 p 的空间为 64k, 运行在一个请求式分页系统中, 每个页面大小为 8k, 该进程的页表如下. 页号 页框号 有效位 0 12 1 1 3 1 2 0 1 3 6 0 4 2 1 5 15 0 6 5 1 7 8 0 其中, 有效位=1 表示页面在内存, 0 表示页面不在内存, 请将逻辑地址 0x050c、0x1302、0x1f71、0x2c57、0x4400 转换为对应的物理地址并写出计算过程. 由于空间为 64K, 每个页面大小为 8K, 因此最多有 8 个页面. 因此虚拟地址中页号需要占用 3 位. 页内偏移占用 13 位. 因此: 0x050c 二进制为: 000|0 0101 0000 1100, 页号为 0, 因此页框号为 12 = 1100, 因此转换为物理地址后为 0001 1000 0101 0000 1100 = 0x1850c 0x1302 二进制为: 000|1 0011 0000 0010, 页号为 0, 因此页框号为 12 = 1100, 因此转换为物理地址后为 0001 1001 0011 0000 0010 = 0x19302 0x1F71 二进制为: 000|1 1111 0111 0001, 页号为 0, 因此页框号为 12 = 1100, 因此转换为物理地址后为:0001 1001 1111 0111 0001 = 0x19F71 0x2c57 二进制为: 001|0 1100 0101 0111, 页号为 1, 因此页框号为 3 = 0011, 因此转换为物理地址后为:0000 0110 1100 0101 0111 = 0x06c57 0x4400 二进制为: 010|0 0100 0000 0000, 页号为 2, 因此页框号为 0 = 0000, 因此转换为物理地址后为:0000 0000 0100 0000 0000 = 0x00400 文件系统一个文件系统采用索引方式分配磁盘, 其中磁盘块的大小为 4KB, 索引块大小为 32 位. 回答如下问题: 一级索引的文件 A, 二级索引的文件 B, 三级索引的文件 C 容量最大为多少. 索引项大小为 32/8 = 4B, 4KB/4B = 1024 块, 因此一个索引文件可以存放 1024 个索引项. 因此 A 的最大容量为 1024*4KB = 4MB, B 的最大容量为 1024*1024*4KB = 4GB, C 的最大容量为 1024*1024*1024*4KB = 4TB. 假设上述 A、B、C 文件控制块在内存, 则删除文件 A、B 和 C 的任意一块物理块需要读或写多少个磁盘块. 删除 A 中的一块物理块: 首先通过文件控制块访问索引块删除目标物理块的索引. 因此需要访问 1 次. 删除 B 中的一块物理块: 首先通过文件控制块访问一级索引块, 然后访问二级索引块删除目标物理块的索引.因此需要访问 2 次. 删除 C 中的一块物理块: 首先通过文件控制块访问一级索引块, 然后访问二级索引块, 然后访问三级索引块删除目标物理块的索引, 因此需要访问 3 次. 假设上述文件 A、B 和 C 的文件控制块在内存, 则在文件 A、B 和 C 尾部插入一个物理块最多需要读或写多少个磁盘块? 在 A 中插入一块物理块: 首先通过文件控制块访问索引块, 然后通过索引项访问物理块 . 因此需要访问 2 次. 在 B 中插入一块物理块: 首先通过文件控制块访问一级索引块, 然后访问二级索引块, 最后访问物理块. 因此需要访问 3 次. 在 C 中插入一块物理块: 首先通过文件控制块访问一级索引块, 然后访问二级索引块, 然后访问三级索引块,最后访问物理块, 因此需要访问 4 次. 分析题请举例说明, 和 FCFS 相比, SJF 可以获得更短的平均等待时间, RR 可以获得更短的平均响应时间. 有如下进程, 其加入时间和需要运行时间如下: 进程名 加入时间 运行时间 P1 0 3 P2 1 4 P3 2 1 如果使用 FCFS 算法: 执行顺序为: P1-&gt;P2-&gt;P3 平均等待时间为: (0+2+5)/3 = 2.33 平均响应时间为: (0+2+5)/3 = 2.33 如果使用 SJF 算法: 执行顺序为: P1-&gt;P3-&gt;P2 平均等待时间为: (0+1+3)/3 = 1.33 平均响应时间为: (0+1+3)/3 = 1.33 如果使用 RR 算法: 假设时间片长度为 1. 那么执行顺序为: P1-&gt;P2-&gt;P3-&gt;P1-&gt;P2-&gt;P1-&gt;P2-&gt;P2 平均等待时间为: (3+3+0)/3 = 2 平均响应时间为: (0+0+0)/3 = 0 根据这个例子, 就能看出 SJF 相比于 FCFS 可以获得更短的平均等待时间, RR 相比于 FCFS 可以获得更短的平均响应时间.","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"考研","slug":"考研","permalink":"/tags/考研/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"/tags/数据结构和算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"苏州大学2016年872试题","slug":"苏州大学2016年试题","date":"2021-08-01T16:21:15.000Z","updated":"2024-03-02T16:13:05.005Z","comments":true,"path":"2021/08/02/苏州大学2016年试题/","link":"","permalink":"/2021/08/02/苏州大学2016年试题/","excerpt":"","text":"数据结构散列表什么是哈希函数? 什么是哈希查找? 如何解决冲突? 分析影响哈希查找算法的性能的因素. 哈希函数: 根据给定的关键字来计算出关键字再给定点哈希表中的地址的函数. 哈希查找: 是根据哈希函数并结合冲突解决方法在已构造的哈希表中查找关键字的一种查找方法. 哈希查找的时间复杂度一般为 O(1) 解决冲突可以通过多种方法进行解决. 比如: 开放定址法, 链地址法; 线性探测法式从发生冲突的地址开始依次查找下一个地址, 直到找到一个空位置为止. 而链地址法是将地址相同的元素使用一个链表记录下来, 这样访问的时候就只需要遍历链表. 影响哈希查找算法性能的因素: 哈希表的性能主要看平均查找长度, 与关键字个数无关, 与装填因此有关. 二叉查找树什么是二叉查找树? 什么是 AML 树? 将关键字 50,40,30,60,70,10,20,80 依次插入一棵初始为空的 AML 树, 画出最后所得的 AML 树. 二叉查找树又称二叉排序树, 它是一棵空树或者是具有下列性质的二叉树: 1. 若它的左子树不为空, 则左子树的所有节点的值均小于它的根结点的值. 2. 若它的右子树不为空, 则右子树上所有结点的值均大于它的根结点的值. 3. 它的左, 右子树也为二叉排序树. AVL 树: 以树中所有结点为根的树的左右子树高度之差的绝对值不超过 1 的特殊的二叉查找树. 最后构建的 AVL 树为: 去除链表重复的元素def copy_without_same_node(node: ListNode) -&gt; ListNode: &quot;&quot;&quot; 去除链表的重复结点. 采用set去重. Args: node (ListNode): 链表. Returns: ListNode: 去重后的链表. &quot;&quot;&quot; new_node = node node_map = {node.val} while node.next: if node.next.val in node_map: node.next = node.next.next else: node_map.add(node.next.val) node = node.next return new_node 数组中最小连续序列def min_subsequence(arr: list[int]) -&gt; int: &quot;&quot;&quot; 求顺序表中连续序列的最小值. 和求连续序列的最大值相同的做法, 只需要遍历一次顺序表, 在遍历过程中, 记录当前总和, 如果大于零则丢弃前面的序列, 因为大于零的之前的序列无法在最后获得最小值. Args: arr (List[int]): 顺序表 Returns: int: 顺序表中连续序列的最小值. &quot;&quot;&quot; res, idx = 0, 0 for x in arr: idx += x if idx &gt; 0: idx = 0 else: res = min(idx, res) return res n 个结点有多少种不同二叉树from functools import lru_cache @lru_cache() def n_node_tree_num(n: int) -&gt; int: &quot;&quot;&quot; n 个结点可以有多少种不同的二叉树. 由于该问题具有重复子结构的特性, 具体为 f(n) = f(0)*f(n-1) + f(1)*f(n-2) ... f(n-2)*f(1) + f(n-1)*f(0) 由于题目要求使用递归函数的形式编写, 而若是普通递归会造成大量的重复计算, 因此采用 Python的函数缓存, 将函数结果保存下载, 避免重复计算. Args: n (int): n 个结点. Returns: int: 可以构成的二叉树个数. &quot;&quot;&quot; if n == 0: return 1 return sum( n_node_tree_num(i) * n_node_tree_num(n - i - 1) for i in range(n) ) 操作系统判断题 操作系统最主要的目标是运行程序. 操作系统最主要的目标是方便性和有效性. 进程 A 和 B 共享变量 x, 需要互斥执行; 进程 B 和 C 共享变量 y, 需要互斥执行. 因此, 进程 A 和 C 也必须互斥执行. 错误, A 和 C 可以同时执行. 存在外碎片的内存分配机制有连续分配和段页式分配两种。 错误, 连续分配不会存在外碎片, 会存在已经分配的内存却不会使用的内碎片. 如果一个计算机的硬盘为 4GB,每个块的大小为 512B,用位示图来管理该硬盘的空间,则位示图的大小为 8MB。 4*1024*1024*1024/512 = 8MB, 所以正确. 当时间片轮转算法的时间片足够大时, 该算法等同于先来先服务算法. 正确, 时间片足够大, 说明可以在一个时间片完成一个进程. 也就相当于先来先服务算法. Unix 所采用的设计结构是模块化结构. 错误, Unix 采用的设计结构是整体结构. 用户级线程适合运行在多处理器架构下. 错误, 用户级线程是由程序自己控制调度的, 因此内核一次只会为一个进程分配一个处理器. 因此是内核级线程更适合运行在多处理器架构下. 一个操作系统有 20 个进程, 竞争使用 30 个同类资源. 资源申请方式是每次申请一个, 一旦某个进程获得了它需要的全部该类资源, 就可以马上运行完并归还所有申请的资源 . 假设每个进程最多需要该类资源 30 个,最少需要 1 个, 并且 20 个进程需要的资源总数小于 50. 如果仅考虑这类资源, 系统不会产生死锁. 正确, 不可能会产生死锁. 最极端的例子中: 19 个进程需要 2 个资源, 1 个进程需要 11 个资源. 那么当 19 个进程都占有 1 个资源, 最后一个资源占有 10 个资源的时候, 有 29 个资源已经被分配, 还有 1 个资源可以被分配, 而任一一个进程分配到资源都会马上运行完并归还所有申请的资源. 因此不会发生死锁. 在 I/O 设备管理中, 假脱机(Spooling)和缓冲技术均以内存为基础来设置缓冲空问. 错误, Spooling 技术还可以使用磁盘来设置缓冲空间. 在一个请求式分页系统中, 采用最近使用先淘次页面置换算法(和 LRU 相反, 先淘汰最近使用的页面)时, 假如一个进程的页面走向为 4、3、2、1、4、3、5、4、3、2、1、5, 当分配给该作业的物理块数为 3 时, 访问过程中发生的缺页次数为 13. 缺页次数为 7, 不为 13. 因此错误. 访问过程如下图: 1 2 3 change 4 √ 4 3 √ 4 3 2 √ 4 3 1 √ 4 3 1 4 3 1 4 5 1 √ 4 5 1 3 5 1 √ 2 5 1 √ 2 5 1 2 5 1 内存访问 由于缺页率为 0, 因此都是访问内存需要先访问页表再访问内存地址, 因此有效访问时间为 200ns. 磁盘访问时间 = 寻道时间+旋转延迟时间+传输时间. 寻道时间 = 5ms. 旋转访问延迟时间 = (1/r)/2 =(60/7200)/2 s = 4.133ms. 传输时间 = 4KB/(1024*1024 KB/s) = 4000/(1024*1024) = 0.004ms. 因此平均磁盘访问时间为 9.137ms (1-0.01)*200 + 0.01*(100+((1-0.2)*0.1*1000+0.29.1371000)+100) = 408.74ns. 文件检索提高效率方案: 文件的目录结构方面: 采用树型目录结构, 树型目录结构具有能有效提高对目录的检索速度; 文件的逻辑结构方面:由于对此文件的操作主要是根据姓名和身份证号进行检索, 因此可以根据姓名的长度(字数相同的)对文件进行分目录存储 或者根据姓名的姓的拼音首字母分目录存储, 身份证号(同一个省份的每个身份的前几位都相同)按前几位分目录存储. 文件中的个人身份信息属性一致, 所以可以认为每个人的身份信息大小相同, 因此可以将这个文件的逻辑文件信息连续存放, 即采用顺序文件的方式. 文件的物理结构方面: 可以采用连续分配的方式, 把逻辑文件中的个人身份信息顺序地存锗到相邻的物理盘块中; 这样查找速度快, 且基本没有空间浪费. PV 操作任务图大致为: Semaphore s2=2, s1=0, r1=0, r2=0; // 初始化各个进程的信号量. 从s2开始运行. Semaphore mutex = 1; // 代表缓冲区读写权限的信号量. Procedure S1(){ while(1){ P(s1); P(mutex); // 将s1的消息发送到缓冲区 V(mutex); V(r1); V(r2); } } Procedure S2(){ while(1){ P(s2); P(s2); P(mutex); // 将s2的消息发送到缓冲区 V(mutex); V(s1); } } Procedure R1(){ while(1){ P(r1); P(mutex); // 读取s1的消息. V(mutex); V(s2); } } Procedure R2(){ while(1){ P(r2); P(mutex); // 读取s1和s2的消息. V(mutex); V(s2); } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"考研","slug":"考研","permalink":"/tags/考研/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"/tags/数据结构和算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"苏州大学2015年872试题","slug":"苏州大学2015年试题","date":"2021-07-29T02:27:15.000Z","updated":"2024-03-02T16:13:04.022Z","comments":true,"path":"2021/07/29/苏州大学2015年试题/","link":"","permalink":"/2021/07/29/苏州大学2015年试题/","excerpt":"","text":"数据结构判断题 若有一个栈的输入序列是 1,2,3,…,100, 输出序列的第一个元素是 100, 则第 50 个输出元素是 50. 错误, 第一个输出的是 100, 那么第 50 个输出的是 51. 在一个有向图中, 所有顶点的入度之和等于所有顶点的出度之和. 正确, 对于每一条边, 都会增加一个出度和一个入度, 因此所有顶点的入度之和等于所有顶点的出度之和. 在拓扑排序序列中, 任意两个结点 i 和 j, 都存在从 i 到 j 的路径. 错误, 如果在拓扑排序序列中, i 在 j 之前, 那么都存在从 i 到 j 的路径. 如果 i 在 j 之后, 那么不存在从 i 到 j 的路径. 在哈希表中, 装填因子的值越小, 存取元素时发生冲突的可能性就越小. 正确, 装填因子 = 关键字个数 / 表长. 因此装填因子越小, 代表空间浪费越多, 冲突可能性越小. 任何一个无向连通图的最小生成树只有一棵. 错误, 可能存在不同的最小生成树. 简答题简述堆排序算法的基本思想. 对于快速排序而言, 堆排序有哪些优势? 对于归并排序而言堆排序有哪些优势? 假定有 8000 个整数, 需要找出最大的 10 个数, 在堆排序、快速排序、基数排序方法中, 采用哪种方法最好? 请说明理由. 堆排序是通过将关键字调整为堆, 然后依次将堆顶的元素和放入到有序区, 每次放入后都需要整理堆的结构. 直到全部的元素都放入到有序区中. 对于快速排序, 堆排序在最坏的情况下时间复杂度也为 O(n*log(n)), 而快速排序在最坏情况下时间复杂度为O(n^2), 并且堆排序的空间复杂度为 O(1), 而快速排序的空间复杂度为 O(log(n)). 对于归并排序, 堆排序的空间复杂度为 O(1), 而归并排序的空间复杂度为 O(n). 采用堆排序最好, 因为如果使用大顶堆, 只需要进行 1 次建堆, 10 次推出并调整堆就可以选出 10 个最大的数了. 而不必等到全部数排序好后选出, 因此堆排序最快. 递归创建二叉树def init_tree_by_list( chs: Optional[List[str]], idx: int = 0 ) -&gt; Optional[TreeNode]: &quot;&quot;&quot; 递归创建二叉树. Args: chs (Optional[List[str]]): 二叉树堆值的列表. idx (int, optional): 当前节点所在列表的下标. Defaults to 0. Returns: Optional[TreeNode]: 生成的二叉树. &quot;&quot;&quot; if chs and idx &lt; len(chs): return TreeNode( val=chs[idx], left=init_tree_by_list(chs, idx * 2 + 1), right=init_tree_by_list(chs, idx * 2 + 2), ) 两数之和-链表版def two_sum2(node: DulLinkedList, target: int) -&gt; str: &quot;&quot;&quot; 两数之和, 双链表版. 由于采用双链表, 并且有序, 因此可以使用双指针法. Args: node (DulLinkedList): 双链表. target (int): 目标数. Returns: str: 返回信息. &quot;&quot;&quot; cur = node while cur.next: cur = cur.next tail, head = cur, node while tail and head and tail != head: if tail.val + head.val == target: return f&quot;{target} = {head.val} + {tail.val}&quot; elif tail.val + head.val &lt; target: head = head.next else: tail = tail.pre return &quot;not exist two numbers sum equals target.&quot; 两个有序顺序表的中间值def two_order_list_median(lst1: list[int], lst2: list[int]) -&gt; float: &quot;&quot;&quot; 二分法求解. 对于两个有序数组, 可以划分为两部分, 一部分小于等于中位数, 一部分大于中位数. 而中位数 就可以在这条边界旁取得. 因此我们可以通过二分的方法分别在两个数组中找到这条边界. Args: lst1 (list[int]): 顺序表1 lst2 (list[int]): 顺序表2 Returns: float: 中位数. &quot;&quot;&quot; m, n = len(lst1), len(lst2) def get_Kth_element(k): idx1, idx2 = 0, 0 while True: if idx1 == m: return lst2[idx1 + k - 1] if idx2 == n: return lst1[idx1 + k - 1] if k == 1: return min(lst1[idx1], lst2[idx2]) new_idx1 = min(idx1 + k // 2 - 1, m - 1) new_idx2 = min(idx2 + k // 2 - 1, n - 1) pivot1, pivot2 = lst1[new_idx1], lst2[new_idx2] if pivot1 &lt;= pivot2: k -= new_idx1 - idx1 + 1 idx1 = new_idx1 - 1 else: k -= new_idx2 - idx2 + 1 idx2 = new_idx2 + 1 total_length = m + n if total_length % 2 == 1: return get_Kth_element((total_length + 1) // 2) return ( get_Kth_element(total_length // 2) + get_Kth_element(total_length // 2 + 1) ) / 2 操作系统判断题 所有用户进程都必须常驻内存. 错误, 并非所有进程都常驻于内存中的, 一般只有正在执行的进程在内存中. 有 m 个进程的操作系统出现死锁时, 死锁进程个数的范围为 1&lt;k&lt;=m. 正确, 死锁是由两个或两个以上进程对于互斥资源的抢夺造成的. 因此死锁进程个数的范围为 1&lt;k&lt;=m. 除了 FCFS, 其它的磁盘调度算法都会出现饥饿现象. 错误, SCAN 算法也不会出现饥饿现象. 増加内存中的进程数量, 可以提高 CPU 的利用率. 错误, 增加内存中的进程数量, 可能会导致分配给现有正在运行的进程的内存减少, 从而使得需要花费更多的时间用于内存调度, 从而减少了 CPU 的利用率. 在分页式存储管理中, 引入 TLB 可减少每一次的内存访问时间. 错误, 如果需要访问的内存地址不存在于 TLB 中(未命中), 会增加访问其的时间. 解答题 t\\p P1 P2 P3 P4 P5 0s 8 1s 10 4 2s 9 6 6 3s 8 # 5 2 4s 7 4 # 10 5s 6 6 9 6s 5 8 8 7s 7 7 7 8s # 6 6 9s # 5 10s 7 11s # 因此 5 个进程执行的顺序图为: P1-&gt;P2-&gt;P2-&gt;P4-&gt;P3-&gt;P3-&gt;P1-&gt;P1-&gt;P3-&gt;P5-&gt;P5-&gt;P5 因为 周转时间 = 完成时间 - 到达时间, 并且 响应时间 = 第一次处理时间 - 到达时间. 因此每个进程的周转时间和响应时间为: 进程编号 P1 P2 P3 P4 P5 周转时间 8 2 7 1 7 响应时间 0 0 2 0 5 PV 操作 Semaphore msg = 1 // 用于实现对缓冲区的互斥操作, 初始值为1 Semaphore reader[n]=0 // 控制n个读者是否已经读取完消息, 全部初始为1 Procedure B(){ // 发送者进程/ while(1){ P(msg); // 清空缓冲区 // 将消息发送至缓冲区 int i; for(i=0;i&lt;n;i++){ V(reader[i]); } V(msg); } } Procedure A(int i){ // 接收者进程, i标记了为哪一个接收者. while(1){ P(reader[i]) P(msg); // 从缓冲区取出消息 // 读取消息 // 将消息放回缓冲区 V(msg); } } 分析题 对于每条记录, 需要大小为 4*2 + 2 + 128*2 + 18 + 2 + 4 = 290 Byte 文件的总大小为 290000000 Byte = 290000 KB = 290 MB 逻辑文件结构: 由于主要操作为根据姓名进行记录查询. 因此可以根据姓名对文件进行分目录存放. 相同长度姓名的记录在同一个目录中, 这样可以方便根据姓名查找. 因此可以将这个文件的逻辑文件信息连续存放, 即采用顺序文件的方式. 物理文件结构: 由于每条记录的大小相差不大. 因此可以采用连续分配的方式, 把逻辑文件中的记录顺序地存储在相邻的物理盘块中; 这样查找速度快, 且没有太大的空间浪费. (1) 因为每个磁盘块为 1KB, 因此文件需要 290000 个磁盘块. (2) 平均需要 290000/2 = 145000 个磁盘块.","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"考研","slug":"考研","permalink":"/tags/考研/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"/tags/数据结构和算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"苏州大学2014年872试题","slug":"苏州大学2014年试题","date":"2021-07-28T02:27:15.000Z","updated":"2024-03-02T16:13:05.018Z","comments":true,"path":"2021/07/28/苏州大学2014年试题/","link":"","permalink":"/2021/07/28/苏州大学2014年试题/","excerpt":"","text":"数据结构判断题 在一个图中,所有顶点的度数之和等于所有边的总数. 错误, 所有顶点的度数只和等于所有边的总数的两倍. 快速排序在被排序数据已基本有序的情况下最易发挥其长处. 错误, 快速排序在基本无序的情况下发挥其长处. 冒泡排序在数据已基本有序的情况下最易发挥其长处. 求子串的定位操作称为串的模式匹配. 正确. 串的模式匹配, 就是求模式串在主串中的位置. Dijkstra迪杰斯特拉(Dijkstra)算法的用途是什么? 说明其基本思想, 并验证该算法的正确性. 为实现该算法, 如何设计图的数据结构? 用途是求图中充某一个点开始的, 到其他点的最短路径. 基本思想是通过不断找到从已求点集 v 出发的一条最短且不成环的边, 并不断将边的终点加入到点集 v 中,并用一个数组记录其最短路径长度和边的出发点. 直到所有点都并入了点集 v 中, 则表示算法求解完成. 其中数组记录的是每个点的最短路径长度, 而边点出发点则记录了最短路径的上一步的点, 因此可以根据上一步的点推导出最短路径. 如果存在这样的一个点 v1: v1 已经被并入了点集 v, 而在算法之后的过程中, 存在一点 v2, 使得 源点-&gt;v2-&gt;v1 的路径比 源点-&gt;v1 的路径更短. 那么就必须保证 源点 -&gt;v2 的长度比 源点-&gt;v1 的长度更短, 而这样就会导致 v2 应该先于 v1 并入点集 v, 与假设矛盾. 因此通过反证法可以证明 Dijkstra 算法的正确性. 可以设计如下数据结构: class graph(object): def __init__(self): self.vexs = [] self.edge_num = 0 self.matix = [] 分解质因数为单链表def get_prime_factor(num: int) -&gt; ListNode: &quot;&quot;&quot; 将一个正整数分解其质因数由到小组成的链表. 例如对于 2100 可以分解成 7 5 5 3 2 2, 因此就返回链表: 7-&gt;5-&gt;5-&gt;3-&gt;2-&gt;2. Args: num (int): 输入的正整数. Returns: ListNode: 质因数由大到小组成的链表. &quot;&quot;&quot; head = ListNode() cur, idx = head, num // 2 while num &gt; 1 and idx &gt; 1: if num % idx == 0: for i in range(2, idx // 2 + 1): if idx % i == 0: break else: cur.next = ListNode(idx) cur = cur.next num //= idx idx += 1 idx -= 1 return head.next 验证二叉树是否严格def is_strict_binary(node: TreeNode) -&gt; bool: &quot;&quot;&quot; 判断一个二叉树是否严格二叉(指节点的出度只能为 0 或 2, 不存在出度为 1 的节点) 采用递归求解. 判断一个节点作为根节点的子树是否严格二叉的判定过程为: 1. 若出度为 2, 则需要保证左右子树都为严格的二叉树 2. 若出度为 1, 则不为严格二叉树. 3. 若出度为 0, 则为严格的二叉树. Args: node (TreeNode): 输入的二叉树根节点. Returns: bool: 该二叉树是否严格二叉. &quot;&quot;&quot; if node.left and node.right: return is_strict_binary(node.left) and is_strict_binary(node.right) elif node.left or node.right: return False return True 求顺序表第四分之一小的元素def get_quarter(arr: List[int], lo: int = 0, hi: int = 0) -&gt; int: &quot;&quot;&quot; 求顺序表中第 1/4 小的元素. 最优算法: 快速排序分组 + 二分 基本思路如下: 通过一趟快速排序将整个顺序表分为两部分, 然后根据分界点的位置判定下次 分组是在哪一组或者是否得到答案. 这样可以最小地比较顺序表中的元素, 就得到答案. Args: arr (List[int]): 顺序表 lo (int, optional): 左区间. Defaults to 0. hi (int, optional): 右区间. Defaults to 0. Returns: int: 第 1/4 小的元素. &quot;&quot;&quot; # 初始化变量 k = len(arr) // 4 if not hi: hi = len(arr) - 1 if lo &gt;= hi or len(arr) &lt; 4: return -1 key = arr[lo] left, right = lo, hi # 进行快速排序的一次遍历 while left &lt; right: while left &lt; right and key &lt; arr[right]: right -= 1 arr[left] = arr[right] while left &lt; right and key &gt; arr[left]: left += 1 arr[right] = arr[left] arr[left] = key # 二分 if left == k: return arr[left] elif left &lt; k: return get_quarter(arr, left + 1, hi) else: return get_quarter(arr, lo, left) 操作系统判断题 在任何操作系统中, 系统资源分配的最小单位是线程. 错误, 系统资源分配的最小单位是进程. 线程是 CPU 调度的最小单位. 处于死锁状态的进程必然拥有至少ー个互斥资源. 错误, 处于死锁状态的进程可能在等待其他进程释放互斥资源, 不一定拥有至少一个互斥资源. 虚拟存储器的最大容量是内存和外存的容量之和. 错误, 虚拟存储器的最大容量受到两个条件的限制, 一是内存和外存容量之和的物理限制, 二是计算机的地址位数能容纳的最大容量的限制. 决定文件访问效率的因素有 2 个, 分别是文件的物理结构和逻辑结构. 正确. 假脱机(Spooling)技术可以减少进程的上下文切换次数. 正确. Spooling 技术是在内存和设备之间添加缓存区. 减少了等待设备 IO 所引起的进程切换, 也就减少了进程上下文切换次数. 简答题 1分别从文件的逻辑结构、物理结构和文件目录三个不同角度入手, 举一个实例谈谈如何提高文件存取的效率. 文件的逻辑结构是从用户观点出发看到的文件组织形式.文件的物理结构是从实际观点出发 , 又称文件的存储结构, 是指文件在外存上的组织形式. 按逻辑结构, 文件有无结构文件和有结构文件两个类型. 有结构文件又包括顺序文件、索引文件、索引顺序文件和直接文件和散列文件.顺序文件对顺序文件的效率是所有逻辑文件中最高的; 索引文件建立了一张索引表以加快索引速度索引顺序文件是顺序和索引两种组织形式的结合; 索引顺序文件和直接文件和散列文件给定记录的键值或通过 Hash 函数转换的键值直接记录的物理地址, 从而提高了存取效率, 但可能会起冲突. 文件目录实现按名存取, 提高目录的检索速度, 将对系统性能的提高有极大的帮助. 简答题 2从资源共享、创建和结束三个方面分别谈谈进程和它创建的子进程、进程和它创建的线程之间的关系. 进程和它创建的子进程 一个进程创建另一个进程, 此时创建者为父进程, 被创建的进程称为子进程. 子进程可以进程父进程所拥有的资源. 当子进程被撤销时应将从父进程那里获得的资源归还给父进程. 此外在撤销父进程时也必须撤销其所有子进程. 进程和它创建的线程 进程是分配资源的基本单位, 而线程不拥有系统资源. 但线程可以访问其隶属的进程的系统资源. 一个线程被创建后便开始了它的生命周期, 直到终止. 线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态. 解答题一个分页存储系统(采用二级页表), 页表存放在内存: 如果访问一次内存需要 200ns, 则访问一个内存单元需要多少时间? 由于采用分页存储系统, 因此如果想要访问一个内存单元, 就需要先在第一级页表得到内存单元在第二级页表的位置, 然后再访问第二级页表找到内存单元的存储地址, 最后通过地址访问内存单元. 因此需要 (2+1)*200= 600ns 如果该系统采用三级页表, 则访问一个内存单元需要多少时间? 如果采用三级页表, 就需要多访问一个页表, 因此需要 (3+1)*200 = 800ns 如果该系统引入联想寄存器, 90% 的页表项可以在快表中命中, 则访问一个内存单元平均需要多少时间?(假设访问一次快表需要 10ns) 访问一个内存单元的平均时间为 0.9(10+200) + 0.1(600+10) = 250ns 如果该系统采用虚拟存储技术, 页面的命中率为 80%, 每次缺页处理平均需要花费 50000s, 则访问一个内存单元平均需要多少时间? 访问一个内存单元的平均时间为: 0.8(600)+0.2(400+200+50000+200) = 10640 如果该系统同样采用虚拟存储技术, 页面的命中率为 80%, 但缺页时有 10% 的页面需要进行页面置换(不需要页面置换的缺页处理需要花费 40000ns,需要页面置换的缺页处理需要花费 80000ns), 则访问一个内存单元平均需要多少时间? 访问一个内存单元平均需要的时间为 0.8(600)+0.2(400+200+0.180000+0.940000+200) = 9440ns PV 操作有四个进程 S1、R1、R2 和 R3, 其中 S1 向缓冲区 BUFF 发送消息, R1、R2 和 R3 分别从缓冲区中接收消息. 发送和接收的规则如下: 缓冲区 BUFF 大小为 1. 只有当缓冲区有消息时, R1、R2 和 R3 才能从缓冲区中取出消息. 每个消息 R1、R2 和 R3 必须各取 1 次. 只有当它们都取过后, 才能清空缓冲区. 每个消息 R1、R2 和 R3 只能取 1 次请用信号量机制来实现这 4 个进程间的同步. Semaphore SR1=SR2=SR3=1; Semaphore R1=R2=R3=0; Procedure S1(){ while(1){ // Generate message P(SR1); P(SR2); P(SR3); // Send messages to buffer V(R1); V(R2); V(R3); } } Procedure R1(){ while(1){ P(R1); // Receive messages from buffer V(SR1); } } Procedure R2(){ while(1){ P(R2); // Receive messages from buffer V(SR2); } } Procedure R3(){ while(1){ P(R3); // Receive messages from buffer V(SR3); } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"考研","slug":"考研","permalink":"/tags/考研/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"/tags/数据结构和算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"苏州大学2013年872试题","slug":"苏州大学2013年试题","date":"2021-07-27T02:27:15.000Z","updated":"2024-03-02T16:13:04.439Z","comments":true,"path":"2021/07/27/苏州大学2013年试题/","link":"","permalink":"/2021/07/27/苏州大学2013年试题/","excerpt":"","text":"数据结构问答题 如何将图表示为邻接矩阵? 给出其类型定义. 图是由点和边组成的, 而用邻接矩阵表示图, 就是用一个二维数组表示图中的点和边. 具体而言就是用二维数组的下标表示点, 然后二维数组中的值表示两点之间是否有边. 具体类型定义如下: class AdjacencyMatrix(object): def __init__(self) -&gt; None: self.matrix = [] # 邻接矩阵, 边表 self.points = [] # 顶点表 self.sides_num = 0 # 当前边点条数 迪杰斯特拉(Dijkstra)算法中, 集合 S 的作用是什么? 算法时间复杂度是多少? 集合 S 是已经求得的最短路径的顶点的集合. 用于记录哪些点为已经求得的点, 避免点重复求得相同的点. 也是用于结束算法的标志, 当所有点都位于集合 S 中时, 即表明 Dijkstra 算法求解完成. Dijkstra 算法的时间复杂度为 O(|V|^2) 其中 V 为图中边的数量. 解决哈希冲突已知一组关键字为 (10,24,32,17,31,30,46,43,40,63), 设哈希函数 H(key) = key%13. (1) 请画出用线性探测法处理冲突构造所得来的哈希表. key 10 24 32 17 31 30 46 43 40 60 H 10 11 6 4 5 4 7 4 1 11 因此通过线性探测法处理冲突构造来的哈希表为: addr 0 1 2 3 4 5 6 7 8 9 10 11 12 val 40 ## ## ## 17 31 32 30 46 43 10 24 60 (2) 简述查找关键字 43 的查找过程. 首先通过 43%13=4 找到哈希表中的地址为 4 的值 17. 不为 43, 继续找到地址为 5 的 值 31, 不为 43, 继续找到地址为 6 的值 32, 不会 43, 继续找到地址为 7 的值 30, 不会 43, 继续找到地址为 8 的值 46, 不会 43,最后找到地址为 9 的值 43. 最终找 到该关键字. 孩子兄弟法存储的树的结点个数class CSTree(object): &quot;&quot;&quot; 孩子兄弟存储法表示的树. &quot;&quot;&quot; def __init__( self, val: Any = None, child: Optional[&quot;CSTree&quot;] = None, next_sibling: Optional[&quot;CSTree&quot;] = None, ) -&gt; None: self.val = val self.child = child self.next_sibling = next_sibling def get_node_number(node: Optional[CSTree]) -&gt; int: &quot;&quot;&quot; 返回节点数量. 当前节点的子树的节点数量 = 1 + 所有孩子的节点子树的节点数量. Args: node (Optional[CSTree]): 孩子兄弟法表示的树结构. Returns: int: 节点总数. &quot;&quot;&quot; return ( 1 + get_node_number(node.next_sibling) + get_node_number(node.child) if node else 0 ) 递归删除单链表中值为 item 的结点def remove_item(node: Optional[ListNode], target) -&gt; Optional[ListNode]: &quot;&quot;&quot; 递归删除单链表中值为target的节点. 如果当前节点的值为target则丢弃当前节点, 返回处理完之后节点的单链表. 如果当前节点的值不会target, 则处理完之后的节点, 并修改当前节点的next指针, 最后返回当前节点. Args: node (Optional[ListNode]): 当前节点. target ([type]): 要删除的目标值. Returns: Optional[ListNode]: 删除所有值为target的节点的单链表. &quot;&quot;&quot; if node: if node.val == target: return remove_item(node.next, target) node.next = remove_item(node.next, target) return node 每位相加的新值的个数def get_number(n: int) -&gt; int: &quot;&quot;&quot; 输入一个数, 返回它通过一种运算可以得到所有正整数的个数. 这种运算的规则是, 对于这个数 n , 可以在其前加一个小于等于 n 一半的数 m , 来构成一个新的数 mn , 对于 mn , 可以递归取得一个小于等于 m 一半的数 p, 构成一个新的数 pmn. 依次递推. 解决方法: 使用动态规划的思想, 由底至上的递归方法. 因为我们可以看出, 该运算具有重复子结构, 因此可以依次 取得1-n的所有数的可以得到的个数. 由于使用了一个 pre 变量来保存需要的前序和, 因此实际上的时间复杂度为O(n), 由于需要大小为 n 的 数组来保存之前的数据, 因此空间复杂度为O(n). Args: n (int): 输入的数. Returns: int: 通过这种运算可以得到正整数的个数. &quot;&quot;&quot; dp = [0] * (n + 1) pre = 0 for i in range(1, n + 1): if i &amp; 1 == 0: pre += dp[i &gt;&gt; 1] dp[i] = 1 + pre return dp[n] 操作系统名词解释 磁盘寻道时间 磁盘寻道时间是指磁盘在读取信息前, 将磁头移动到指定磁道所需要的时间, 这个时间除了跨越 n 条磁道所需要的时间 n*m(m 为跨越一条磁道的时间), 还包括启动磁臂的时间 s. 程序动态装入 程序动态装入是指把装入模块装入内存后, 并不立即把装入模块中的相对地址转换为绝对地址, 而是把这种地址转换对迟到程序真正要执行才进行. 因此, 装入内存后的所有地址为相对地址. 用户态线程 有关线程管理的所有工作都由应用程序完成, 内核意识不到线程的存在. 内碎片 内部碎片是指一片内存空间已经被分配给了某进程, 但不会被利用. 从而造成空降浪费. 临界区 访问临界资源的那部分代码称为临界区. 判断题 存在 m 个进程的系统中, 死锁进程的个数 k 在 1&lt;k&lt;=m 区间内. 正确, 死锁是指两个或两个以上的进程在执行过程中, 由于竞争资源或者由于彼此通信而造成的一种阻塞的现象, 若无外力作用, 它们都将无法推进下去. 此时称系统处于死锁状态或系统产生了死锁, 这些永远在互相等待的进程称为死锁进程. 因此死锁进程的个数一定大于 1 且小于 m. 分页引入 TLB 能减少每一次内存的访问时间 错误, 不一定能减少每一次内存的访问时间. 只有当 TLB 中命中才会减少内存的访问时间, 否则会增加内存访问时间. 在引入虚存的系统中, 磁盘无限大, 进程就能拥有任意大的编址空间. 错误, 虚拟存储的容量有两个限制条件, 一个是在物理上无法大于内存容量+外存容量. 另一个则是要小于计算机的地址位数能容纳的最大容量. 因此并不是外村容量无限大, 就能够让进程拥有任意大的编址空间. 文件目录一般存放在外存中. 正确, 系统中文件很多时, 文件目录可能占用大量的空间, 因此文件目录通常存放在磁盘上. 进程从等待到就绪, 一定有就绪到运行. 错误, 进程从等待到就绪一般是由于除 CPU 外的资源得到分配, 等待 CPU 处理. 与是否有进程从就绪到运行无关. 分析题在一个请求式分页系统中, 目前系统的利用率如下 CPU 操作:3% 分页磁盘的 I/O 操作:97% 其它 I/O 设备:5% 下列方法是否可以提高 CPU 利用率,请分别说明理由。 通过题意分析得出, 分页磁盘的 I/O 操作非常高, 而 CPU 和其他 I/O 设备的利用率非常低, 因此可以判断得出,导致 CPU 利用率低的主要原因是由于进程频繁地切换. 导致正在执行的进程无法充分利用 CPU. 安装一个更加快速的 CPU 无法提高 CPU 利用率, 因为安装一个更快速的 CPU 无法改变进程频繁切换的现状. 无法增加 CPU 利用率. 撤销内存中的进程 可以提高 CPU 利用率. 内存中的进程减少, 因此就会多出内存来存放正在运行的内存, 因此就减少了进程的切换, 因此 CPU 就能得到更充分的利用. 增加内存容量 可以提高 CPU 利用率. 因为内存容量增大, 就可以有更多空间来存放进程数据, 因此就会减少进程的切换的开销, 从而使得 CPU 能够得到充分的利用. 换一个容量更加大的硬盘 无法提高 CPU 利用率. 内存容量大不出无法通过增加硬盘的容量来解决. 换一个更加快速的硬盘。 无法提高 CPU 利用率. 更加快速的硬盘也无法减少进程切换的开销. 分析题 2有一请求式分页系统, 其页表存放在主存中, 对主存的一次存取需要 1.5 微秒, 如果需要访问磁盘,每次磁盘访问时间是 100 微秒. 请回答以下问题: 假如缺页率为 0, 访问一次内存数据的存取时间是多少? 由于缺页率为零, 因此只需要访问一次内存. 存取时间为: 1.5 微秒 假如缺页率为 0, 系统引入联想寄存器, 平均命中率为 80%. 当页表项在联想寄存器中时, 其査找时间忽略为 0. 访问一次内存数据的平均存取时间为多少? 平均存取时间为: 0.2*(1.5) = 0.3 微秒 假如系统不采用联想寄存器, 缺页率为 20%, 其中一半需要进行页面置換. 访问一次内存数据的平均存取时间为多少? 由于不采用联想寄存器, 且缺页率为 20%, 因此访问一次内存的平均存取时间为: 0.2*(1.5+100+1.5) +0.8*(1.5) = 21.8 微秒 论述题在文件系统中, 目录的作用是什么? 有哪些不同的目录组织形式? 试举一个例子说明根据文件名在目录中査找该文件的创建日期的过程. 文件目录与文件管理和文件集合相关联, 它包含有文件的信息, 用于标识系统中的文件及其物理地址, 供检索时使用. 目录的结构有: 单级目录结构, 两级目录结构, 多级目录结构和无环目录结构. 将用户给定的文件名与目录中的文件名逐次比较, 锁定时, 在访问文件对应的控制块, 在控制块的使用信息中找到文件的创建日期.","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"考研","slug":"考研","permalink":"/tags/考研/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"/tags/数据结构和算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"苏州大学2012年872试题","slug":"苏州大学2012年试题","date":"2021-07-26T11:48:15.000Z","updated":"2024-03-02T16:13:04.996Z","comments":true,"path":"2021/07/26/苏州大学2012年试题/","link":"","permalink":"/2021/07/26/苏州大学2012年试题/","excerpt":"","text":"数据结构简述题 连通分量 无向图中的极大连通子图称为连通分量. 连通分量主要用于确定从图中的一个顶点能否到达图中的另一个顶点. 最小生成树 对于一个带权连通图 G=(V,E) 从中得到一个 G1=(V1,E1) 的子图. 并且这个子图为一棵树, 则称子图为生成树. 最小生成树则表示在 G 的所有生成树中, 权值最小的那一类生成树. 堆排序 将 arr[1…n] 看成一颗完全二叉树的顺序存储结构, 利用完全二叉树中双亲结点和子结点的关系, 每次在当前无序区中选择关键词最大的元素. 双端队列 双端队列是指两端都可以进行入队和出队操作的队列. 稀疏矩阵的压缩存储方法 为多个值相同的元素只分配一个存储空间, 对零元素不分配存储空间. 散列表假定一个待散列存储的线性表为(37,65,25,73,42,91,45,361875), 散列地址空间为 HT[12] 若采用除留余数法构造散列函数和链接法处理冲突, 试求出每一元素的散列地址, 画出最后得到的散列表, 求出平均查找长度. 由于采用除留余数法, 可得散列函数为: H(n) = n % 11. 散列地址和元素的关系如下: key 37 65 25 73 42 91 45 36 18 75 addr 4 10 3 7 9 3 1 3 7 9 因此散列表为: addr 0 1 2 3 4 5 6 7 8 9 10 elem 45 ## ## 25 37 ## ## 73 ## 42 65 link1 ## ## ## 91 ## ## ## 18 ## 75 ## link2 ## ## ## 36 ## ## ## ## ## ## ## 因此平均查找长度为: ASL = (1*6+2*3+3*1)/10 =1.5 单链表结点与前驱结点交换位置def change(node: Optional[ListNode], i: int) -&gt; Optional[ListNode]: &quot;&quot;&quot; 将单链表中编号为 i (从 0 开始)的节点和它的前驱节点交换位置. 因为为单链表, 所以需要在cur.next.next为目标节点时, 才能操作如何指向前驱节点. Args: node (Optional[ListNode]): 单链表. i (int): 目标节点编号. Returns: Optional[ListNode]: 交换后的链表. &quot;&quot;&quot; idx = 1 head = ListNode(val=0, next=node) cur = head while cur.next: if idx == i: target = cur.next.next cur.next.next, cur.next, target.next = target.next, target, cur.next break idx += 1 cur = cur.next return head.next 构造平衡二叉查找树def init_balance_search_tree(n: int) -&gt; TreeNode: &quot;&quot;&quot; 将自然数range(1,n+1)作为树的节点的值, 构造一棵平衡二叉查找树. 采用递归的方法, 由于自然数是递增有序的, 因此可以选择中间节点作为子树的父节点, 左边的 元素作为左子树, 右边的节点作为右子树. 递归下去就可以构建成一颗平衡的二叉查找树. Args: n (int): 自然数. Returns: TreeNode: 平衡的二叉查找树. &quot;&quot;&quot; def dfs(le: int, ri: int) -&gt; TreeNode: mid = (le + ri) // 2 return TreeNode( val=mid, left=dfs(le, mid - 1) if le != mid else None, right=dfs(mid + 1, ri) if ri != mid else None, ) return dfs(1, n) 操作系统名词解释 内碎片 内碎片是指已经分配给某进程, 但是无法被利用的内存空间. 微内核 将内核中最基本的功能保留在内核, 将那些不需要在核心态下执行的功能移到用户态下执行. 中级调度 即内存调度, 为了提高内存利用率和系统吞吐量, 将那些不能运行的进程调至外存上等待. 用户级线程 在用户态线程中, 有关线程管理的所有工作都由应用程序完成, 内核意识不知道线程的存在. 死锁 多个进程因竞争资源而造成的一种僵局, 若无外力作用, 这些进程都将无法向前推进. 分析请求式分页系统需要解决的核心问题, 并谈谈如何提高请求式分页系统的效率. 地址转换 由于分页系统需要频繁地访问内存, 因此地址转行速度越快, 访问内存的速度也就越快, 分页系统的效率也就越高. 缺页率 缺页率越高, 就会增大分页系统在访问内存的时间. 进而降低分页系统的效率. 内存分配 选择合理的内存分配方式, 可以为特定的进程分配适度的主存空间. 减少内存的访问次数, 因此提升分页系统的效率. 为提高请求式分页系统的效率, 可以为地址转换增设一个具有并行查找能力的高速缓冲的快表, 用来存放当前访问的若干页表项, 以加速地址转换的过程. 选择合适的页面置换算法, 降低缺页率. 根据每个进程在运行时的缺页情况, 为每个进程分配适当的物理块, 使进程所谓缺页率趋于适当程度. PV 操作规则如下: S1 发送消息, R1, R2, R3 接收消息. 消息的缓冲区大小为 1 每个消息需要被 R1, R2, R3 各接收一次. 只有在消息被 R1, R2, R3 都接收后, S1 才能发送下一个消息. Semaphore SR1=SR2=SR3=1; Semaphore R1=R2=R3=0; Procedure S1(){ while(1){ // Generate message P(SR1); P(SR2); P(SR3); // Send messages to buffer V(R1); V(R2); V(R3); } } Procedure R1(){ while(1){ P(R1); // Receive messages from buffer V(SR1); } } Procedure R2(){ while(1){ P(R2); // Receive messages from buffer V(SR2); } } Procedure R3(){ while(1){ P(R3); // Receive messages from buffer V(SR3); } } 磁盘 IO 操作一个文件有 10 个磁盘块, 假设文件控制块在内存 (如果文件采用索引分配, 索引表也在内存 ). 在下列情況下,请计算在连续分配, 链接分配, 单级索引分配三种分配方式下分别需要多少次磁盘 I/O 操作?(每读入或写出一个磁盘块需要一次磁盘 I/O 操作,另外,假设在连续分配方式下, 文件头部无空闲的磁盘块, 但文件尾部有空闲的磁盘块.) 在文件开始处删除一个磁盘块 连续分配 连续分配可以直接通过指针加法获得下一个磁盘块的地址, 因此可以不需进行 IO 操作. 因此 IO 操作次数为 0. 链接分配 需要分为两种情况: 隐式链接和显式链接 隐式链接: 由于下一块磁盘块的地址存储在第一块磁盘块的物理块中, 需要访问 1 次磁盘快来获得第二块磁盘块的地址. 因此 IO 操作次数为 1. 显式链接: 因为链接表存储已经在文件系统装载时装入内存. 则仅需要修改链接表即可. 因此 IO 操作次数为 0. 单级索引分配 由于索引表已经在内存中, 只需删除其第一个物理块的地址 . 因此 IO 操作次数为 0. 在文件结尾处添加一个磁盘块 连续分配 由于知道文件的第一个磁盘的地址, 并知道文件的物理块的个数, 只需要在末尾添加一个磁盘块. 因此 IO 操作的次数为 1. 链接分配 需要分为两种情况: 隐式链接和显式链接 隐式链接: 根据文件结束块读取最后一块物理块的内容, 获得新的物理块, 最后将读取的最后一个物理块的指针指向新的物理块. 因此 IO 操作的次数为 3. 显式链接: 由于链接表已经放入内存, 只需要获得新的物理块, 并将其地址加入链接表. 因此 IO 操作的次数为 1. 单级索引分配 由于索引表已经存在于内存, 只需在获得新的物理块, 并将其地址加入索引表. 因此 IO 操作的次数为 1. 在文件结尾处删除一个磁盘块 连续分配 直接修改文件长度即可, 不需要进行 IO 操作. 因此 IO 操作次数为 0. 链接分配 需要分为两种情况: 隐式链接和显式链接 隐式链接: 需要从第一个物理块一直读取到倒数第二个物理块, 然后将倒数第二个物理块的指针内容修改为-1,需要读取 9 个指针, 并修改倒数第二个物理块的指针. 因此 IO 操作的次数为 10. 显式链接: 由于链接表已经存在于内存, 只需要删除最后一个地址块的地址. 不需要进行 IO 操作. 因此 IO 操作的次数为 0. 单级索引分配 由于索引表已经存在于内存中. 只需要读取索引快, 并删除最后一个条目. 因此 IO 操作的次数为 0. 开放题随着多核时代的米临,操作系统也需要适应 CPU 的这个变化。请从目前的操作系统的功能入手, 谈谈如何使得现代操作系统适合多核计算环境。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"考研","slug":"考研","permalink":"/tags/考研/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"/tags/数据结构和算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"苏州大学2011年872试题","slug":"苏州大学2011年试题","date":"2021-07-25T02:48:15.000Z","updated":"2024-03-02T16:13:04.046Z","comments":true,"path":"2021/07/25/苏州大学2011年试题/","link":"","permalink":"/2021/07/25/苏州大学2011年试题/","excerpt":"","text":"数据结构简答题 什么是队列, 什么是循环队列? 只允许在线性表点一端进行插入, 另一端进行删除操作的线性表, 被称为队列. 循环队列是指将顺序队列假想为一个环状的空间, 即把存储队列元素的表从逻辑上看成一个环. 什么是最小生成树, 如何构造最小生成树? 对于一个带权连通图 G=(V,E) 从中得到一个 G1=(V1,E1) 的子图. 并且这个子图为一棵树, 则称子图为生成树. 最小生成树则表示在 G 的所有生成树中, 权值最小的那一类生成树. 最小生成树有两种构造方法, 分别是 Prim 算法和 Kruskal 算法. Prim 算法是从某一点开始, 不断找到与当前子图相连且不构成环的权值最小的边, 并将其加入到子图中, 直到所有点均加入到子图中, 即可构成最小生成树. Kruskal 算法则是不断寻找 G 中权值最小且不构成环的边, 直到所有点均在子图中, 即可构成最小生成树. 选择排序算法 以随机顺序排列的 n 个记录的链表, 其中 n&gt;1000. 应该采用归并排序. 因为要达到最好的时间复杂度 O(n*log(n))的排序算法, 比较方便且适用于链表的为归并排序算法, 并且归并排序说是非递归实现, 也能使空间复杂度为 O(1). 以随机顺序排列的 n 个记录的数组, 其中 n&gt;1000. 应该采用归并排序. 采用快速排序, 因为当排序元素较多, 且随机排列时, 快速排序的时间复杂度较低. 为 O(n*log(n)). n 个记录的数组, 其中所有记录都距离正确位置至多两个位置. 应该采用冒泡排序, 因为距离至多为 2, 冒泡排序的时间复杂度为 O(2*n) 二叉树的层次遍历def level_order(node: Optional[TreeNode]) -&gt; Generator: &quot;&quot;&quot; 二叉树的层序遍历. Args: node (Optional[TreeNode]): 二叉树. Yields: Generator: 返回一个层序遍历二叉树的生成器. &quot;&quot;&quot; if node is None: return None level = [node] while level: new_level = [] for item in level: yield item if item.left: new_level.append(item.left) if item.right: new_level.append(item.right) level = new_level 按照奇偶拆分单链表def split_linked_list(node: Optional[ListNode]) -&gt; tuple[ListNode, ListNode]: &quot;&quot;&quot; 将单链表拆分为全为奇数和全为偶数的两个单链表. Args: node (Optional[ListNode]): 单链表. Returns: tuple[ListNode, ListNode]: 全为奇数的单链表和全为偶数的单链表 &quot;&quot;&quot; even_list, head = ListNode(), ListNode(val=0, next=node) cur = head while cur and cur.next: if cur.next.val % 2 == 0: tmp, cur.next = cur.next, cur.next.next even_list.next, tmp.next = tmp, even_list.next cur = cur.next return head.next, even_list.next 有序矩阵搜索def matrix_search(arr: List[List[int]], target: int) -&gt; bool: &quot;&quot;&quot; 有序二维数组中查找目标值. 由于是在行递增, 列递减的二维数组中, 因此我们可以将初始点位于第一行的最后一列中, 然后判断其是否与目标值相等: - 如果相等则退出 - 如果大于, 则减少列数 - 如果小于, 则增加行数 因此可以遍历到二维数组中所有的数. Args: arr (List[List[int]]): 有序二维数组. target (int): 目标值. Returns: bool: 是否存在. &quot;&quot;&quot; row, col = len(arr), len(arr[0]) i, j = 0, col - 1 while i &lt; row and col &gt;= 0: idx = arr[i][j] if idx == target: return True elif idx &gt; target: j -= 1 else: i += 1 return False 操作系统判断题 一个运行时需要 300MB 存储空间的程序, 是不可能在一台只有 256MB 的内存的计算机上运行起来的. 错误, 因为可以使用虚拟存储技术, 使得该进程不会在运行时一次性地将全部数据读取进内存, 而是将部分未使用的内存存放在外存中, 待使用到时再读取进内存. 死锁将导致计算资源的使用效率不高, 所以在设计操作系统时, 不应该让死锁发生. 正确, 死锁是指两个或两个以上的进程在执行过程中, 因争夺资源而造成的一种互相等待的现象, 若无外力作用, 它们都将无法推进下去. 在计算机系统中资源是有限的, 而处于死锁的进程往往占有大量的资源且不能被剥夺, 造成系统资源利用率降低. 甚至有些死锁的出现会使系统无法正常运行, 给系统造成极大危害 因此在设计操作系统时, 不应该让死锁发生. 简答题 举例说明进程和线程的联系与区别. 调度: 进程是操作系统分配资源的基本单位, 而线程是独立调度的基本单位. 在同一进程中, 线程的切换不会导致进程的切换, 而在不同进程中, 线程的切换会引起进程的切换. 资源: 由于进程时分配资源的基本单位. 进程拥有资源, 而线程基本不拥有资源. 但是线程可以访问其隶属进程的系统资源. 并发: 进程之间可以并发执行, 同一进程中的线程也可以并发执行. 系统开销: 由于进程相较于线程更加庞大. 因此创建一个进程消耗的系统资源远大于创建一个线程消耗的资源,特别地, 当在一个进程中创建多个线程时, 由于线程可以共同拥有其隶属进程的资源, 因此消耗的资源不大.在切换方面, 切换同一进程中线程所消耗的时间远比切换进程消耗的时间短, 但若是切换到不同进程的线程,由于也会引发进程的切换, 因此也会消耗一定到时间. 通信: 进程之间通信需要进行同步和互斥手段进行辅助, 以保障数据的一致性. 而线程间可以直接读写进程数据段来进行通信. 说明操作系统对于应用程序开发来说的必要性和重要性. 必要性: 从系统的观点来看, 操作系统时计算机系统中的一个系统软件, 它管理和控制计算机系统的四大类资源: 处理器, 存储器, 外设和信息, 任何的应用软件和开发都需要借助于操作系统来对计算机的资源进行调用. 重要性: 操作系统的主要功能为处理器管理, 存储器管理, 设备管理, 文件管理, 用户接口. 从层次的角度来说, 操作系统是与计算机硬件之间联系的一层, 本身已经实现了复杂的对硬件资源进行操作的功能, 而且还提供了方便的接口, 可以让应用软件的开发更加注重于软件本身的功能, 使软件的开发更加便捷. 另外操作系统具有四大特性: 并发行, 共享性, 虚拟性和异步性. 这些特性可以让开发的软件具有更加强大的功能, 软件质量更高. 设计一个进程同步解决的问题, 并采用同步源语 wait/signal 来解决问题.读者写者问题: 一个数据库可以为多个并发进程所共享. 可以供多位读者同时读取. 但若是被一个写者读取时, 其他人不能读/写该文件. semaphore r, w; // r为读者信号量, w为写者信号量. 初始值均为1. int read_count; // 记录有多少个读者正在读 Procedure reader() { while (1) { wait(r); if (read_count == 0) { wait(w); } read_count++; signal(r); // read something wait(r); read_count--; if (read_count == 0) { signal(w); } signal(r); } return; } Procedure writer() { while (1) { wait(w); // update/read something... signal(w); } return; } 简述处理死锁一般有哪些策略 预防死锁 设置某些限制条件, 破坏产生死锁的四个必要条件中的一个或几个, 以防止发生死锁. 优点:适用于做突发式处理的进程, 不必进行剥夺. 缺点: 效率低,进程初始化时间延长。 避免死锁 在资源的动态分配过程中, 用某种方法防止系统进入不安全状态从而避免死锁. 优点:不必进行剥夺/ 缺点:必须知道将来的资源需求,进程不能被长时间阻塞. 死锁的检测和解除 无需采取任何限制性措施, 允许进程在执行过程中发生死锁. 通过系统的检测机构及时检测出死锁的发生, 然后采取某种措施解除死锁. 优点:不延长进程初始化时间, 允许对死锁进行现场处理. 缺点:通过剥夺解除死锁造成损失.","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"考研","slug":"考研","permalink":"/tags/考研/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"/tags/数据结构和算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"苏州大学2010年872试题","slug":"苏州大学2010年试题","date":"2021-07-23T04:14:15.000Z","updated":"2024-03-02T16:13:04.774Z","comments":true,"path":"2021/07/23/苏州大学2010年试题/","link":"","permalink":"/2021/07/23/苏州大学2010年试题/","excerpt":"","text":"数据结构简答题 栈和队列有什么共同点和不同点? 共同点: 都是一种特殊的线性表, 都仅允许顺序表的头/尾进行加入元素/删除元素的操作. 不同点: 栈是一种 FILO 的数据结构, 只允许在栈顶进行加入或者删除操作, 因此最先加入的元素, 最后才会被推出. 队列是一种 FIFO 的数据结构, 只允许在队尾/队头加入元素, 队头/队尾删除元素, 因此最先加入的元素, 最先被推出. 什么是矩阵的压缩存储, 试举例说明. 矩阵的压缩存储指为多个值相同的元素只分配一个存储空间, 队零元素不分配存储空间. 目的是节省存储空间. 例子: 对于一个 1000*1000 稀疏矩阵, 仅有 10 个非零数据. 若是用二维数组存储, 则会浪费大量的空间.但如果采用三元组顺序表方式存储, 则仅仅需要 10 组三元组就能存储存储数据. 判断, 并说明理由.题目: 对任意一个图, 从它的某个顶点出发进行一次深度优先或广度优先搜索遍历可访问到该图的每个顶点. 错. 如果是无向图的连通图或者有向队强连通图, 则能够访问到该图队每个顶点. 对于非连通的无向图, 不可能一次遍历访问到所有顶点. 对于有向非强连通图则有可能一次遍历到所有顶点. 单链表剔除值为 x 的结点def remove_x(node: Optional[ListNode], target: int): &quot;&quot;&quot; 删除所有节点值为target的节点, 需要注意应该判断cur.next的值. Args: node (Optional[ListNode]): 单链表 target (int): 目标值 Returns: [type]: 删除后的单链表 &quot;&quot;&quot; head = ListNode(val=-1, _next=node) cur = head while cur.next: if cur.next.val == target: cur.next = cur.next.next else: cur = cur.next return head.next 表达式树求值def calculate(t: Optional[TreeNode]) -&gt; int: &quot;&quot;&quot; 求解计算树的值. Args: t (Optional[TreeNode]): 计算树, 叶子节点为数值, 节点为运算符. Returns: int: 求解的值. &quot;&quot;&quot; if not t: return -1 if not t.left and not t.right: return t.val return eval(f&quot;{calculate(t.left)}{t.val}{calculate(t.right)}&quot;) 按照奇偶重新组合def com_even_odd(arr: List[int]) -&gt; List[int]: &quot;&quot;&quot; 让所有的偶数位于数组的偶数下标上, 或者所有奇数位于数组的奇数下标上. 由于一个整数必定是偶数或是奇数, 因此只需要让偶数/奇数其中一个排列正确, 则能保证满足题意. 因此我选择修改偶数下标, 用两个指针分别指向了偶数下标和奇数下标, 并不断找到不符合题意的元 素, 然后交换. 直到两个指针的其中一者超过属猪边界. Args: arr (List[int]): 数组 Returns: List[int]: 重新排列后的数组 &quot;&quot;&quot; even, idx = 0, 1 while even &lt; len(arr) and idx &lt; len(arr): while even &lt; len(arr) and not arr[even] % 2: even += 2 while idx &lt; len(arr) and arr[idx] % 2: idx += 2 if idx &lt; len(arr) and even &lt; len(arr): arr[idx], arr[even] = arr[even], arr[idx] return arr 操作系统名次解释 进程 进程实体的运行过程, 是系统进行资源分配和调度的基本单位. 虚拟地址 通过某种虚拟技术模拟出来的地址空间的技术. 多道程序设计 在计算机内存中同时存放几道相互独立的程序, 使它们在管理程序的控制下, 相互穿插的运行. 两个或两个以上程序在计算机系统中同处于开始到结束之间的状态. 分时操作系统 多个用户通过终端同时共享一台主机, 这些终端连接在主机上, 用户可以同时与主机进行交互操作而互不干扰. 动态重定位 在程序运行过程中要访问数据时再进行逻辑地址与物理地址的变换(即在逐条指令执行时完成地址映射. 一般为了提高效率, 此工作由硬件地址映射机制完成. 硬件支持, 软硬件结合完成) 硬件上需要一对寄存器的支持. 叙述文件目录项, 文件目录, 目录文件之间的差别和关系.文件目录项是为了使文件控制块与文件一一对应, 而其中的每一个文件控制块被称为文件目录项. 而把所有的文件目录项组织在一起, 就构成了文件目录, 即文件控制块的有序集合. 为了实现对文件目录的管理, 通常将文件目录以及文件的形式保存在外存, 这个文件就叫做目录文件. 三者之间的关系是包含与被包含的关系, 但也存在区别, 目录文件存储有文件目录项, 文件目录也包含文件目录项的相关信息, 但是目录文件并不包含全部的文件目录. 虚拟内存的目的和作用目的: 在计算机系统中, 由于许多在程序运行中不用或暂时不用的程序和数据占据了大量的内存空间, 而一些需要运行的作业无法装入内存运行. 显然, 内存是十分宝贵的. 为了解决这个问题, 就需要虚拟内存技术. 即拿出一部分的硬盘空间来充当内存使用, 当内存占用紧张时, 系统就会自动调用硬盘来充当内存, 以缓解内存的紧张. 而在需要使用到相应的数据时, 才会将硬盘的数据重新读取进内存. 比较两种进程调度算法 先来先服务算法 优先执行最先进入就绪状态的进程, 在当前进程结束后才让出 CPU. 利于长作业的工作, 但是不利于短作业的工作. 有利于 CPU 繁忙的作业, 而不利于 IO 繁忙的作业. 优先级算法 每个进程会有一个相应的优先级, 根据高优先级优先的原则, 优先级越高就会越先得到 CPU 资源. 有利于重要的进程优先执行. 但是会造成低优先级的进程持续得不到处理的情况. 银行家算法银行家算法是著名的死锁避免算法. 其思想是:把操作系统看做是银行家, 操作系统管理的资源相当于银行家管理的资金, 进程向操作系统请求分配资源相当于用户向银行贷款. 操作系统按照银行家指定的规则为进程分配资源, 当进程首次申请资源时, 要测试该进程对资源的最大需求量, 如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源, 否则推迟分配. 当进程在执行中继续申请资源时, 先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量. 若超过则拒绝分配资源, 若没有超过则再测试系统现存的资源能否满足该进行尚需的最大资源量, 若能满足则按当前的申请量分配资源, 否则也要推迟分配。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"考研","slug":"考研","permalink":"/tags/考研/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"/tags/数据结构和算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"苏州大学2009年872试题","slug":"苏州大学2009年试题","date":"2021-07-08T04:14:15.000Z","updated":"2024-03-02T16:13:04.992Z","comments":true,"path":"2021/07/08/苏州大学2009年试题/","link":"","permalink":"/2021/07/08/苏州大学2009年试题/","excerpt":"","text":"数据结构名词解释 循环队列 将队列想象成一个环状的空间, 即把存储队列元素的表从逻辑上看成一个环. 快速排序 基于分治的方法, 在待排序列中任取一个元素作为基准, 通过一趟排序将待排序序列分成独立的两个部分, 而后分别递归的对两个子表重复上述过程, 直至每部分内只有一个元素或空为止, 即所有元素都放在其最终位置上. 满二叉树** ** 一棵高度为 h,并且含有 2^(h-1) 个结点的二叉树称为满二叉树. 三元组顺序表 稀疏矩阵的一种存储方法, 用一个数组存储一个稀疏矩阵. 稀疏矩阵中非零元素的行、列和值作为一个元素存储在数组中, 并且数组按照行从小到大、行相同列从小到大排序. 串的模式匹配 子串的定位操作。从主串的第 pos 个字符起和模式的第 1 个字符比较, 若相等, 则继续逐个比较后续字符;否则从主串的下一个字符起再重新和模式的字比较. 以此类推, 直到模式中的每个字符依次和主串中的字符序列相等, 则匹配成功, 否则不成功. 哈希表解决冲突设哈希表函数为 H(k)=k mod 9, 关键字序列为: 23, 45, 14, 17, 9, 29, 37, 18, 25, 41, 33. 采用链地址法解决冲突. (1) 画出哈希表. 根据散列函数计算各关键字对应的 Hash 地址: 0 1 2 3 4 5 6 7 8 45 37 29 23 33 25 17 9 14 18 41 (2) 求出查找各个关键字的比较次数. 45, 37, 29, 23, 33, 25, 17 的比较次数为 1 9, 14 的比较此时为 2 18, 41 的比较此时为 3 (3) 计算在等概率情况下, 查找成功的平均查找长度. 查找成功: 指关键字在 Hash 表中, 最终能够查找出. 因此等概率指所有存在于 Hash 表中的关键字等概率. 查找失败: 指关键字不在 Hash 表中, 最终没有关键字比配. 因此等概率指对于每个 Hash 地址等概率. 查找成功的平均长度为 (1*7 + 2*2 + 3*2) / 11 = 17/11 [ 查找失败的平均查找长度: (0*2 + 1*5 + 3*2) / 9 = 11/9 ] 循环单链表交换前驱后继def change_pre_post(node: ListNode): &quot;&quot;&quot; 已知node是循环单链表中的一个节点, 要求交换它的前驱和后继. 先用一个指针循环单链表一遍, 直到指针指向前驱节点. 然后交换节点的前驱和后继. Args: node (ListNode): 需要更改前驱和后继的节点. &quot;&quot;&quot; cur = node while cur and cur.next != node: cur = cur.next if cur and node.next: node.next, cur.next = cur, node.next.next 有向图邻接表的出度class ArcNode(object): &quot;&quot;&quot; 顺序表的边节点类, 是一个链表结构的用于保存指向节点和权重的链表. 实现了通过list初始化的功能. &quot;&quot;&quot; def __init__( self, target: int = 0, weight: int = 0, next: Optional[&quot;ArcNode&quot;] = None ) -&gt; None: self.target = target self.weight = weight self.next = next @classmethod def init_by_list(cls, arr: List[Any]) -&gt; Optional[&quot;ArcNode&quot;]: head = ArcNode() cur = head for x in arr: node = ArcNode(target=x[0], weight=x[1], next=None) cur.next, cur = node, node return head.next class VNode(object): &quot;&quot;&quot; 顺序表的节点类, 记录了当前节点的数据、出度、入度和边度单链表. &quot;&quot;&quot; def __init__( self, data: int = 0, in_degree: int = 0, out_degree: int = 0, first_arc: Optional[ArcNode] = ArcNode(), ) -&gt; None: self.data = data self.in_degree = in_degree self.out_degree = out_degree self.first_arc = first_arc class ArcGraph(object): &quot;&quot;&quot; 顺序表类, 记录了边的数量和节点的数量, 以及一个节点的列表, 用于描述图的结构. &quot;&quot;&quot; def __init__( self, graph: List[VNode] = [], vex: int = 0, arc: int = 0 ) -&gt; None: self.graph = graph self.vex_num = vex self.arc_num = arc def get_in_and_out(g: ArcGraph): &quot;&quot;&quot; 根据顺序表的结构, 初始化每个节点的出度和入读. Args: g (ArcGraph): 顺序表. &quot;&quot;&quot; for l in g.graph: p = l.first_arc while p: l.out_degree += 1 g.graph[p.target - 1].in_degree += 1 p = p.next 二叉树的繁茂度def get_depth(t: Optional[TreeNode]) -&gt; int: &quot;&quot;&quot; 由顶到下的递归操作, 每次取左子树和右子树中高度较大的一颗子树, 就能得到树的深度. Args: t (Optional[TreeNode]): 树 Returns: int: 树的深度. &quot;&quot;&quot; if not t: return 0 if t.left or t.right: return max( 0 if not t.left else 1 + get_depth(t.left), 0 if not t.right else 1 + get_depth(t.right), ) else: return 1 def get_width(t: Optional[TreeNode]) -&gt; int: &quot;&quot;&quot; 遍历每一层, res取所有层宽度的最大值, 就能找到树的宽度. Args: t (Optional[TreeNode]): 树 Returns: int: 树的宽度. &quot;&quot;&quot; if not t: return 0 lst = [t] res = 0 while lst: new_lst = [] res = max(res, len(lst)) for node in lst: if node.left: new_lst.append(node.left) if node.right: new_lst.append(node.right) lst = new_lst return res def get_luxuriant(t: Optional[TreeNode]) -&gt; int: return get_depth(t) * get_width(t)","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"考研","slug":"考研","permalink":"/tags/考研/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"/tags/数据结构和算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"写一篇文章来吐槽Go语言的机制","slug":"写一篇文章来吐槽Go语言的机制","date":"2021-07-07T14:09:15.000Z","updated":"2024-03-02T16:13:05.026Z","comments":true,"path":"2021/07/07/写一篇文章来吐槽Go语言的机制/","link":"","permalink":"/2021/07/07/写一篇文章来吐槽Go语言的机制/","excerpt":"","text":"吐槽 Go 语言的机制起因今天突发奇想想用 Go 来写一写 LeetCode 困难题。因为平时感觉 Go 还是挺靠谱的（而且速度比 Python 快多了），比起 Python 的方便快捷，Go 更给我一种我能完全掌握我在干嘛的感觉（现在看来这就是幻觉）。 所以打开了今天的拦路虎 题目介绍首先看到这个题，我发现结点的顺序有如下限制： 父结点总是在子结点之前 没了 是的，没错，只有一个限制。那么问题就很简单了，就是从头结点开始遍历，每次将当前结点的子结点放入 map 中，从 map 中找到下一个结点，继续这个过程就可以找到所有的路径了。 因此我发现可以使用回溯法，因此我使用递归实现。 在编写中有几点需要注意的： 子结点加入后，在函数完成时需要将其剔除，不然会影响到之后的递归。 遍历到当前结点时，需要剔除该结点，在处理完后需要将其加入 题目解答想到这里，我随手写了一个低效率版本，并且十分合理地以低效率的时间和空间通过了该题。 // 执行用时：28 ms, 在所有 Go 提交中击败了6.98%的用户 // 内存消耗：14.1 MB, 在所有 Go 提交中击败了6.98%的用户 func BSTSequences(root *TreeNode) [][]int { if root == nil { return append([][]int{}, []int{}) } var ( res [][]int path []int dfs func(idx *TreeNode, que map[*TreeNode]bool, path []int) sliceCope func([]int) []int mapCope func(map[*TreeNode]bool) map[*TreeNode]bool ) sliceCope = func(i []int) (res []int) { for _, x := range i { res = append(res, x) } return } mapCope = func(m map[*TreeNode]bool) map[*TreeNode]bool { res := map[*TreeNode]bool{} for k, v := range m { res[k] = v } return res } que := map[*TreeNode]bool{root: true} dfs = func(idx *TreeNode, que map[*TreeNode]bool, path []int) { delete(que, idx) path = append(path, idx.Val) if idx.Left != nil { que[idx.Left] = true } if idx.Right != nil { que[idx.Right] = true } if len(que) == 0 { res = append(res, path) } else { for key := range que { newQue := mapCope(que) newPath := sliceCope(path) dfs(key, newQue, newPath) } } return } dfs(root, que, path) return res } 这我肯定不能满意，我发现了我在复制 map 和 slice 上花费了很多不应该的时间。因此我下定决心研究代码，结果问题就来了。 Go 语言在遍历 map 的时候不是将其 keys 保存成一个数组，从而遍历它的。而是每次从 map 中去除一个 key。这就导致了如果在遍历过程中修改了 map，则会发生很多难以预料的事情。因此需要使用一个 slice 保存其 key 值，再遍历数组就可以保证能够顺利遍历了。 然后在复制 Slice 的时候，已经习惯 Python 的原本想使用 slice[:]从而获得一个副本。结果突然想起来 Go 的切片不同于 Python，Python 是生成一个新的列表，而 Go 这则是修改该 slice 的指针。在高效的同时也导致其…根本没有发生改变。 最后使用 copy 也有一些坑点，在复制 slice 的时候，如果被覆盖的那个 slice 空间不够大，则无法成功复制，也就是说得先分配一定的大小的空间，才能使用 copy 函数。 以下是修改后的代码（但是不得不说，Go 是真的香）， // 执行用时：12 ms, 在所有 Go 提交中击败了90.70%的用户 // 内存消耗：6.9 MB, 在所有 Go 提交中击败了95.35%的用户 func BSTSequences(root *TreeNode) [][]int { if root == nil { return append([][]int{}, []int{}) } var ( res [][]int path []int dfs func(idx *TreeNode) ) que := map[*TreeNode]bool{root: true} dfs = func(idx *TreeNode) { delete(que, idx) path = append(path, idx.Val) if idx.Left != nil { que[idx.Left] = true defer delete(que, idx.Left) } if idx.Right != nil { que[idx.Right] = true defer delete(que, idx.Right) } if len(que) == 0 { newSlice := make([]int, len(path)) copy(newSlice, path) res = append(res, newSlice) } else { st := make([]*TreeNode, 0, len(que)) for key := range que { st = append(st, key) } for i := range st { dfs(st[i]) } } que[idx] = true path = path[:len(path)-1] return } dfs(root) return res }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"golang","slug":"golang","permalink":"/tags/golang/"},{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"苏州大学2008年872试题","slug":"苏州大学2008年试题","date":"2021-07-06T02:54:15.000Z","updated":"2024-03-02T16:13:04.046Z","comments":true,"path":"2021/07/06/苏州大学2008年试题/","link":"","permalink":"/2021/07/06/苏州大学2008年试题/","excerpt":"","text":"数据结构名词解释 线索二叉树: 对于一个二叉树, 可以根据某种遍历顺序(一般为中序遍历)将二叉树的所有节点形成一个列表. 因此每个节点就会有对应的前驱和后继. 线索二叉树是将二叉树中原本为空的左指针指向前驱节点, 将原本为空的右指针指向后继节点的二叉树. 堆: 堆是一种特别的完全二叉树. 若是其所有父节点总是大于对应的子节点, 则为最大堆; 若是起所有父节点总是小于对应的子节点, 则为最小堆. 邻接矩阵: 用一个二维数组表示图的结构. 对于二维数组中的某点 M[i][j] 的值表示点 i 到点 j 是否有边, 以及边的权值为多少. 稳定排序: 如果待排序表中存在两个元素 R1, R2. 其对应的关键词为 key1=key2, 且在排序前 R1 在 R2 之前, 如果使用某一算法排序后, R1 一定也在 R2 前面, 则称这个排序算法是稳定排序算法. 析构函数: 当对象的生命周期结束时, 自动调用运行函数. 它的目的是清空并释放对象先前占用的存储器资源. 已知不完整的前序遍历和中序遍历, 请填完前序遍历和中序遍历, 并画出二叉树结构.已知: 前序遍历: AB_E_ICFJ_G 中序遍历: D_HEIA_FKC_ 解法: 根据前序遍历和中序遍历的特点: 前序遍历的第一个节点一定是根节点, 因此可以将中序遍历分为两个部分, 分别是左子树和右子树. 然后在前序遍历中找到相应的节点, 然后再找到对应的根节点, 依次递归进行. 直到子树中只有一个节点. 结果: 前序遍历: ABDEHICFJKG 中序遍历: DBHEIAJFKCG 结构: 括号匹配def bracket_matching(string: str) -&gt; List[Tuple[int, int]]: &quot;&quot;&quot; 括号匹配, 给一个包含多种括号的字符串, 返回各个括号及其反括号的下标. 使用栈匹配括号. 具体算法如下: - 如果当前字符是括号, 则压入栈. - 如果是反括号, 则判断其和栈顶的括号是否匹配. 如果匹配则记录两者的下标, 并推出栈顶的括号 如果不匹配, 说明字符串是非法的括号字符串. Args: string (str): 一个包含多种括号的字符串. Returns: List[Tuple[int, int]]: 返回匹配括号的下标数组· &quot;&quot;&quot; res, stack = [], [] start = {&quot;(&quot;: 1, &quot;[&quot;: 2, &quot;{&quot;: 3} end = {&quot;)&quot;: 1, &quot;]&quot;: 2, &quot;}&quot;: 3} for i, ch in enumerate(string): if ch in start: stack.append((ch, i)) if ch in end: if end[ch] != start[stack[-1][0]]: return None else: res.append((stack[-1][1], i)) stack.pop() return res if not stack else None Dijkstra（以后考试不做要求）def dijkstra(target_map: Map, node: int): point_dict = {node: 0} # 表示起始点到目标点的最小路径长度 pre_node = {node: node} # 记录路径中的前驱 v = {node} # 记录节点是否已经有了最短路径 for line_node, line_cost in target_map.get_lines(node): # 先将起始点能直接遍历到的点记入dict中 point_dict[line_node] = line_cost pre_node[line_node] = node for _ in range(target_map.size - 1): cost, min_node = float(&#39;inf&#39;), None # 寻找当前最小路径的点 for index_node in point_dict: if index_node not in v and cost &gt; point_dict[index_node]: cost = point_dict[index_node] min_node = index_node v.add(min_node) for line_node, line_cost in target_map.get_lines(min_node): # 更新dict if line_node not in point_dict or point_dict[line_node] &gt; line_cost + cost: point_dict[line_node] = line_cost + cost pre_node[line_node] = min_node return format_res(point_dict, pre_node) def format_res(cost, pre): res_dict = {} for node in cost: res_dict[node] = {&#39;cost&#39;: cost[node]} path = [str(node)] idx = node while pre[idx] != idx: idx = pre[idx] path.append(str(idx)) res_dict[node][&#39;path&#39;] = &#39;-&gt;&#39;.join(path[::-1]) return res_dict 编写 shell 排序算法def shell_sort(arr: List[int]) -&gt; List[int]: &quot;&quot;&quot; 希尔排序. Args: arr (List[int]): 待排序数组. Returns: List[int]: 排序完成后的数组. &quot;&quot;&quot; length = len(arr) for sub in range(length // 2, 0, -1): for idx in range(0, length, sub): min_idx = idx for i in range(idx, length, sub): if arr[i] &lt; arr[min_idx]: min_idx = i arr[idx], arr[min_idx] = arr[min_idx], arr[idx] return arr 操作系统判断对错, 并分析原因 磁盘访问的最小单位是扇区, OS 以扇区为单位存储和读取数据. 错误, 最小单位是字节; 磁盘储存的最小单位是扇区, 不是 OS. 处于用户态的进程可以访问一切内存和执行一切指令. 错误, 机器处于用户态时, 程序只能执行非特权指令. 系统处于不安全状态不一定是死锁状态 正确 虚拟存储系统中，只要磁盘空间无限大，则作业就能拥有做任意的编址空间. 错误, 编址空间与地址码有关, 与磁盘空间无关. 说明缺页中断, 并说明与硬件中断的区别.(1) 缺页中断: 若系统发现所要访问的页面不在内存中, 这时就产生一个缺页信号, 即缺页中断。其过程为 : 首先转到操作系统的缺页中断处理程序; 然后程序根据该页在外存的位置将其调入内在中。在调页过程中, 如果内存张有空闲空间,则程序只把缺页装入任何一个空闲存储块中, 再对页表中的相应表现进行修改即可: 若内存中无空闲空间、则必须先淘汰内存中的某些页面 , 若被淘汰页曾被修改过, 则将其写回外存. (2) 区别 缺页中断在指令的执行期间产生和处理中断; 一条指令可以产生多个缺页中断。 电子转账解决死锁问题系统会死锁, 是因为对两个账户进行加锁操作时可以分割进行的, 若此时有两个用户同时进行转账, 进程 P1 先对账户 A 进行加锁, 再申请账户 B; 进程 P2 先对账户 B 进行加锁再申请账户 A, 此时产生死锁。解决方法: 可以采用资源顺序分配法对 A、B 账户进行编号, 用户转账时只能按照编号由小到大进行加锁; 也可以采用资源预分配法, 要求用户在使用资源之前将所有资源一次性申请到.","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"考研","slug":"考研","permalink":"/tags/考研/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"/tags/数据结构和算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"苏州大学2007年872试题","slug":"苏州大学2007年试题","date":"2021-07-05T01:54:15.000Z","updated":"2024-03-02T16:13:05.047Z","comments":true,"path":"2021/07/05/苏州大学2007年试题/","link":"","permalink":"/2021/07/05/苏州大学2007年试题/","excerpt":"","text":"数据结构名词解释 逆波兰式: 后缀表达式, 运算符在操作数后面. 自由树: 无回路的连通图. 外部排序: 将待排序的记录存储在外存上, 排序时再把数据一部分一部分地调入内存进行排序. 在排序过程中需要多次进行外存和内存之间的交换, 对外存文件中的记录进行的结果仍然放到原有文件中. 邻接表: 对图 G 中的每个顶点 V1 建立一个单链表, 第 i 个单链表中的结点表示依附于顶点 Vi 的边. 边表的头指针和顶点的数据信息采用顺序存储. 占位程序: 缺失或未经测试的函数的简化版, 用于产生足以用于测试的值. 队列的实现方法有哪些? 试比较各种实现方法的优缺点, 并距离说明队列在计算机系统中有何应用? 队列的实现方法有: 顺序队列, 即采用顺序存储结构存储队列. 链式队列, 即采用链式存储结构存储队列. 各有什么优缺点: 顺序队列 优点: 可以一次性分配保证够用的空间, 效率高, 因为是基于数组的, 长度也是固定的. 可以实现动态容量. 缺点: 动态分配长度时, 效率低下. 链表队列 优点: 可以方便快速地动态增长. 缺点: 由于基于链表, 要动态创建和删除节点, 效率较低. 应用 解决主机于外部设备之间的速度不匹配的问题. 解决由多用户引起的资源竞争问题. 链表的交集def intersection(l1: ListNode, l2: ListNode) -&gt; ListNode: &quot;&quot;&quot; 求两个有序单链表的交集, 存放在l1中. 设置两个指针分别指向两个链表的开头, 如果两个指针指向的结点的值相同, 则表示位于交集内. 如果不相同, 则比较两个结点的值的大小, 如果l1的大, 则移动l2的指针. 否则删除当前l1的结点. Args: l1 (ListNode): 有序单链表1 l2 (ListNode): 有序单链表2 Returns: ListNode: 交集的单链表 &quot;&quot;&quot; if not l1 or not l2: return l1 h1, h2 = ListNode(0, l1), ListNode(0, l2) t1, t2 = h1, h2 while t1.next and t2.next: # 如果相等则t1,t2移动到下一格 if t1.next.val == t2.next.val: t1, t2 = t1.next, t2.next # 如果大于则移动t2, 直到相等或者大于t1.val elif t1.next.val &gt; t2.next.val: t2 = t2.next # 如果t1.val &lt; t2.val 则移动t1, 且跳过当前结点 else: t1.next = t1.next.next return l1 合并二叉排序树def insert_node(tree: TreeNode, target: TreeNode): &quot;&quot;&quot; 将一个节点插入到二叉排序树中. Args: tree (TreeNode): 二叉排序树 target (TreeNode): 目标节点 &quot;&quot;&quot; if target.val == tree.val: return elif target.val &lt; tree.val: if tree.left: insert_node(tree.left, target) else: tree.left = target else: if tree.right: insert_node(tree.right, target) else: tree.right = target def merge_search_tree(tree: TreeNode, target: TreeNode) -&gt; TreeNode: &quot;&quot;&quot; 合并两个二叉排序树. 后序遍历第二个二叉排序树, 对于遍历到的每个节点, 将其作为单个节点插入到第一个二叉排序树中, 然后返回第一个二叉排序树. Args: tree (TreeNode): 第一个二叉排序树 target (TreeNode): 二个二叉排序树 Returns: TreeNode: 合并后的二叉排序树 &quot;&quot;&quot; def post_order(idx: TreeNode): &quot;&quot;&quot; 后序遍历 Args: idx (TreeNode): 遍历的当前节点 &quot;&quot;&quot; if idx.left: post_order(idx.left) if idx.right: post_order(idx.right) idx.left, idx.right = None, None insert_node(tree, idx) post_order(target) return tree 有向无环图的最长路径def longest_path(_map: dict, start: int = 0): &quot;&quot;&quot; 求DAG的单源最长路径. 可以转换成求所有权值为相反数的最短路径. 最短路径可以使用Dijkstra求出. Args: _map (dict): DAG &quot;&quot;&quot; length = [float(&#39;inf&#39;) for _ in range(len(_map))] pre = [start for _ in range(len(_map))] que = [[-v[0], v[1], v[2]] for v in _map[start]] heapq.heapify(que) for _ in range(len(_map) - 1): idx_len, idx_node, idx_pre = heapq.heappop(que) length[idx_node] = idx_len pre[idx_node] = idx_pre for v in _map[idx_node]: heapq.heappush(que, [-v[0] + idx_len, v[1], v[2]]) max_node = start for i in range(len(length)): if length[i] &lt; length[max_node]: max_node = i print(f&#39;The longest path length is {-length[max_node]}&#39;) path = [str(max_node)] while pre[max_node] != max_node: max_node = pre[max_node] path.append(str(max_node)) path_str = &#39;-&gt;&#39;.join(path[::-1]) print(f&#39;The path is {path_str}&#39;) 由于使用到了最小堆, 并且每条边都会进行加入最小堆操作, 因此时间复杂度为 O(E+V*log(V)) 操作系统请判断下属说法的对错, 并说明原因 分时操作系统必然建立在多道程序技术的基础之上 错误, 多道程序设计引入的目的是提高 CPU 的使用率, 两者无关. 进程是指令的集合 错误, 进程是任务的执行者, 程序是机器指令和数据的集合, 进程可以被看作正在运行的计算机程序. 存储保护的功能是限制内存存取 错误, 保证进入内存的各道作业都在自己的存储空间内运行, 互补干扰. 位示图可用于主存空间的共享 错误, 用于管理磁盘空间和主存空间. 内存管理(非连续)略 连续分配、链接分配、UNIX inode 分配. 详细说明下列的文件访问需求, 采用那种分配方案最合适.大文件顺序访问连续分配, 因为每个文件占据磁盘上的一组连续的块, 适合文件顺序访问. 大文件直接访问UNIX inode, 可以将所有的数据块指针集中到索引块中, 方便直接访问文件. 小文件直接访问链接分配: 可以直接访问文件, 适合小文件直接访问. [连续分配] : 每个文件在磁盘上占有一组连续的块。 优点: 实现简单, 用于连续分配文件的所需寻道数量最小, 在确实需要寻道时所需的寻道时间也最小. 缺点: 为新文件找到足够可分配空间较为困难, 会存在外部碎片. [链接分配] : 采用链接分配, 每个文件是磁盘块的链表, 一个链表包含一个文件的内容. 优点: 解决了连续分配的分配文件困难的问题, 因为可以随机散布一个文件内容, 所以不要求文件保存的连续性. 缺点: 仅能有效用于顺序访问文件, 要找到文件的 i 块, 就必须冲文件开始起, 跟着指针一直到第 i 块. 不能有效地支持文件直接访问. 在空间利用上, 指针也占用了额外的空间. [索引分配(UNIX inode)] : 索引分配在链接分配基础上, 将所有指针放在一起, 依次排列, 形成索引块. 解决了链接分配不能直接访问的问题. 优点: 既没有外部碎片, 让文件可以在磁盘上随机存储, 又解决了直接访问的问题. 缺点: 浪费空间, 每个文件都需要有一个索引块, 而当文件过小时, 也需要分配一个完整的索引块. 而索引块的大小也有不同的机制进行管理. 什么是虚拟设备, 为什么在操作系统中要引入虚拟设备?将一台物理 I/O 设备虚拟为多台逻辑上的 I/O 设备, 并允许每个用户占用一台逻辑上的 I/O 设备. 这样可以使原来仅允许在一段时间内由一个用户访问的设备(临界资源), 变为在一段时间内允许多个用户同时访问的共享设备. 哲学家就餐问题概述: 每个哲学家会优先去去拿序号低的一侧的筷子, 然后去拿序号高的一侧的筷子. 不去拿中间的筷子. // 表示哲学家周围的筷子资源, 初始都为 1, 表示都未被占用. Semaphore chopsticks[5] = {1,1,1,1,1}; // 表示编号为 i 的哲学见的行动 Procedure philosopher(int i){ while(true){ int priority_chopstick = 0; thinking(); if i != 4{ P(chopsticks[i]); P(chopsticks[i+1]); eating(); V(chopsticks[i+1]); V(chopsticks[i]); } else { P(chopsticks[0]); P(chopsticks[4]); eating(); V(chopsticks[0]); V(chopsticks[4]); } } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"考研","slug":"考研","permalink":"/tags/考研/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"/tags/数据结构和算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"苏州大学2006年872试题","slug":"苏州大学2006年试题","date":"2021-07-04T09:41:15.000Z","updated":"2024-03-02T16:13:03.991Z","comments":true,"path":"2021/07/04/苏州大学2006年试题/","link":"","permalink":"/2021/07/04/苏州大学2006年试题/","excerpt":"","text":"数据结构名词解释 堆栈: 只允许在一端进行插入和删除操作的线性表 最小生成树: 对一个带权连通无向图 G=(V, E), 生成树不同, 每棵树的权也可能不同. 设 R 为 G 的所有生成树的集合, 若T 为 R 中边的权值之和最小的那棵生成树, 则 T 称为 G 的最小生成树. 折半查找: 用于有序的顺序表, 首先将给定的 key 与表中中间位置的元素的关键字比较, 若相等, 则查找成功, 返回该元素的存储位置, 若不等, 则所需查找的元素只能在中间元素以外的前半部分或后半部分中, 缩小范围, 继续查找. 堆排序: 将 arr[1…n] 看成一颗完全二叉树的顺序存储结构, 利用完全二叉树中双亲结点和子结点的关系, 每次在当前无序区中选择关键词最大的元素. 连通分量: 无向图的极大连通子图 依次像队列和双端队列输入[1, 2 , 3, 4, 5, 6], 是否可以得到一下输出.略. 二叉树叶结点放入动态分配顺序存储结构的顺序表def leaves_list(tree: TreeNode) -&gt; list: &quot;&quot;&quot; 二叉树叶结点放入动态分配顺序存储结构的顺序表. 采用dfs算法搜索从左到右搜索叶结点. 由于python的list本身就为动态分配的顺序存储结构, 其他语言需要在加入新元素后扩大容量 每次扩大为当前容量大两倍. Args: tree (TreeNode): 树根节点. Returns: list: 动态分配的保存叶结点顺序存储结构. &quot;&quot;&quot; head = [] def dfs(root: TreeNode): if not root.left and not root.right and root.val != -1: head.append(root.val) else: if root.left: dfs(root.left) if root.right: dfs(root.right) dfs(tree) return head 字符串匹配（以后的考试不做要求）def index(source: str, target: str) -&gt; int: &quot;&quot;&quot; 字符串定位操作. 在字符串中找到目标字符串的起始下标. 在定位操作过程中, 首先定位目标字符串的首尾, 如果首位字符符合, 再匹配中间字符. Args: source (str): 源字符串. target (str): 目标字符串. Returns: int: 目标字符串在源字符串的起始下标. &quot;&quot;&quot; len_s = len(source) len_t = len(target) if len_t == 0 or len_s == 0: return -1 for i in range(0, len_s - len_t - 1): if source[i] == target[0] and source[i + len_t - 1] == target[-1]: if source[i:i + len_t] == target: return i return -1 归并排序链表def merge_sort_ln(head: ListNode) -&gt; Optional[ListNode]: &quot;&quot;&quot; 归并排序算法排序单链表. Args: head (ListNode): 单链表的头结点. Returns: Optional[ListNode]: 排序后的单链表头结点. &quot;&quot;&quot; def merge_ln(h1: Optional[ListNode], h2: Optional[ListNode]) -&gt; Optional[ListNode]: &quot;&quot;&quot; 合并函数. 将两个排序好的单链表合并为一个排序好的单链表. Args: h1 (Optional[ListNode]): 第一个排序好的单链表. h2 (Optional[ListNode]): 第二个排序好的单链表. Returns: Optional[ListNode]: 合并完成的单链表. &quot;&quot;&quot; d_h = ListNode() t, t1, t2 = d_h, h1, h2 while t1 and t2: if t1.val &lt;= t2.val: t.next, t1 = t1, t1.next else: t.next, t2 = t2, t2.next t = t.next if t1: t.next = t1 else: t.next = t2 if not d_h.next: return None return d_h.next def sort_func(h: Optional[ListNode], tail: Optional[ListNode] = None) -&gt; Optional[ListNode]: &quot;&quot;&quot; 递归拆分函数. 拆分直到头结点和尾结点中间仅剩一个结点, 或者没有结点. 采用快慢指针的方式找到头尾结点的中间结点, 然后拆分为两部分. Args: h (Optional[ListNode]): 拆分的头结点 tail (Optional[ListNode], optional): 拆分的尾结点. Defaults to None. Returns: Optional[ListNode]: 返回合并好的单链表. &quot;&quot;&quot; if not h: return h if h.next == tail: h.next = None return h slow = fast = h while slow and fast and fast != tail: slow, fast = slow.next, fast.next if fast != tail and fast: fast = fast.next mid = slow return merge_ln(sort_func(h, mid), sort_func(mid, tail)) return sort_func(head) 操作系统判断下列说法是否正确, 并说明理由在单 CPU 的计算机系统中, 进程是不能并行操作的.正确, 单 CPU 只能并发操作, 无法做到真正的并行操作. 在死锁发生后, 参与死锁的所有进程都占有资源.错误, 参与死锁的所有进程均等待资源, 参与死锁的进程至少有两个已经占有资源. 存储管理中的请求分页系统必定需要重新定位机制的支持.错误, 重定位机制用于连续分配方式中. 解释以下概念 中断: 也称为外中断, 来自 CPU 执行指令以外的时间的发生, 如设备发出的 I/O 结束中断, 表示设备输入/输出处理已经完成, 希望处理机能够向设备发出下一个输入/输出的请求, 同时让完成输入/输出后的程序继续运行. 这一类中断通常是与当前程序运行无关的事件 , 即它们与当前处理机运行的程序无关. 虚拟设备: 通过某种虚拟技术, 将一台无力设备变成若干台逻辑设备, 从而实现对多个用户对该物理设备的同时分享. 中级调度: 内存调度. 为了提高内存利用率和系统吞吐率. 中级调度用于把进程从内存移到外存, 当内存有足够空间时,再将合适的进程换入内存. Cache: 访问速度比一般随机存储器快的一种存储器, 用于让数据访问速度适应 CPU 处理速度. LRU 算法: 选择最近最长未访问过的页面予以淘汰的算法. 在虚拟存储技术中, 系统将进行进程运行时所缺的页面调入内存的时机有预调页策略和请求式调页策略两种. 请说明这两种策略的原理, 并结合具体的实例比较这两种策略的优劣. 预调页技术 以预测为基准, 将预计在不久后便会访问的程序或数据所在的页, 预先调入内存. 优点: 一次调入若干页, 效率较好. 缺点: 预测不一定准确, 预调入的页面可能根本不被执行到. 主要用于进程的首次调入 , 由程序员指出应该先调入哪些页. 请求调页策略: 进程在运行中提出调页请求后, 系统将其所需的页面调入内存. 优点: 由该请求调页策略所确定调入的页, 一定会被访问; 比较容易实现. 缺点: 每次仅调入一页, 需要花费较大的系统开销, 增加了磁盘 I/O 的频率. PV 操作Semaphore s = 1 // 表示缓冲区是否为空, 初始为1 Semaphore d1 = 0; // 表示是否有D1在缓冲区 Semaphore d2 = 0; // 表示第二个进入缓冲区的数据是否是D2 Semaphore d3 = 0; // 表示第二个进入缓冲区的数据是否是D3 // D1 Procedure D1(){ while(1){ P(s); 将d1数据写入缓冲区; V(d1); } } // D2 Procedure D2(){ while(1){ P(d1); 将d2数据写入缓冲区; V(d2); } } // D3 Procedure D3(){ while(1){ P(d1); 将d3数据写入缓冲区; V(d3); } } // H1 Procedure H1(){ while(1){ P(d2); 把d1, d2数据从缓冲区拿出, 并处理. V(s); } } // H2 Procedure H2(){ while(1){ P(d3); 把d1, d3数据从缓冲区拿出, 并处理. V(s); } } 文件管理根据题意, 可知每条记录所需的长度. 姓名(8 byte) + 地址(100 byte) + 年龄(1 byte) + 专业(20 byte) = 129byte 一共有 32000 条记录, 故总共需要 4128000 byte = 4128 KB = 1032 * 4KB = 1032 个物理块. 设计的方案: 文件的逻辑结构: 由于对此文件的操作主要是根据姓名进行记录的查询, 因此可以根据姓名的首字母对文件进行分目录存储, 即姓名首字母相同的分在同一个目录, 最多有 26 个目录. 每个目录中的文件长度差不多, 因此可以将这个文件的逻辑文件信息连续存放, 即采用顺序文件的方式. 文件的物理结构: 由于该文件的大小已知, 故可以采用连续分配的方式, 把逻辑文件中的记录顺序地存储到相邻的物理盘块中; 这样查找速度快, 且没有增加其他额外空间. 在该结构下, 每次检索平均需要访问 1032 / 2 = 516 个物理块","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"考研","slug":"考研","permalink":"/tags/考研/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"/tags/数据结构和算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"苏州大学2005年872试题","slug":"苏州大学2005年试题","date":"2021-07-03T09:20:15.000Z","updated":"2024-03-02T16:13:04.022Z","comments":true,"path":"2021/07/03/苏州大学2005年试题/","link":"","permalink":"/2021/07/03/苏州大学2005年试题/","excerpt":"","text":"数据结构什么叫平衡二叉树? 一棵结点数为 n 的平衡二叉树的平均查找时间为多少? 请简述. 它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1, 并且左右两个子树都是一个平衡二叉树. 平均查找时间为 O(logN) [ 递归的描述方式, 当前高度差不超过 1, 或为空树, 子树也满足同样的条件 ] 有 1000 个无序的数值, 希望从快速排序、基数排序、堆排序、归并排序中选一种排序算法, 能以最快的速度排出 10 个最大的数据来. 试问选哪一种排序算法? 为什么? 应该选择堆排序 快速排序、堆排序、归并排序的平均时间复杂度都为 O(logN) 的排序算法, 基数排序的平均时间复杂度为 O(d(n+rd)), 故首先排除基数排序. 由于只需要选择前 10 大的数, 而堆排序每一次可以取出未排序的数组中的最大数, 故只需要取出 1 次就可以排出最大的 10 个数据. [ 考察了对于各种排序算法的区别的认识. 考察了最大堆每次可以取出最大数的性质 ] 删除链表中相同的节点def remove_same(node: Optional[ListNode]) -&gt; Optional[ListNode]: &quot;&quot;&quot; 删除链表中相同的节点. 创建一个集合, 然后遍历链表, 如果当前值不在集合中, 则将其加入集合, 如果存在, 则跳过当前结点. 因为需要跳过结点, 因此指针应该位于当前结点的前驱结点, 跳过结点也就是前驱结点的next指向了后继结点. Args: node (Optional[ListNode]): 待去重的链表 Returns: Optional[ListNode]: 去重后的链表 &quot;&quot;&quot; if not node: return node point_s, idx = set(), node while idx.next: if idx.next.val in point_s: idx.next = idx.next.next else: point_s.add(idx.next.val) idx = idx.next 三元表顺序表转置矩阵，快速转置算法def fast_transpose(ts: TSMatrix) -&gt; TSMatrix: &quot;&quot;&quot; 三元组顺序表快速转置算法. 转置的算法并不复杂, 只需要互换x, y的坐标即可. 但真正困难的是将排序后的坐标排序形成顺序表. 快速转置算法的原理是利用开始时已经排序好的三元组顺序表的信息, 在常数时间内将其放入新的三元组中. 具体如下: 1. 已知未排序的三元组顺序表是先根据x排序, 若x相同, 再根据y排序. 则转置后y一定是从上到下依次 递增的, 因此我们可以利用这一点. 2. 先遍历一遍转置后的顺序表, 记录不同的x的分组各有多少个. 将其保存至一个数组中. 这是为了 在遍历到一个三元组时, 可以方便地知道要将其放入在什么位置. 3. 最后便利一遍待转置的三元组顺序表, 每次将当前三元组转置后放入目标顺序表中. Args: ts (TSMatrix): 待转置的三元组顺序表 Returns: TSMatrix: 转置完成的三元组顺序表 &quot;&quot;&quot; nums = [0 for _ in range(ts.nu + 1)] for item in ts.triple_list: nums[item.j] += 1 pot = [0, 1] for item in nums[1:]: pot.append(pot[-1] + item) res = TSMatrix(mu=ts.nu, nu=ts.mu, tu=ts.tu) for triple in ts.triple_list: triple.i, triple.j = triple.j, triple.i res.triple_list[pot[triple.i] - 1] = triple pot[triple.i] += 1 ts = res return ts 全排列def permutations(lst: list) -&gt; List[int]: &quot;&quot;&quot; 输出数组的全排列. 使用dfs算法输出数组的全排列. 在每次调用函数时, for循环遍历所有arr[le]的情况, 然后递归去寻找 (le+1, ri)的全排列. 直到le==ri, 则保存当前的arr为一个排列. 这是一种自顶向下的实现方法. Args: lst (list): 输入的数组 Returns: List[int]: 全排列的结果 &quot;&quot;&quot; res = [] def dfs(arr: list, le: int, ri: int): if le == ri: res.append(arr[:]) else: i = le for num in range(le, ri): arr[num], arr[i] = arr[i], arr[num] dfs(arr, le + 1, ri) arr[num], arr[i] = arr[i], arr[num] dfs(lst, 0, len(lst)) return res 操作系统请解释并比较以下概念共享设备和独占设备 共享设备: 通过分时共享使用的设备. 在申请设备时, 如果设备空闲, 就将其独占, 不再允许其他进程申请使用. SMP 和 ASMP SMP: Symmetric multiprocessing, 对称多处理器结构, 在一个计算机上汇集了一组处理器(多 CPU), 每个处理器之间共享子系统和总线结构. ASMP: Asymmetric multiprocessing, 非对称多处理器结构, CPU 被不平等对待. 物理地址和逻辑地址 物理地址: 内存中物理单元的集合. 面向用户和程序员的地址空间. 简答题目录在文件系统中的作用是什么?使文件控制块与文件一一对应 在操作系统中引入线程有什么好处?减小程序在并发执行时的时空开销, 提高操作系统并发性能. 在设计操作系统时, 主要哪几种结构可供选择? 大内核系统将操作系统的主要功能模块都作为一个紧密联系的整体运行在核心态, 从而为应用提供高性能的系统服务. 微内核系统将内核中最基本的功能(进程管理等)保留在内核, 将那些不需要在核心态执行的功能移动到用户态执行, 降低了内核设计的复杂性. 进程调度内存有 3 页数据区 [2, 3, 4, 5, 3, 4, 1, 2, 3, 5, 1, 4, 1, 4, 5, 1, 3, 2, 1, 3] 采用一下算法的缺页次数和发生缺页的时间. FIFO LRL OPT PV 操作服务员放香蕉和草莓, 男人吃草莓, 女人吃香蕉. 水果盘只有一个空位. Semaphore cap = 1; // 表示水果盘的剩余容量 Semaphore stra = 0; // 表示水果盘中草莓的剩余数量 Semaphore bana = 0; // 表示水果盘中香蕉的剩余数量 // 服务员进程 Procedure Waiter{ while(true){ P(cap); 将水果放入水果盘中; if(放入的是草莓){ V(stra); }else if(放入的是香蕉){ V(bana); } } } // 男人进程 Procedure Man{ while(true){ P(stra); 从水果盘中取出草莓; V(cap); 吃掉草莓; } } // 女人进程 Procedure Woman{ while(true){ P(bana); 从水果盘中取出香蕉; V(cap); 吃掉香蕉; } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"考研","slug":"考研","permalink":"/tags/考研/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"/tags/数据结构和算法/"},{"name":"操作系统","slug":"操作系统","permalink":"/tags/操作系统/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"软件需求分析知识点汇总","slug":"软件需求分析知识点汇总","date":"2021-06-01T15:01:15.000Z","updated":"2024-03-02T16:13:04.293Z","comments":true,"path":"2021/06/01/软件需求分析知识点汇总/","link":"","permalink":"/2021/06/01/软件需求分析知识点汇总/","excerpt":"","text":"1 需求概述需求问题的提出讲述了在项目设计时，分析需求的重要性。 以及如果没有有效地分析需求，会造成怎样的结果。 在项目开发中，所有的干系人（涉众（Stakeholder）都对需求分析阶段感兴趣。 干系人是指所有能够影响软件系统的实现或者会被实现后的软件系统所影响的个人或团体。（如用户，客户，开发者，管理者，领域专家等） 未真正明白这些问题就开始编码，结果没有人对产品满意。 需求的定义需求定义的不同观点IEEE 的需求定义 用户解决问题或达到目标所需的条件或权能（Capability）。 系统或系统部件要满足合同、标准、规范或其它正式规定文档所需具有的条件或权能。 一种反映上面（1）或（2）所描述的条件或权能的文档说明。 IEEE 公布的定义包括从用户角度（系统的外部行为），以及从开发者角度（一些内部特性）来阐述需求。关键的问题是一定要编写需求文档。 Jones 认为的需求用户所需要的并能触发一个程序或系统开发工作的说明。 Sommerville 认为的需求需求是指明必须实现什么的规格说明。它描述了系统的行为、特性或属性，是在开发过程中对系统的约束。 优秀需求的特征 完整性:需求无遗漏，即需求变更中“新需求”所占量不大。 正确性：每一项需求都必须准确地陈述其要开发的功能。 无歧义性：对所有的需求说明的读者只能有一个明确统一的解释。 可行性：每一项需求都必须是在已经知道系统和环境的权能和限制范围内可以实现的。 有优先级 必要性 可验证性:检查每项需求是否能通过设计测试用例或其他的验证方法，如有演示、检测等来确定产品是否确实按需求实现了。 需求的层次与分类 业务需求：描述为什么要开发系统 why）开发系统的目标是什么，为什么要有这个系统。 用户需求：描述系统能够帮用户做什么（what） 系统需求：描述达到用户要求的具体流程（How） 业务需求业务需求是指反映组织机构或客户对系统、产品高层次的目标要求，通常问题定义本身就是业务需求。 目标通常就是业务需求 业务需求的内容 业务：产品属于哪类业务范畴？应该完成什么功能？需要为什么服务？ 客户：产品为谁服务？目标客户是谁？ 特性：产品区别于其他竞争产品的特性是什么？ 价值：产品的价值体现在什么方面？ 优先级：产品功能特性的优先级次序是什么？ 用户需求用户需求是指描述用户使用产品必须要完成什么任务，怎么完成的需求，通常是在问题定义的基础上进用户访谈、调查，对用户使用的场景进行整理，从而建立从用户角度的需求。 系统需求系统需求（system requirement）用于描述包含多个子系统的产品（即系统）的顶级需求。系统可以只包含软件系统，也可以既包含软件又包含硬件子系统。人也可以是系统的一部分，因此某些系统功能可能要由人来承担。 软件需求软件需求分为：功能需求，非功能需求和设计约束 功能需求描述系统应该提供的功能或服务，通常涉及用户或外部系统与该系统之间的交互，一般不考虑系统的实现细节。 功能需求是需求的主体，是需求的本质。 功能需求定义了：系统必须完成的那些事，即为了向它的用户提供有用的功能，产品必须执行的动作 。 零散（需求项）-&gt; 整理（特性、用例） 功能需求需要对用户需求进行分析、提炼、整理，因为用户需求具有零散、存在矛盾的特点。功能需求是需求分析与建模的产物，能生成指导开发的、更精确的软件需求。 非功能需求 描述了系统展现给用户的行为和执行的操作等。它包括外部界面的具体细节、性能要求及质量属性。 非功能需求是产品必须具备的品质，他们可以让产品有吸引力、易于使用、快速、可靠或者安全。 功能性需求是让产品工作的需求，非功能需求是为工作赋予特性的需求。 质量属性质量是反映实体满足明确和隐含需要的能力的特性总和 设计约束设计约束是指对开发人员在软件产品设计和构造上的限制，产品必须遵从的标准、规范和合约。包括：非技术因素的技术选型、预期的软硬件环境和预期的使用环境三大类型。 需求在总体方案中的位置软件生存周期软件生存周期就是从提出软件产品开始，直到该软件产品被淘汰的全过程。 瀑布模型(线形顺序模型) 特点： 从上一项活动接收该项活动的工作对象，作为输入； 利用这一输入实施该项活动应完成的内容； 给出该项活动的工作结果，作为输出传给下一项活动； 对该项活动实施的工作进行评审。若其工作得到确认，则继续进行下一项活动，否则返回前项，甚至更前项的活动进行返工。 缺点: 严格分级导致缺乏灵活性，特别是无法解决软件需求不明确或不准确的问题。凡前一阶段出现的问题需要通过后一阶段的重新确认来解决，所以这一点在开发过程完成后才有所察觉，因此,有时其代价十分高昂。 人员之间的通讯和软件工具之间的联系以及开发工作之间的并行和串行等都是必要的，但瀑布模型中并没有体现出这一点。 需要人员比较多； 瀑布式方法在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。 原型法 特点： 开发者和用户可充分通信，明确用户的需求； 可以给用户以机会更改心中原先设想的、不尽合理的最终系统； 可以低风险开发柔性较大的计算机系统； 使系统更易维护、对用户更友好的机会； 使总的开发费用降低，时间缩短。 缺点： “模型效应”或“管中窥豹”。对于开发者不熟悉的领域把次要部分当作主要框架，做出不切题的原型。 原型迭代不收敛于开发者预先的目标。为了消除错误，每次更改，次要部分越来越大，“ 淹没”了主要部分。 原型过快收敛于需求集合，而忽略了一些基本点。 资源规划和管理较为困难，随时更新文档也带来麻烦。 螺旋模型 特点： 螺旋模型加入了风险分析，是一种风险驱动的方法体系； “螺旋模型”的核心就在于不需要在刚开始的时候就把所有事情都定义的清清楚楚。可以先定义最重要的功能，实现它，然后听取客户的意见，之后再进入到下一个阶段。如此不断轮回重复，直到得到满意的最终产品。因此，迭代过程这种模式使适应需求的变化会更容易些； 加快了整个开发工作的进度。因为开发人员清楚问题的焦点所在，他们的工作会更有效率； 使用面向对象的语言或统一建模语言 缺点： 这个模型的使用需要具有相当丰富的风险评估经验和专门知识，具有高素质的项目管理者和软件研发团队。 增量模型 特点： 这种模型融合了线性顺序模型的基本成份和原型实现模型的迭代特征。 人员分配灵活，刚开始不用投入大量人力资源，当核心产品很受欢迎时，可增加人力实现下一个增量。 当配备的人员不能在设定的期限内完成产品时，它提供了一种先推出核心产品的途径，这样就可以先发布部分功能给客户，对客户起到镇静剂的作用。 缺点： 始至终开发者和客户纠缠在一起，直到完全版本出来。 敏捷模型（SCRUM）特点： 从产品角度看，敏捷方法适用于需求萌动并且快速改变的情况，如系统有比较高的关键性、可靠性、安全性方面的要求，则可能不完全适合； 从组织结构的角度看，组织结构的文化、人员、沟通则决定了敏捷方法是否适用。 瀑布模型式是最典型的预见性的方法，严格遵循预先计划的需求、分析、设计、编码、测试的步骤顺序进行。敏捷方法强调适应性而非预见性，相比迭代式开发两者都强调在较短的开发周期提交软件，敏捷开发的周期可能更短，并且更加强调队伍中的高度协作。 2 需求工程需求工程的提出简述了需求工程是怎么提出，如何提出，在什么时间提出的。 需求工程的定义需求工程(RE)的概念 是指应用已证实有效的技术、方法进行需求分析，确定客户需求，帮助分析人员理解问题并定义目标系统的所有外部特征的一门学科。 RE 通过合适的工具和记号系统地描述待开发系统及其行为特征和相关约束，形成需求文档，并对用户不断变化的需求演进给予支持。 需求分析专家 Alan Davis 把需求工程定义为“直到（但不包括）把软件分解为实际架构构件之前的所有活动” 需求工程 RE 可分为系统需求工程（如果是针对由软硬件共同组成的整个系统）和软件需求工程（如果仅是专门针对纯软件部分）。 传统的需求处理是软件工程的需求阶段，系统化的需求工程则将软件需求开发和系统需求开发结合起来，在系统工程的开始阶段起到重要的作用。 软件需求工程是一门分析并记录软件需求的学科，它把系统需求分解成一些主要的子系统和任务，把这些子系统或任务分配给软件，并通过一系列重复的分析、设计、比较研究、原型开发过程把这些系统需求转换成软件的需求描述和一些性能参数。 需求工程的内容需求工程是系统工程和软件工程的一个交叉分支，涉及到软件系统的目标、软件系统提供的服务、软件系统的约束和软件系统运行的环境。它还涉及这些因素和系统的精确规格说明以及系统进化之间的关系。它也提供现实需求和软件能力之间的桥梁。 需求工程的五阶段生命周期：需求定义和分析、需求决策、形成需求规格、需求实现与验证、需求演进管理 三阶段周期的说法：获取、表示和验证 需求开发需求开发的任务是准确地定义未来系统的目标，确定为了满足用户的需求系统必须做什么。 需求获取从项目的规划开始建立最初的原始需求。 需求获取是需求工程的主体,非常困难，主要原因有： 缺乏领域知识,应用领域的问题常常是模糊的、不精确的； 存在默认的知识,如难以描述的常识问题； 存在多个知识源,且多知识源之间可能有冲突； 客户可能的偏见，如不能提供或不想告知你所需要了解的事情。 需求分析、协商与建模需求分析阶段主要对收集到的需求进行提炼、分析和认真审查，进行需求建模、对模型或原型进行分析。确保所有参加人员取得一致共识。找出错误、遗漏和不足，建立完整的分析模型。 需求规约 采用原始模板，在你的组织中要为编写软件需求文档定义一种标准模板 指明需求的来源 为每项需求注上标号制定一种惯例来为每项需求提供一个独立的可识别的标号或记号 记录业务规范 需求验证需求验证目的是要检验需求是否能够反映用户的意愿 有效性检查—指功能需求是否符合用户所提出的需求。 一致性检查—系统功能描述及约束是否一致。 完备性检查—是否包含所有系统用户的需求和约束。 可检验性检查—是否能设计出一组验证方法。 需求管理需求管理是一种用于查找、记录、组织和跟踪系统需求变更的系统化方法，可用于获取组织和记录系统需求并使客户和项目团队在系统需求变更上保持一致。 有效的需求管理在于维护清晰明确的需求阐述，每种需求类型所适用的属性，以及与其他需求和其他项目工作之间的可追踪性。 其活动包括：定义需求基线，建立跟踪信息，进行变更控制。 需求工程优秀实践 需求分析师职责需求分析师是对项目涉众的需求进行收集、分析、记录和验证等职责的主要承担者。 工作 需求分析师是客户与开发人员交流的中间人，负责将客户对产品的初步想法转化为明确的需求说明，用来指导开发工作。 定义业务需求 需求分析师的第一项工作是帮助业务或出资方、产品经理或市场经理定义项目的业务需求。 规划需求方法 确定项目干系人和用户类别 获取需求 需求分析师可能要用到各类信息收集技巧，帮助用户阐明自己需要那些系统功能，满足业务目标。 分析需求 需求分析师还要对收集到的需求进行分析，找出那些客户没有明确说明的需求。 记录需求 沟通需求 主导需求的验证 引导对需求的优先级排序 需求分析师要负责对各类干系人和开发人员进行合作与协商，以保证他们进行合理的优先级划分 。 管理需求 需求分析师参与了软件开发的整个生命周期 ，因此，他应该帮助制订、检查和执行项目的需求管理计划。 必备技能 倾听的技巧 要善于双向交流，就必须知道如何有效地倾听。 访谈谈和提问的技巧 大部分需求是通过讨论得到的，因此，需求分析师必须能够与不同的个人或小组就需求展开讨论。 才思敏捷 分析技巧 系统思考的技巧 学习技巧 引导技巧 观察能力 领导力技巧 观察技巧 观察力敏锐的需求分析师能够从不经意的闲谈中发现重要的信息。 沟通技巧 组织技巧 需求分析师需要处理获取和分析过程中收集到的大量杂乱的信息。 建模技巧 人际交往能力 需求分析师应具备让彼此利益竞争的人们进行合作的能力。 创造性 需求分析师不能像抄录员那样只记下客户说过的每句话。 需求分析师还需具备从实践经验中积累的广博知识。 其中最基本的是对当代需求管理技术的深刻理解，以及在各种不同的软件开发生命周期环境中应用这些技术的能力。 需求分析师需要将需求开发与管理活动贯穿于整个产品生命期中。 掌握应用领域的知识、最大限度地减少与客户间的误解。 3 需求获取需求获取为涉众团体之间的相互沟通、识别需求的过程。涉众团体通过这个过程提取、定义需求。需求获取不但涉及技术问题，而且涉及社会交往问题。 需求获取的一个必不可少的结果是对项目描述的客户需求的理解。 问题域问题域是指与问题相关的部分现实世界 问题域是定义用户需求的前提条件。用户需求与所处的客观世界是紧密联系的，依赖可运行程序的计算机本身难以产生预期的效果。 需求工程的本质在于从待求解问题加以解决，与问题相对应的是问题的解决方案。 软件需求的相关描述应包括三个方面的内容 问题所处问题域知识的描述，用 K 表示。 用户最终期望在问题域中产生的效果，称为用户需求，用 R 表示。 为实现用户期望的效果，运行待开发软件系统的计算机必须与问题所处的问题域进行交互，对这种交互的描述也与软件需求直接相关，成为规格说明。用 S 表示。 K，S→R,即在三者各自的描述均正确的前提下，S 所定义的行为能在 K 所描述的问题域中产生所期望的效果 R 需求获取方法与技术需求获取的方法 面向对象的方法 基于场景的方法 场景（Scenario)这一概念在需求工程领域取得了广泛的应用。一般来说，它基于对应用环境的某一特定情境的描述来阐述用户的需求。对于这一类方法，目前应用最广泛的是基于用例的方法。用例是从用户的观点，以交互的方式对与系统的行为特征进行的描述，而场景一般认为是用例的一个实例。 面向方面的方法 面向视点的方法 需求获取的技术 面谈法 问卷法调查法 需求专题讨论会 观察用户的工作流程 原型化方法 基于用例的方法 需求重用 建立业务需求业务需求指的是一组信息，描述的是需要，在此需要的指导下，一个或对多个项目交付一个解决方案和符合预期的最终业务成果。业务机会、业务目标、成功标准和一个愿景声明共同构成业务需求。 业务需求的冲突业务需求收集自多个来源，可能有冲突。 协商是解决办法 产品愿景和范围 产品愿景(product vision)将所有涉众统一到一个方向上。描述了产品用来干什么，它最终会是什么样子。 愿景关系到整个产品。当产品的战略定位或信息系统的业务目标随时间发生改变时，愿景也会随之变化，但这种变化相对缓慢。 范围明确当前项目或开发迭代应强调最终产品愿景的那些部分，范围声明的是项目内外的边界。 愿景与范围文档 业务需求 背景 总结新产品或对现有产品进行变更的依据和环境。描述产品开发的历史背景或形式。 业务机遇 业务目标 成功指标 愿景申明 业务风险 业务假设和依赖 范围与限制 项目的范围定义了所提出的解决方案的概念和范围 主要特征 首发版本的范围 概述计划在产品的第一个版本中实现的主要特性。 各后续版本的范围 要采用阶段性的开发方式，需要决定推迟实现哪些特性，并为后续的版本做出时间安排。 限制与排除 定义项目包含的需求与不包含的需求之间的界线。 业务背景 这一部分概述一些项目的业务问题，包括简要描述主要的干系人类别，以及说明项目的管理优先级。 干系人简介 对每类涉众的说明都应提供如下信息： 从产品得到的主要价值或利益，产品如何才能产生较高的客户满意度。 可能对产品采取的态度。 感兴趣的主要功能和特点。 必须加解决的任何已知约束。 项目优先级 要想更有效地进行决策，涉众必须就项目的优先级达成一致。 部署注意事项 获取用户需求要获得用户的需求，应采取以下步骤： 确定产品的不同用户类型。 挑选出每一类用户和其他涉众的代表并与他们一起工作。 对谁是项目需求的决策者达成共识。 寻找用户代表 每个项目都有几位用户类的关键成员负责提供需求。我们称他们为产品代言人(product champion)或用户代言人或项目协调人。 设置用户代言人为构造客户和开发人员之间的伙伴关系提供了有效途径。 每位用户代言人都是他所属用户类的成员与项目的需求分析员之间的主要联系人。 如果每位用户代言人都被赋予足够的权力，能够为他代表的用户类做出具有约束力的决定，他们就能发挥最大效应。 陷阱 用户代言人模型在很多情况下都获得了成功。其成功需要具备以下条件： 用户代言人理解并履行他的职责。 被赋予用户需求级别的决策权，有足够的工作时间。 引入用户代言人时应小心下列可能出现的问题： 一个合格的用户代言人根据授权做出的决定却被经理推翻。 用户代言人如果忘了自己应代表其他客户，而只表达出自己的需求，那么他的工作肯定做不好。 用户代言人如果缺乏对新系统的充分了解，就可能在重要问题上听从需求分析员的决定。 资深用户可能因为自己没有时间而推荐缺少经验的用户担任代言人。 谨防用户试图代表他们不属于的用户类发表意见。 用户需求的冲突处理 如果是个别用户之间的分歧，则由用户代言人来裁决。 如果不同的用户类或客户群提出的需求发生冲突时，应支持最重要的用户类或对产品的商业前景影响最大的客户群提出的需求。 不同的企业客户都可能要求按他们自己的喜好设计产品。解决办法还是依据项目的业务目标来确定哪些客户对项目的成败影响最大。 用户经理表述的需求有时会和其部门中实际用户的需求相矛盾。尽管用户需求必须服从业务需求，但不属于用户类的经理应该服从于用户代言人，因为后者是用户的代表。 当开发人员对产品的想法与客户的要求不一致时，通常应由客户做出决定。 理解需求用例法 用例描述了系统与外部角色之间的一系列交互。 角色(actor)指与系统交互以实现某种目的的人、软件系统或硬件设备。 用例源于面向对象的开发方法,用例转变了需求开发的角度，用例更接近目标。 用例图(user-case diagram)提供了对用户需求的概要性可视化表示。 流程： 找出系统边界和参与者 建立场景 捕获用例 定义关系和建立用例图 基于用例的需求获取需求获取的步骤 识别项目远景 系统改进点不等同于软件需求 用户根据自身的工作特点和支付能力决定哪些应该改进，哪些不需要改进 这就是用户的远景，它表明用户改进的目标，这也将成为项目的目标 业务模型描述了“现实是什么”，远景则描述“希望的改进” 远景表达了“为什么要开发这个系统” 在业务现状(业务模型)下，开发系统是为了达到什么目标？ 识别业务参与者 客户、供应商、合作伙伴、潜在客户、政府等 识别用例 业务为业务参与者提供的价值 体现企业业务本质，是有意义的目标 详述用例 业务用例是对业务流程的封装，在业务建模过程中需要逐一描述其内部细节，即详述业务用例 详细说明业务用例的工作流程 说明业务用例的工作流程，以便于客户、用户和涉众理解 重构用例 利用用例建模高级技术重构用例模型 用例关系 通过用例关系将复杂的用例进行适当的分解，以便于提高需求的复用性和可扩展性等，从而使用例模型的结构更合理 用例分级 可以根据用例的重要程度进行分级，以便后续迭代计划的制定，高级别的用例优先考虑 用例分包 将相关的用例打包，通过分包的方式可以将用例图分层表示，以用于大规模系统的用例建模 4 需求分析与建模分析与需求的关系分析建立在需求获取的基础上 用户视角理解用户问题过渡到开发团队视角分析用户问题 与需求一样，它还是在问题域中 从用户视角跨入开发团队视角 分析与需求捕获在很大程度上重叠，这两个活动常常相辅相成，为了澄清和找出任何遗漏或歪曲的需求，常常需要在需求之上作一些分析 需求分析的模型和方法提出目标系统的数据模型、功能模型和行为模型是需求分析的核心任务。 所谓模型就是系统的一种书面描述，通过抽象、概括和一般化，把研究的对象或问题转化为本质相同的另一对象或问题，以便解决的方法。 数据模型 描述对象系统的本质属性及其关系。常用的建模工具有实体-联系图、类图等。 功能模型 描述对象系统所能实现的所有功能。而不考虑每个功能实现的次序。常用的建模工具有数据流图、活动图等。 行为模型 描述对象系统为实现某项功能而发生的动态行为。常用的建模工具有控制流图、状态转换图和顺序图等。 需求分析方法需求分析方法由对软件问题的信息域和功能域的系统分析过程及其表示方法组成; 常见的有： 面向数据流的结构化分析方法 (SA) 面向对象的分析方法 (OOA) 结构化需求分析与建模 实体关系图(Entity-Relationship Diagram,E-R 图)来创建数据模型，描述系统中所有重要的数据对象； 数据流图（Data Flow Diagram,DFD） ：用来创建功能模型，描述了信息流和数据转换。 状态转换图 （State-Transition Diagram,STD）用来创建行为模型，描述系统状态如何响应外部事件，而进行转换。 数据流图 数据字典数据词典(Data Dictionary，简称 DD)和数据流图密切配合，能清楚地表达数据处理的要求。 数据词典用于对数据流图中出现的所有成分给出定义，它使数据流图上的数据流名字、加工名字和数据存贮名字具有确切的解释。每一条解释就是一条词条，按一定的顺序将所有词条排列起来，就构成了数据词典，就象日常使用的英汉词典、新华词典一样。 通常，数据字典应该包含下列 5 类元素的定义：数据流；数据元素；数据存储；变换处理；源点及终点（汇点）。 E-R 图 用 E-R 模型描述现实世界，不必考虑信息的存储结构、存储路径及存取效率如何在计算机中实现。 该模型面向现实世界，便于直接描述现实世界，且有直观、自然、语义丰富、易于向其它数据模型转换等优点。 状态转换图 活动表语法：事件名（参数表）／动作表达式 常用事件名： Entry、Exit、Do 动作表达式：应做的具体动作 事件表达式：触发状态转换的事件。 语法：事件说明 [守卫条件]／动作表达式。 其中，事件说明的语法：事件名（参数表）。 分析系统的需求说明，找出可能的状态 找出每个状态下的动作 在状态之间画事件 分析系统标注开始与终止状态 面向对象需求分析与建模面向对象方法学概述了解基本概念：对象、类、消息、封装性、继承性、多态性、优点、抽象、封装。 面向对象=对象+类+继承+通信 面向对象方法学的特点 符合人们习惯的思维方式 面向对象方法学将问题域的理念直接映射到对象，以及对象之间的接口，这种映射的方法符合人们习惯的思维方式。 稳定性好 当系统的功能需要变化时，并不会引起软件结构的整体变化，仅需要作一些局部性的修改； 可重用性好 容易开发大型软件产品 可维护性好 易于测试和调试 OOA 的基本原则和任务为建立分析模型，要运用如下的 5 个基本原则： 建立信息域模型； 描述功能； 表达行为； 划分功能、数据、行为模型，揭示更多的细节； 用早期的模型描述问题的实质，用后期的模型给出实现的细节。 OOA 包含三项内容： 理解：由用户与系统分析员、基本领域的专家充分交流，达到充分理解用户的要求和本领域的知识。 表达：将所理解的知识用面向对象方法进行表达。 验证：将所表达的知识用面向对象方法进行验证。 过程： 从业务需求描述出发获取执行者和场景；对场景进行汇总、分类、抽象，形成用例；确定执行者与用例、用例与用例之间的关系，生成用例图，建立功能模型。 从业务需求描述和用例描述中提取“关键概念”，形成领域概念。 依据领域概念和功能模型，研究系统中主要的类之间的关系，生成类图，建立对象模型。 从用例出发，将系统看成“黑盒子”，识别出参与者和系统交互的系统事件，在系统（顺序图、状态图等）中进行描述，并进一步识别出系统操作，建立动态模型。 依据系统动态模型和对象模型，建立操作契约，描述响应系统操作执行后对系统状态的影响，从而回答“做什么“的问题。 对象模型类图 序列图 状态图 活动图 5 需求文档需求文档的作用作用： （1）规范的文档可以拓展人脑的知识记忆能力。（2）编制需求文档的过程，可以帮助需求工作人员更好的理解问题域，使文档表达的知识更准确、更清晰。（3）定义清晰、正确、规范的需求文档为开发人员、项目管理人员和软件用户提供相对稳定的可阅读资料。（4）通过编制需求文档，可以尽早发现需求错误，提高项目开发效率。（5）需求文档能够促进软件开发过程的规范化，也为开发团队建立了经验模型和可利用知识库。（6）需求文档可以作为项目开发方和软件客户之间的有关软件系统的协议基准，可以使用它作为合同协议的重要组成部分。使开发方和软件客户对系统目标达成一致。（7）需求文档还可以作为软件成本估算和项目开发进度安排的重要依据，从而使整个项目开发计划的制订更为合理。 原则： （1）在可能的情况下，需求文档应该由软件开发方和软件客户联合起草。（2）文档编写应适应文档的读者。（3）文档的表达方式依赖于内容。（4）文档编写应该有必要的重复（强化）。（5）文档编写应有一定灵活性。（详细程度上，可以扩展与合并，能对需求变更进行有效的管理和控制）（6）采用原型法，渐进式开发需求文档。 常见文档： 文档分类： 项目视图与范围文档（愿景和范围文档）包含了业务需求 用户需求通常形成用例文档 在得到用户需求之后，需求工程师需要对其进行建模和分析，细化为系统需求并建立能够满足系统需求的解决方案。 系统需求规格说明可细化为软件需求规格说明文档、硬件需求规格说明文档、接口需求规格说明文档及人机交互文档。 软件需求规格说明需求获取收集了需求信息，需求分析活动深入理解了需求信息并建立了能够满足用户需求的软件解决方案。需求规格说明（需求描述）是将需求获取、需求分析的结果进行文档化的过程。在软件开发过程中，将分析的结果文档化是不可或缺的任务，也称为编写规约活动。 主要活动： 首先寻找一个标准模版，然后根据模版的结构对模版进行选择与裁剪转变为需求规格说明文档模版。 然后将根据系统模型、系统需求和需求规格说明文档进行文档写作，然后形成软件需求规格说明文档。 各种写作风格： 自然语言：就是使用结构合理的自然语言来描述需求，该表示不管对于写的人还是看的人都是一个非常容易接受的方法。以前的项目很多都是采用此方法。优点：易于编写、易于阅读，不需要掌握特定的技巧；缺点：不够严谨，歧义性强，表达能力弱（特别是对于复杂问题的描述） 图形化模型：图形化模型在表述时能够给读者提供更强的视觉效果，同时能够使问题更加聚焦。在日常交流中，我们经常会绘制一些非标准的示意图，以便更好地进行沟通。优点：可视化、聚焦性，易于理解。缺点：编写和阅读的人都需要能够正确地理解模型，所以一般 SRS 不可能完全采用复杂模型。 形式化描述：如果说图形化模型比自然语言表达的精确度更高的话，则形式化描述比图形化模型更高一些。对于逻辑性很强，精度要求很高的场合，形式化规格描述是一种不错的选择。 优点：严谨、精确。缺点：编写和阅读的人都会感到很困难。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"/tags/软件工程/"},{"name":"需求分析","slug":"需求分析","permalink":"/tags/需求分析/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"云服务器中快速配置Oracle数据库","slug":"云服务器配置Oracle数据库","date":"2021-05-31T10:27:15.000Z","updated":"2024-03-02T16:13:04.775Z","comments":true,"path":"2021/05/31/云服务器配置Oracle数据库/","link":"","permalink":"/2021/05/31/云服务器配置Oracle数据库/","excerpt":"","text":"前言这个学期学了一门叫做高级数据库的课程，相信学过的都知道，基本上是在说 Oracle 数据库。而在这门课的实验中，就需要使用到 Oracle 数据库来进行一些实验。但是，问题出现在学校的课程安排和电脑配置上，这次的实验课只有三次，而我正好因为一些事耽误了一节，所以现在就需要我在自己的电脑上进行实验。但是，我没想到这才是问题的开始。 在上个学期，我更换了我的电脑，我从联想拯救者迁移到了 Mac mini m1，有一说一，macOS 用起来太爽了，太符合我胃口了。但是它也有很多不好的地方，比如 Oracle 不能在 MacOS 上运行，这也没什么，我们不是还有万能的 Docker 嘛，我记得在今年年初的时候，Docker 已经完成了对 m1 芯片的适配了，于是但我高高兴兴地打开 Docker 后，安装了 Oracle 数据库，结果在使用 sqlplus 登陆时一直显示ORA-12547: TNS:lost contact,我开始还以为是用户名或密码错了，结果上网一看，结果好像是说 m1 芯片现阶段不兼容…把我给整无语了。 最后想起我室友就是使用了阿里云的云服务器搭建了一个 Oracle，还能在学校的电脑上使用，这不是太方便了嘛，于是我想起了我以前在 vultr 存的几十块钱还没用呢，这不是正好可以用来租几个云服务器嘛。于是便开始了踩坑之旅…( ；´Д ｀) 在踩完坑后，发觉如果没有一些博客的指导，我肯定需要更长的时间。所以打算将这次的经历分享出来，反馈自己的经验，让更多人受益。 配置流程配置准备想要配置一个云服务器作为 Oracle 数据库，当然不是免费的，需要完成一下几项： 拥有一个云服务器(不管是国外的还是国外的，能用就行) 本地 ssh 连接工具(当然一般的云服务器在网页中也会有控制台，但是我觉得还是本地连接好用一点) 数据库连接工具 租借云服务器因为我使用的是 vultr 的服务，在此只指导如何在 vultr 中搭建。 点击图标中的按钮，可以查看自己的余额，要想租借一个服务器，需要余额在 5 美元以上。(可以使用支付宝，支付宝的英文为 Alipay) 然后进入 Products 页面，看到自己的服务器空空如也，是不是很伤心呢？没事，只要点击右边的小加号，就可以选择自己心仪的服务器啦～(´▽ ｀) 首先选择服务类型，选择 Cloud Compute 然后选择服务器的地区，我选择的是 Atlanta，这个根据你的位置可能网速有所差别。 然后选择服务器的系统，我们选择 CentOS 的 7x64 版本，我也没用过其他版本，怕出问题，在此唠叨一句。╮(╯▽╰)╭ 最后选择服务器的资源大小，一般选择 5 美金每月的就可以了，如果有更大的需求，可以考虑其他的。 全部选择好以后，就可以点击“Deploy Now”拥有自己的云服务器啦！ 连接云服务器相信有很多人和我一样，不知道如何使用云服务器。 我们可以打开“Products”，然后就可以看到自己正在运行的云服务器了，接下来只用点击状态，或者在扩展选项中查看详情，就可以进入服务器的详细页面。 在这个页面中，最重要的几个信息就是服务器的 IP 地址、用户名以及密码了。请妥善保管好。 然后就可以在自己的 ssh 工具中连接啦 在此放入我的示例： % ssh {这里是你的云服务器的用户名哦}@{这里是你的云服务的IP地址哦} root@155.138.207.121&#39;s password: Last failed login: Mon May 31 11:43:13 UTC 2021 from 91-115-102-148.adsl.highway.telekom.at on ssh:notty There were 1206 failed login attempts since the last successful login. Last login: Sun May 30 07:10:12 2021 from 117.152.144.111 [root@vultr ~]# 如果显示 “successful login”就代表连接成功啦。 [tips：第二行的 password 后输入是不会显示的，但是记得要输入密码才能进入云服务器哦～] 安装 Docker安装命令如下： curl -fsSL https://get.docker.com | bash -s docker --mirror aliyun 直接在连接后的云服务器中输入就好了 使用 docker 安装 oracle确定自己可以使用docker --version查看自己的 docker 版本，代表已经成功安装 docker 啦，一下我们来看看怎么使用 docker 安装 oracle。然后使用docker ps查看 docker 是否正在运行，如果没有运行，可以使用systemctl start docker来启动 docker 首先要知道带图形化带 oracle 是很大的，而我们需要安装的只不过是 oracle 内核，因此我们需要搜索docker-oracle-xe-11g是否有合适的 docker 版本。 因此我们可以使用 docker search 命令： [root@vultr ~]# docker search docker-oracle-xe-11g NAME DESCRIPTION STARS OFFICIAL AUTOMATED deepdiver/docker-oracle-xe-11g 40 [OK] epiclabs/docker-oracle-xe-11g Customized Oracle XE 11g build for CI and de… 19 [OK] pengbai/docker-oracle-xe-11g-r2 oracle xe 11g r2 with sql initdb and web con… 10 [OK] arahman/docker-oracle-xe-11g phusion/baseimage based spin off of alexei-l… 9 [OK] konnecteam/docker-oracle-xe-11g Fork of https://github.com/wnameless/docker-… 3 [OK] rafaelri/docker-oracle-xe-11g Fork from wnameless/docker-oracle-xe-11g 3 [OK] ignatov/docker-oracle-xe-11g Dockerfile of Oracle Database Express Editio… 3 [OK] gswteam/docker-oracle-xe-11g Oracle XE 11g 0 [OK] jeromefromcn/docker-oracle-xe-11g docker-oracle-xe-11g 0 [OK] nguoianphu/docker-oracle-xe-11g Oracle Express Edition 11g Release 2 on Ubun… 0 [OK] lynxsolutions/docker-oracle-xe-11g docker-oracle-xe-11g 0 [OK] zzzfree/docker-oracle-xe-11g docker-oracle-xe-11g 0 [OK] deadok22/docker-oracle-xe-11g docker-oracle-xe-11g 0 rdehuyss/docker-oracle-xe-11g Oracle Express 11g R2 on Ubuntu 14.04.2 LTS 0 [OK] dbanttari/docker-oracle-xe-11g Branch of wnameless/docker-oracle-xe-11g tha… 0 [OK] bizybot/docker-oracle-xe-11g wnameless/docker-oracle-xe-11g 0 [OK] xtechnologies/docker-oracle-xe-11g docker-oracle-xe-11g 0 [OK] cheyu0325/docker-oracle-xe-11g docker-oracle-xe-11g 0 kikicarbonell/docker-oracle-xe-11g Docker image of Oracle Database Express Edit… 0 [OK] ceagan/docker-oracle-xe-11g Modified version of wnameless/docker-oracle-… 0 [OK] zigac/docker-oracle-xe-11g Oracle xe 11g 0 [OK] demers/docker-oracle-xe-11g-spark Oracle XE 11g with Spark 0 dockerbolcom/docker-oracle-xe-11g Fork of https://github.com/wnameless/docker-… 0 [OK] gmartsenkov/docker-oracle-xe-11g oracle 0 [OK] demers/docker-oracle-xe-11g Docker Oracle 11g XE with Java 13 and Python… 0 可以看到有这么多的 oracle 版本，我选择的是epiclabs/docker-oracle-xe-11g，选择自己喜欢的就好。 然后使用docker pull epiclabs/docker-oracle-xe-11g命令拉取镜像到本地就好了(不得不说国外的服务器拉取资源太 TM 快了，这速度，得有 50MB/s 吧) 然后启动镜像为一个容器就成功了，命令如下： docker run -h &quot;oracle&quot; --name &quot;oracle&quot; -d -p 49160:22 -p 49161:1521 -p 49162:8080 epiclabsdocker-oracle-xe-11g 解释一个这个命令就是： docker run 表示运行一个镜像 -h “oracle” 表示将这个容器的 hostname 指定为 “oracle” –name “oracle” 表示制定这个容器的名称为 “oracle” -d 表示后台运行容器 -p 表示端口映射，格式为 {这个是主机端口}:{这个是容器端口}, 因为 oracle 默认端口为 1521，因此我们配置 49161:1521，表示主机端口号 49161 就可以访问到 oracle 的端口了。 最后面是 docker 要运行的容器名 最后使用命令docker ps可以查看正在运行的容器。如果显示 oracle 已经启动，表示成功了。 连接 Oracle 数据库在此只分享使用 IDEA 连接的截图，其他工具连接大同小异。 其中用户名和密码，可以在网络上查找 oracle 数据库的默认密码 连接后就可以愉快地操作数据库啦～(´▽ ｀)","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"/tags/Docker/"},{"name":"Oracle","slug":"Oracle","permalink":"/tags/Oracle/"},{"name":"云服务器","slug":"云服务器","permalink":"/tags/云服务器/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"实现算法(查找)","slug":"实现算法(查找)","date":"2021-05-16T08:04:15.000Z","updated":"2024-02-24T12:27:19.234Z","comments":true,"path":"2021/05/16/实现算法(查找)/","link":"","permalink":"/2021/05/16/实现算法(查找)/","excerpt":"","text":"查找的基本概念概念 查找 查找表 静态查找表 关键字 平均查找长度 顺序查找和折半查找顺序查找 优点: 对数据元素的存储没有要求. 缺点: 平均查找长度较长, 效率低. 有序时可以降低查找失败的平均查找长度. 折半查找（二分查找）def binary_search(arr: list, target): lo, hi = 0, len(arr) - 1 while lo &lt;= hi: mid = (lo + hi) // 2 if arr[mid] == target: return mid elif arr[mid] &gt; target: lo = mid + 1 else: hi = mid - 1 return -1 判定树 优点: 速度快. 缺点: 要求线性表具有随机存储的特性, 仅适合顺序存储结构, 不适合于链式存储. 分块查找（索引顺序查找） 块内元素可以无序, 但块之间是有序的. 顺序查找或折半查找所在的块, 然后在块内顺序查找. 若有 n 个元素, 构造成索引顺序查找, 则根据均值不等式, 每块 sqrt(n)个元素最佳. 若块间使用折半查找, 则是分得越小越好. 散列表散列表的概念 散列函数: 一个把査找表中的关键字映射成该关键字对应的地址的函数, 记为 Hash(key) = Addr 冲突: 散列函数可能会把两个或两个以上的不同关键字映射到同一地址, 需要尽量减少冲突; 另一方面, 冲突总是不可避免的, 需要好好设计处理冲突的方法. 同义词: 发生碰撞的不同关键字称为同义词. 散列表: 根据关键字而直接进行访问的数据结构. 散列函数的构造方法 散列函数的定义域必须包含全部需要存储的关键字,而值域的范围则依赖于散列表的大小或地址范围。 散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中,从而减少冲突的发生。 散列函数应尽量简单,能够在较短的时间内计算出任一关键字对应的散列地址。 直接定址法直接取某个线性函数值为散列地址, 散列函数为: H(key)=key 或 H(key)=a*key+b 适用: 关键字分布连续 优点: 计算简单, 不会产生冲突 缺点: 若关键字分布不均匀, 空位较多, 会造成存储空间的浪费 除留余数法假定散列表长为 m, 取一个不大于 m 但最接近或等于 m 的质数 p, 利用以下公式把关键字转换为散列地址. H(key) = key%p 关键: 选好 p, 使得每个关键字通过该函数转换后等概率地映射到散射空间上的任一地址 , 从而减少冲突的可能性. 数字分析法设关键字是 r 进制数(如十进制数), 而 r 个数码在各位上出现的频率不一定相同, 可能在某些位上分布均匀一些, 每种数码出现的机会均等; 而在某些位上分布不均匀, 只有某几种数码经常出现, 此时应选取数码分布较为均匀的若干位作为散列地址。 适用: 已知的关键字集合, 若更换了关键字, 则需要重新构造新的散列函数。 平凡取中法顾名思义, 这种方法取关键字的平方值的中间几位作为散列地址. 具体取多少位要视实际情况而定。 适用: 关键字的每位取值都不够均匀或均小于散列地址所需的位数. 优点: 散列地址与关键字的每位都有关系, 因此使得散列地址分布比较均匀. 处理冲突的方法开放定址法所谓开放定址法, 是指可存放新表项的空闲地址既向它的同义词表项开放, 又向它的非同义词表项开放. 其数学递推公式为: Hi = (H(key)+di)%m 线性探测法 平凡探测法 再散列法 伪随机序列法 拉链法显然, 对于不同的关键字可能会通过散列函数映射到同地址, 为了避免非同义词发生冲突, 可以把所有的同义词存储在一个线性链表中, 这个线性链表由其散列地址唯一标识。假设散列地址为的同义词链表的头指针存放在散列表的第 i 个单元中, 因而查找、插入和删除操作主要在同义词链中进行。拉链法适用于经常进行插入和删除的情况. 散列查找性能分析 检测査找表中地址为 Addr 的位置上是否有记录, 若无记录, 返回查找失败; 若有记录, 比较它与 key 的值, 若相等, 则返回查找成功标志, 否则执行步骤 2. 用给定的处理冲突方法计算“下一个散列地址”, 并把 Addr 置为此地址, 转入步骤 1. 虽然散列表在关键字与记录的存储位置之间建立了直接映像, 但由于“冲突”的产生, 使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此, 仍需要以平均查找长度作为衡量散列表的査找效率的度量. 散列表的査找效率取决于三个因素: 散列函数、处理冲突的方法和装填因子. 装填因子. 散列表的装填因子一般记为 z, 定义为一个表的装满程度 a = 表中记录数n/散列表长度m","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"算法","slug":"算法","permalink":"/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"实现算法(排序)","slug":"实现算法(排序)","date":"2021-05-14T07:04:15.000Z","updated":"2024-03-02T16:13:05.001Z","comments":true,"path":"2021/05/14/实现算法(排序)/","link":"","permalink":"/2021/05/14/实现算法(排序)/","excerpt":"","text":"简单排序算法直接插入排序时间: O(n**2) 空间: O(1) 稳定: True 直接插入排序是从头到尾遍历一遍序列, 每次将当前元素插入到前方到已经排列好到序列中 . 具体插入方法是,从后向前遍历排序好到序列, 如果待排元素和当前元素符合条件, 则交换位置. 如果不符合, 说明已经排列成功,待排点就插入完毕. def insert_sort(arr, func=lambda x, y: x &lt; y): length = len(arr) if length &lt;= 1: return for i in range(1, len(arr)): tem = arr[i] for j in range(i - 1, -1, -1): if func(tem, arr[j]): arr[j + 1], arr[j] = arr[j], tem else: break return arr 选择排序时间: O(n**2) 空间: O(1) 稳定: False 选择排序是从头到尾遍历一遍序列, 每次选择最左侧未排序的下标作为待选择下标, 然后在未排序的序列中找到一个最符合条件的元素, 然后交换到待选择下标中. def select_sort(arr, func=lambda x, y: x &lt; y): length = len(arr) for i in range(length): min_index = i for j in range(i + 1, length): if func(arr[j], arr[min_index]): min_index = j arr[i], arr[min_index] = arr[min_index], arr[i] return arr 冒泡排序时间: O(n**2) 空间: O(1) 稳定: True 冒泡排序是每次比较下标相邻的元素, 然后逐步向后遍历. 每次可以将最大的那个数放置到未排序序列的末尾, 因此最多需要循环 n 次. 但是在每次冒泡过程中, 也将其他元素进行了排序. 所以可以通过一个变量来监测当前循环中有无变化. 如果没有变化, 就不用继续进入下一个循环了. def buble_sort(arr, func=lambda x, y: x &lt; y): length = len(arr) for i in range(length - 1, -1, -1): has_change = False for j in range(1, i + 1): if func(arr[j], arr[j - 1]): arr[j], arr[j - 1] = arr[j - 1], arr[j] has_change = True if not has_change: break return arr 复杂排序算法希尔排序时间: O(n*[log(n)]**2) 空间: O(1) 稳定: False 希尔排序是直接插入排序的进阶版, 它由多个(一般为 log[len(arr)])直接插入排序构成. 在每次直接插入排序中, 原本只是比较相邻的两个数, 但在希尔排序中, 每次会比较步长个间距的两个数. 希尔排序之所以比直接插入排序更加高效, 可以通过一个例子来认识: arr= [321565, 56540, 132, 1651, 132,1651, 1], 要想将这个序列排序为从小到大. 直接插入排序在加入 ‘1’ 这个元素时, 需要将这个元素一步一步地向前移动, 直到到达最左侧. 这样涉及到了 len(arr) 次的元素交换. 但在希尔排序中, 由于每次可以跨越一个步长个单位 . 因此只需要移动 log[len(arr)] 个单位. 因此希尔排序比直接插入排序更高效一些. def shell_sort(arr, func=lambda x, y: x &lt; y): length = len(arr) path_l = length // 2 while path_l &gt; 0: for i in range(path_l, length): idx = arr[i] j = i - path_l while j &gt;= 0 and func(idx, arr[j]): arr[j + path_l] = arr[j] j -= path_l else: arr[j + path_l] = idx path_l //= 2 return arr 堆排序时间: O(n*[log(n)]**2) 空间: O(1) 稳定: False 堆排序是使用一个名为堆的结构, 这个结构类似于一个完全二叉树. 因此可以使用一个顺序结构存储每个节点. 对于每一个节点, 如果它有子节点, 则左子节点为 2*idx+1 右子节点为 2*idx+2. 且对于大顶堆来说, 父节点一定大于等于子节点. 那么如何使用堆来进行排序呢, 首先我们可以将一个数组大顶堆化, 然后依次取出第一个节点值依次放入堆的尾端, 然后再维护堆的稳定就可以了(调整时需要忽略尾端已经排序好的序列). 以下是维护堆的代码. 我们设置这样的一个函数 heap_fit(target_idx, size) 其中 target_idx 表示目前需要调整的元素下标, size 表示堆的最大下标. 循环中, 每次都比较 target_idx 的左右节点是否大于 arr[target_idx]. 如果大于, 则用子节点的值更新 target_idx 位置. 并将子节点设置为父节点, 再次比较. 如果不大于或左子节点的下标超过最大范围, 则退出循环 将目前父节点的值更新为最初 target_idx 的值 def heap_sort(arr, func=lambda x, y: x &lt; y): length = len(arr) def heap_fit(target_idx: int, size: int): idx_i, idx_j = target_idx, 2 * target_idx + 1 index_val = arr[idx_i] while idx_j &lt;= size: if idx_j &lt; size and func(arr[idx_j], arr[idx_j + 1]): idx_j += 1 if func(index_val, arr[idx_j]): arr[idx_i] = arr[idx_j] idx_i, idx_j = idx_j, 2 * idx_j + 1 else: break arr[idx_i] = index_val for i in range(length // 2 - 1, -1, -1): heap_fit(i, length - 1) for i in range(length - 1, -1, -1): arr[i], arr[0] = arr[0], arr[i] heap_fit(0, i - 1) return arr 归并排序时间: O(n*[log(n)]**2) 空间: O(n) 稳定: True 归并排序使用了分治思想来进行排序, 首先将元素一一分为一个单独的序列, 然后两两组合起来. 只不过在组合起来的时候保持组合后的序列也是一个有序序列. def merge_sort(arr, le=None, ri=None, func=lambda x, y: x &lt; y): def merge(lo: int, mi: int, hi: int): lo_length = mi - lo hi_length = hi - mi lo_list = arr[lo: mi] hi_list = arr[mi:hi] i, j, k = 0, 0, lo while i != lo_length and j != hi_length: if func(lo_list[i], hi_list[j]): arr[k], i = lo_list[i], i + 1 else: arr[k], j = hi_list[j], j + 1 k += 1 while i != lo_length: arr[k] = lo_list[i] i, k = i + 1, k + 1 while j != hi_length: arr[k], j, k = hi_list[j], j + 1, k + 1 if (le and ri) is None: le, ri = 0, len(arr) if le &lt; ri: mid = (le + ri) // 2 merge_sort(arr, le, mid) merge_sort(arr, mid + 1, ri) merge(le, mid, ri) return arr 快速排序时间: O(n*[log(n)]**2) 空间: O(log(n)) 稳定: False 不多做介绍, 这个相信程序员都知道. def quick_sort(arr, lo=None, hi=None, func=lambda x, y: x &lt; y): if (lo and hi) is None: lo, hi = 0, len(arr) - 1 if lo &gt;= hi: return arr left, right = lo, hi key = arr[lo] while lo &lt; hi: while lo &lt; hi and func(key, arr[hi]): hi -= 1 arr[lo] = arr[hi] while lo &lt; hi and not func(key, arr[lo]): lo += 1 arr[hi] = arr[lo] arr[hi] = key quick_sort(arr, left, lo - 1) quick_sort(arr, lo + 1, right) return arr 基数排序时间: O(n*log(n)) 空间: O(log[max(arr)]) 稳定: True 基数排序是用一个一个桶对序列中每个数字进行分类, 从个位开始分类. 将序列一次输出, 直到最高位分类完成.此时其他位置上对数也完成了排序. def radix_sort(arr): max_num = max(arr) max_index = len(str(max_num)) for i in range(max_index): bucket_list = [[] for _ in range(10)] for x in arr: bucket_list[int(x / (10 ** i)) % 10].append(x) arr.clear() for bucket in bucket_list: for item in bucket: arr.append(item) i += 1 return arr 外部排序算法外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序 整个文件的目的。 外部排序最常用的算法是多路归并排序，即将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行多路归并排序。 以下是对基础的多路归并排序算法的优化算法. 置换-选择排序置换-选择排序算法是用来帮助归并排序分割归并段的算法. 以下是它的工作原理: 从待排文件 FI 输入 W 个记录到工作区 WA. 从内存工作区 WA 中选出其中关键字最小的记录，记为 MINIMAX.(以后再选出关键字比它大的记录纳入本归并段，比它小的归入下一归并段) 将 MINIMAX 记录输出到 FO 中去。 若 FI 未读完，则从 FI 输入下一个记录到 WA 中。 从 WA 中所有关键字比 MINIMAX 记录的关键字大的记录中选出最小的关键字记录，作为新的 MINIMAX。 重复 3）~5）直到在 WA 中选不出新的 MINMAX 记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到 FO 中去。 重复 2）~6）直到 WA 为空，由此得到全部初始归并段。 最佳归并树类似于哈夫曼树的构建原理, 用来构建最佳 I/O 操作的归并树. 败者树败者树","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"算法","slug":"算法","permalink":"/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"实现常用数据结构(图)——图的算法","slug":"实现数据结构(图)——图的算法","date":"2021-05-12T06:04:15.000Z","updated":"2024-03-02T16:13:04.136Z","comments":true,"path":"2021/05/12/实现数据结构(图)——图的算法/","link":"","permalink":"/2021/05/12/实现数据结构(图)——图的算法/","excerpt":"","text":"最小生成树图的生成树是包含图的所有点和部分边的一个图, 它是图的一个子集. 之所以叫树, 是因为生成树中没有环. 最小生成树是生成树中权值最小的一棵树. Prim 算法由一个顶点开始, 每次选择与已有点顶点相连但不指向已有顶点但最小边, 然后将边和指向的订单并入到树中. 直到没有可以选择的边为止. 以下是 Python 代码: [Note]: 由于此算法对存储结构无要求, 故抽象化了一个数据结构来保存当前对图. 以下代码中使用了函数 get_lines(node) , 它是一个生成器函数, 生成器每次返回 node 引申出的路径权值和目标节点. def prim(target) -&gt; int: low_cost = [float(&#39;inf&#39;)] * target.size # 可以到达每个顶点的最小路径长度, 初始为无穷大 v = set() # 顶点集合, 每添加一个顶点就加入其中 v.add(0) # 从0号顶点开始生成树 res = 0 # 最小生成树的权值 for line_cost, target_node in target.get_lines(0): # 查找有关0顶点的所有边, 获得路径长度和目标节点 if low_cost[target_node] &gt; line_cost: # 如果能够获得更短的路径, 就更新 low_cost low_cost[target_node] = line_cost for _ in range(target.size - 1): # 由于0号节点已经在集合中, 所以遍历次数少一次 min_line, min_node = float(&#39;inf&#39;), 0 for i, cost in enumerate(low_cost): if cost &lt; min_line: min_line, min_node = cost, i v.add(min_node) # 将当前边最小的目标顶点加入顶点集合中 res += min_line # 生成树的权值更新 low_cost[min_node] = float(&#39;inf&#39;) # 将加入顶点集合的顶点的low_cost更新为无穷大 for line_cost, target_node in target.find(min_node): # 根据加入的顶点有关的边更新low_cost if target_node not in v and low_cost[target_node] &gt; line_cost: low_cost[target_node] = line_cost return res Kruskal 算法依次按大小将所有的边并入到集合中, 如果形成了环则跳过当前边, 直到所有点都并入到并入到树中为止. 要判断是否形成了环只需要引入并查集, 如果一条边的两个点属于同一个集合, 则会形成环 . 并查集的代码不多做赘述, 具体请看 并查集 以下是 Python 代码: [Note]: 由于此算法对存储结构无要求, 故抽象化了一个数据结构来保存当前对图. 以下代码中使用了函数 target.all_lines(), 它返回了一个 字典列表 , 列表中每个元素分别为: pre_node, target_node, cost, 其中分别表示了起始点, 终点和路径长度. def kruskal(target) -&gt; int: uf = UnionFind(range(target.size)) v = set() res = 0 line_list = sorted(target.all_lines(), key=lambda x: x[cost]) for node1, node2, line_cost in line_list: if len(v) == target.size: break if not uf.union(node1, node2): res += line_cost v.add(node1) v.add(node2) return res 最短路径Dijkstra 算法Dijkstra 算法是用来求得某一点到图中所有点的最点距离的算法, 其与 Prim 算法有相似之处, 都是寻找可以到达的边, 然后用一个数组记录其最小值. 只不过 Dijkstra 算法在每次取最小值时, 记录的值都是起始点到当前点的距离. 以下是 Python 代码: [Note]: 由于此算法对存储结构无要求, 故抽象化了一个数据结构来保存当前对图. 以下代码中使用了函数 get_lines(node) , 它是一个生成器函数, 生成器每次返回 node 引申出的路径权值和目标节点. def dijkstra(target_map: Map, node: int): point_dict = {node: 0} # 表示起始点到目标点的最小路径长度 pre_node = {node: node} # 记录路径中的前驱 v = {node} # 记录节点是否已经有了最短路径 for line_node, line_cost in target_map.get_lines(node): # 先将起始点能直接遍历到的点记入dict中 point_dict[line_node] = line_cost pre_node[line_node] = node for _ in range(target_map.size - 1): cost, min_node = float(&#39;inf&#39;), None # 寻找当前最小路径的点 for index_node in point_dict: if index_node not in v and cost &gt; point_dict[index_node]: cost = point_dict[index_node] min_node = index_node v.add(min_node) for line_node, line_cost in target_map.get_lines(min_node): # 更新dict if line_node not in point_dict or point_dict[line_node] &gt; line_cost + cost: point_dict[line_node] = line_cost + cost pre_node[line_node] = min_node return format_res(point_dict, pre_node) def format_res(cost, pre): res_dict = {} for node in cost: res_dict[node] = {&#39;cost&#39;: cost[node]} path = [str(node)] idx = node while pre[idx] != idx: idx = pre[idx] path.append(str(idx)) res_dict[node][&#39;path&#39;] = &#39;-&gt;&#39;.join(path[::-1]) return res_dict Floyd 算法Floyd 算法就是不断查找在两条路径之间是否有更短的路径, 然后更新一个二维数组的过程的算法. 以下是 Python 代码: [Note]: 由于此算法对存储结构无要求, 故抽象化了一个数据结构来保存当前对图. 以下代码中使用了函数 get_cost(i, j) , 它返回了两个点之间的边的长度, 如果两点之间没有边 , 则返回无穷大. def floyd(target_map) -&gt; (dict, dict): _dict = {i: {} for i in range(target_map.size)} path = {i: {} for i in range(target_map.size)} for i in range(target_map.size): for j in range(target_map.size): if i == j: _dict[i][j] = 0 else: _dict[i][j] = target_map.get_cost(i, j) for v in range(target_map.size): for i in range(target_map.size): for j in range(target_map.size): if i != v and j != v and i != j and _dict[i][j] &gt; _dict[i][v] + _dict[v][j]: _dict[i][j] = _dict[i][v] + _dict[v][j] path[i][j] = v return _dict, path","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"数据结构——线段树(Python 实现)","slug":"线段树","date":"2021-05-09T07:30:15.000Z","updated":"2024-03-02T16:13:04.022Z","comments":true,"path":"2021/05/09/线段树/","link":"","permalink":"/2021/05/09/线段树/","excerpt":"","text":"线段树前言记得大一的时候耶学习过线段树, 当时这是我唯一认真学习过的数据结构, 至于什么 AVL、红黑树. 当时基本上要么是没看, 要么就是知难而退了, 唯独线段树自己认真啃完了大牛的博客, 也自己用 C++实现过了一遍. 但是应该怎么也没料到, 自己会在大三的一次学校组织的 ACM 竞赛中被线段树绊住了脚. 这次就来认真学习一遍线段树, 争取下次需要用到的时候能够胸有成竹. 题目查询数组某个区间的最大值、并在每次查询后更新单个值. 线段树详解 什么是线段树 线段树所记录的是数组（一般是数组）区间内的信息，比如区间内的元素求和、连乘之类的。比如树中的根节点就记录了数组 A 中从索引 0 到索引 9 的元素信息，比如求和、求区间最大值。线段树的叶子节点只有一个元素。但不是完全二叉树，是一棵平衡二叉树（树的最大深度至多比最小深度多 1）。但是一般的，我们认为线段树是一棵满二叉树（为了能像堆那样用索引来表示左、右孩子，只不过堆不一定是满二叉树），只需在不存在元素的地方用 None 填充就好了。线段树一般是以中点索引来分割左、右子树的。 为什么要使用线段树 对于需要频繁查询数组区间的区间值、并且需要频繁修改数组的值的情况下. 就需要使用到线段树, 因为线段树采用了空间换取时间的思想, 每次查询和每次修改后维护的时间复杂度都只是 log(n) 级别, 更为高效. 使用线段树的限制 线段树无法处理数组元素的添加或者删除操作, 只支持空间内的元素值的修改. 线段树的思想线段树的基础思想就是通过额外的多个空间来记录数组的小段区间值, 并在数组修改后能够自底向上进行修改所有需要修改的区间、而不需要修改的区间就不会被访问, 因此修改的复杂度减小了许多. Python 实现from typing import List class SegmentTree: def __init__(self, alist: List[int], merger_): &quot;&quot;&quot;初始化线段树 Args: alist (List[int]): 初始化时传入的一个list，为需要进行区间索引的数组 merger_ (function): merge函数，用于对实现两个数合成一个数对功能 &quot;&quot;&quot; self.data = alist self.size = len(self.data) self.tree = [-float(&#39;inf&#39;)] * 4 * len(self.data) self.merger = merger_ self._buildSegmentTree(0, 0, len(self.data) - 1) def _buildSegmentTree(self, treeIndex: int, left: int, right: int): &quot;&quot;&quot;构建线段树，通过递归构建线段树 Args: treeIndex (int): 当前根节点的索引 left (int): 当前根节点的左边界 right (int): 当前根节点的右边界 &quot;&quot;&quot; if left == right: self.tree[treeIndex] = self.data[left] return leftChild_index = 2 * treeIndex + 1 rightChild_index = 2 * treeIndex + 2 mid = (left + right) // 2 self._buildSegmentTree(leftChild_index, left, mid) self._buildSegmentTree(rightChild_index, mid + 1, right) self.tree[treeIndex] = self.merger( self.tree[leftChild_index], self.tree[rightChild_index]) def quary(self, left: int, right: int) -&gt; int: &quot;&quot;&quot;接口函数，用于查询区间值 Args: left (int): 区间左边界 right (int): 区间右边界 Raises: Exception: 数组索引越界 Returns: int: 返回区间值 &quot;&quot;&quot; if 0 &lt;= left &lt; self.size and 0 &lt;= right &lt; self.size: return self._find(0, 0, self.size, left, right) else: raise Exception(&#39;The indexes is illegal!&#39;) def _find(self, treeIndex: int, left: int, right: int, quaryL: int, quaryR: int): &quot;&quot;&quot;非接口函数，递归查询区间值 Args: treeIndex (int): 当前根节点索引 left (int): 当前根节点左边界 right (int): 当前根节点右边界 quaryL (int): 查询区间左边界 quaryR (int): 查询区间右边界 Returns: [type]: 返回区间值 &quot;&quot;&quot; if left == quaryL and right == quaryR: return self.tree[treeIndex] mid = (left + right) // 2 leftChild_index = 2 * treeIndex + 1 rightChild_index = 2 * treeIndex + 2 if quaryL &gt; mid: return self._find(rightChild_index, mid + 1, right, quaryL, quaryR) elif quaryR &lt;= mid: return self._find(leftChild_index, left, mid, quaryL, quaryR) leftResult = self._find(leftChild_index, left, mid, quaryL, mid) rightResult = self._find( rightChild_index, mid + 1, right, mid + 1, quaryR) return self.merger(leftResult, rightResult) def update(self, index: int, value): &quot;&quot;&quot;接口函数，单点更新 Args: index (int): 更新点的位置 value (any): 更新的值 Raises: Exception: 数组索引越界 &quot;&quot;&quot; if 0 &lt;= index &lt; self.size: self.data[index] = value self._maintain(0, 0, self.size - 1, index, value) else: raise Exception(&#39;The index is illegal!&#39;) def _maintain(self, treeIndex: int, left: int, right: int, index: int, value): &quot;&quot;&quot;非接口函数，递归维护所有包含区间的值 Args: treeIndex (int): 当前根节点的索引 left (int): 当前根节点左边界 right (int): 当前根节点右边界 index (int): 更新点的位置 value (any): 更新的值 &quot;&quot;&quot; if left == right: self.tree[treeIndex] = value return mid = (left + right) // 2 leftChild_index = 2 * treeIndex + 1 rightChild_index = 2 * treeIndex + 2 if index &lt;= mid: self._maintain(leftChild_index, left, mid, index, value) else: self._maintain(rightChild_index, mid + 1, right, index, value) self.tree[treeIndex] = self.merger( self.tree[leftChild_index], self.tree[rightChild_index])","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"实现常用数据结构(图)——遍历","slug":"实现数据结构(图)——遍历","date":"2021-05-08T08:42:15.000Z","updated":"2024-03-02T16:13:05.014Z","comments":true,"path":"2021/05/08/实现数据结构(图)——遍历/","link":"","permalink":"/2021/05/08/实现数据结构(图)——遍历/","excerpt":"","text":"图的遍历可以分为深度优先遍历(dfs) 和 宽度优先遍历(bfs) 由于图可能会有回路, 因此在遍历过程中可能会存在多次遍历同一个点的情况, 因此在深度优先遍历时, 可以使用一个 mark 集合标记当前节点是否访问过. DFS在进行深度优先遍历时, 会将当前路径走到尽头再返回去搜索其他路径, 走到尽头的含义是没有下一个未访问的点. 因此我们一般使用函数的递归调用或使用栈数据结构来保存每次的状态. 由于使用哪种存储形式和遍历的写法没有太大区别, 只是取出下一条路径的方式有些许不同 , 在此仅使用 Python 代码演示遍历过程, 取出下一个节点的过程使用函数 getNextNodes(self, node:Node)-&gt;List[Node] 以下是递归版本: def DFS(self, node: Node): # 访问当前节点 visit(node) self.mark[node] = True nextNodes = self.getNextNodes(node) for nextNode in nextNodes: # 如果不不在集合中, 说明未访问过 if nextNode not in self.mark: DFS(nextNode) 以下是非递归版本: def DFS(self, node: Node): stack = [] stack.append(node) while len(stack) != 0: # 访问当前节点 indexNode = stack.pop() visit(indexNode) self.mark[node] = True nextNodes = self.getNextNodes(indexNode) for nextNode in nextNodes: # 如果不不在集合中, 说明未访问过 if nextNode not in self.mark: stack.append(nextNode) BFS在进行宽度优先遍历时, 会将当前节点的所有下一个节点遍历完后, 再走到下一层的节点. 因此我们一般使用队列数据结构来保存每次的状态. 由于使用哪种存储形式和遍历的写法没有太大区别, 只是取出下一条路径的方式有些许不同 , 在此仅使用 Python 代码演示遍历过程, 取出下一个节点的过程使用函数 getNextNodes(self, node:Node)-&gt;List[Node] 由于使用 Python 自身的 list 来模拟队列要么时间浪费, 要么空间浪费. 于是我使用了 collections 的 deque 高效队列来实现. from collections import deque def BFS(self, node: Node): queue = deque() queue.appendleft(node) while len(queue) != 0: # 访问当前节点 indexNode = queue.pop() visit(indexNode) self.mark[node] = True nextNodes = self.getNextNodes(indexNode) for nextNode in nextNodes: # 如果不不在集合中, 说明未访问过 if nextNode not in self.mark: queue.appendleft(nextNode)","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"记录一个进阶版迷宫题","slug":"进阶版迷宫题","date":"2021-05-08T02:08:15.000Z","updated":"2024-03-02T16:13:05.026Z","comments":true,"path":"2021/05/08/进阶版迷宫题/","link":"","permalink":"/2021/05/08/进阶版迷宫题/","excerpt":"","text":"题目概述给一个 n * m 的迷宫, 其中有 q 对传送阵, 没传送一次需要耗时 3 个单位 , 求起点到终点对最短路径. 思路这道题和普通的迷宫题有些许不同之处, 主要在于存在传送阵. 传送阵可能会导致存在一些点 可能多次遍历到 并且可能 下次遍历时路径更短 所以使用一个 mark 数组记录路径长度(从起点到当前点的路径长度) 然后在遍历过程中维护这个数组. 具体维护思路如下: mark 数组默认全为 无穷大 float(&#39;inf&#39;) 找到起始点后将起始点的 mark 值标为 0 每当遍历到一个点后, 判断当前路径长度是否大于 mark 数组中的值 如果大于, 则遍历当前点能够到达的点 如果小于, 则仅仅将当前点踢出队列 需要注意的是, 由于不能保证终点在第一次遍历到时路径最小, 所以需要等到队列为空时才可以结束循环. 代码from collections import deque n, m, q = [int(item) for item in input().split(&#39; &#39;)] graph = [] for _ in range(n): graph.append(list(input())) # 标记数组默认值为无穷大，使得所有第一次到达的点都可以刷新标记数组 mark = [[float(&#39;inf&#39;) for _ in range(m)] for _ in range(n)] def check(a: int, b: int) -&gt; bool: if 0 &lt;= a &lt; n and 0 &lt;= b &lt; m and graph[a][b] != &#39;#&#39;: return True return False # 使用字典(入口 -&gt; 出口列表) 记录传送门 te = {} for _ in range(q): x1, y1, x2, y2 = [int(item) for item in input().split(&#39; &#39;)] if (x1, y1) not in te: te[(x1, y1)] = [] if (x2, y2) not in te: te[(x2, y2)] = [] te[(x1, y1)].append((x2, y2)) te[(x2, y2)].append((x1, y1)) # 使用队列记录bfs搜索的状态 de = deque() path = [[1, 0], [-1, 0], [0, 1], [0, -1]] endX, endY = 0, 0 for i in range(n): for j in range(m): if graph[i][j] == &#39;S&#39;: de.appendleft([i, j, 0]) if graph[i][j] == &#39;T&#39;: endX, endY = i, j while len(de) != 0: # 取出队列最后的数据 x, y, index = de[-1] # 判断是否走过，若走过，则判断当前路径是否更短，更短则搜索当前点 if index &lt; mark[x][y]: mark[x][y] = index # 再判断是否可以传送 if (x, y) in te: for nextX, nextY in te[(x, y)]: if check(nextX, nextY): de.appendleft([nextX, nextY, index + 3]) # 再将周围可以进入的点加入队列中 for nextX, nextY in [[x + pathX, y + pathY] for pathX, pathY in path]: if check(nextX, nextY): de.appendleft([nextX, nextY, index + 1]) # 最后删除队列中的元素 de.pop() if mark[endX][endY] != float(&#39;inf&#39;): print(mark[endX][endY]) else: print(-1) 总结在写这种需要考虑的事情比较多的题目时, 可以尝试先编写注释, 然后再编写代码. 这样能够有效防止遗漏情况,也便于出现 debug.","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"BFS","slug":"BFS","permalink":"/tags/BFS/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"实现常用数据结构(总结)","slug":"实现数据结构(总结)","date":"2021-04-26T02:14:15.000Z","updated":"2024-03-02T16:13:04.055Z","comments":true,"path":"2021/04/26/实现数据结构(总结)/","link":"","permalink":"/2021/04/26/实现数据结构(总结)/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"golang","slug":"golang","permalink":"/tags/golang/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"实现常用数据结构(图)——图的基础概念","slug":"实现数据结构(图)——基础概念","date":"2021-04-25T13:14:15.000Z","updated":"2024-03-02T16:13:04.055Z","comments":true,"path":"2021/04/25/实现数据结构(图)——基础概念/","link":"","permalink":"/2021/04/25/实现数据结构(图)——基础概念/","excerpt":"","text":"图的逻辑结构1) 有向图和无向图 有向图: 若 E 是有向边(也称弧)的有限集合时，则图 G 为有向图。弧是顶点的有序对，记为&lt;v, w&gt;，其中 v,w 是顶点，v 称为弧尾，w 称为弧头，&lt;v, w&gt;称为从 v 到 w 的弧，也称 v 邻接到 w。 无向图: 若 E 是无向边(简称边)的有限集合时，则图 G 为无向图。边是顶点的无序对，记为(v, w)或(w,v)。可以说 w 和 v 互为邻接点。边(v, w)依附于 w 和 v,或称边(v, w)和 v, w 相关联。 2) 简单图和多重图 一个图 G 如果满足:① 不存在重复边; ② 不存在顶点到自身的边，那么称图 G 为简单图。 若图 G 中某两个顶点之间的边数大于 1 条，又允许顶点通过一条边和自身关联，则称图 G 为多重图。 3) 完全图 对于无向图，|E|的取值范围为 0 到 n(n -1)/2,有 n(n - 1)/2 条边的无向图称为完全图，在完全图中任意两个顶点之间都存在边。 对于有向图，E1 的取值范围为 0 到 n(n-1),有 n(n -1)条弧的有向图称为有向完全图，在有向完全图中任意两个顶点之间都存在方向相反的两条弧。 4) 子图 设有两个图 G=(V, E)和 G’=(V’,E’)，若 V’是 V 的子集，且 E’是 E 的子集，则称 G’是 G 的子图。若有满足 V(G’)= V(G)的子图 G’，则称其为 G 的生成子图。 5) 连通、连通图和连通分量 在无向图中，若从顶点 v 到顶点 w 有路径存在，则称 v 和 w 是连通的。若图 G 中任意两个顶点都是连通的，则称图 G 为连通图，否则称为非连通图。无向图中的极大连通子图称为连通分量。 6) 强连通图和强连通分量 在有向图中，如果有一对顶点 v 和 w，从 v 到 w 和从 w 到 v 之间都有路径，则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连通子图称为有向图的强连通分量。 7) 生成图、生成森林 连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为 n,则它的生成树含有 n-1 条边。包含图中全部顶点的极小连通子图，只有生成树满足这个极小条件，对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。 在非连通图中，连通分量的生成树构成了非连通图的生成森林。 8) 度、入度和出度 在无向图中，顶点 v 的度是指依附于顶点 v 的边的条数，记为 TD(v)。 在有向图中，顶点 v 的度分为入度和出度, 入度是以顶点 v 为终点的有向边的数目,记为 ID(v);而出度是以顶点 v 为起点的有向边的数目，记为 OD(v)。 9) 边的权和网 在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。这种边上带有权值的图称为带权图，也称网。 10) 稠密图和习俗图 边数很少的图称为稀疏图，反之称为稠密图。稀疏和稠密本身是模糊的概念，稀疏图和稠密图常常是相对而言的。一般当图 G 满足|E| &lt; |V|*log|V|时，可以将 G 视为稀疏图。 11) 路径、路径长度和回路 顶点 Vp 到顶点 Vq，之间的一条路径是指顶点序列 Vp, Vi1, Vi2, Vi3,…, Vim, Vq，当然关联的边也可理解为路径的构成要素。路径上边的数目称为路径长度。第一个顶点和最后一个顶点相同的路径称为回路或环。若一个图有 n 个顶点，并且有大于 n-1 条边，则此图一定有环。 12) 简单路径和简单回路 在路径序列中，顶点不重复出现的路径称为简单路径。除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。 13) 距离 从顶点 u 出发到顶点 v 的最短路径若存在，则此路径的长度称为从 u 到 v 的距离。若从 u 到 v 根本不存在路径，则记该距离为无穷(∞)。 14) 有向树 一个顶点的入度为 0、其余顶点的入度均为 1 的有向图，称为有向树。 图的存储结构图一般用一下几种方法进行存储. 邻接矩阵法 所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息(即各顶点之间的邻接关系)，存储顶点之间邻接关系的二维数组称为邻接矩阵。 type Map struct { NodeSize int data [][]int } func InitMap(n int) *Map { var data [][]int for i := 0; i &lt; n; i++ { data = append(data, []int{}) for j := 0; j &lt; n; j++ { data[i] = append(data[i], math.MaxInt32) } } return &amp;Map{ NodeSize: n, data: data, } } 邻接表和逆邻接表 所谓邻接表，是指对图 G 中的每个顶点 Vi 建立一个单链表, 第 i 个单链表中的结点表示依附于顶点 Vi 的边(对于有向图则是以顶点 Vi 为尾的弧)，这个单链表就称为顶点 Vi 的边表(对于有向图则称为出边表)。边表的头指针和顶点的数据信息采用顺序存储 (称为顶点表), 所以在邻接表中存在两种结点: 顶点表结点和边表结点。 // VNode 边表结构 type VNode struct { cIdx int next *VNode } // ArcNode 点结构 type ArcNode struct { data int first *VNode } // Map 图结构 type Map struct { NodeSize int LineSize int nodeList []ArcNode } func InitMap(n int) *Map { var l []ArcNode for i := 0; i &lt; n; i++ { l = append(l, ArcNode{ data: i, first: nil, }) } return &amp;Map{ NodeSize: n, LineSize: 0, nodeList: l, } } 十字链表法 十字链表是有向图的一种链式存储结构。在十字链表中,对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点。这些结点的结构如下图所示。 弧结点中有 5 个域: 尾域(tailvex)和头域(headvex)分别指示弧尾和弧头这两个顶点在图中的位置; 链域 nextIn 指向弧头相同的下一条弧;链域 nextOut 指向弧尾相同的下一条弧。这样，弧头相同的弧就在同一个链表上，弧尾相同的弧也在同一个链表上。 // VNode 弧结构 type VNode struct { start int end int nextIn *VNode nextOut *VNode } // ArcNode 点结构 type ArcNode struct { data int firstIn *VNode firstOut *VNode } // Map 图结构 type Map struct { LineSize int NodeSize int NodeList []ArcNode } func InitMap(n int) *Map { var l []ArcNode for i := 0; i &lt; n; i++ { l = append(l, ArcNode{ data: i, firstIn: nil, firstOut: nil, }) } return &amp;Map{ LineSize: 0, NodeSize: n, NodeList: l, } } 邻接多重表 邻接多重表是无向图的另一种链式存储结构。 在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低。 在邻接多重表中, 所有依附于同一顶点的边串联在同一链表中, 由于每条边依附于两个顶点 , 因此每个边结点同时链接在两个链表中。对无向图而言，其邻接多重表和邻接表的差别仅在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。 // VNode 边结构 type VNode struct { i int iNext *VNode j int jNext *VNode } // ArcNode 点结构 type ArcNode struct { data int first *VNode } // Map 图结构 type Map struct { NodeSize int LineSize int NodeList []ArcNode } func InitMap(n int) *Map { var l []ArcNode for i := 0; i &lt; n; i++ { l = append(l, ArcNode{ data: i, first: nil, }) } return &amp;Map{ NodeSize: n, LineSize: 0, NodeList: l, } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"golang","slug":"golang","permalink":"/tags/golang/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"实现常用数据结构(二叉树)——序列和二叉树","slug":"实现数据结构(树与二叉树)——序列和二叉树","date":"2021-04-25T08:37:15.000Z","updated":"2024-03-02T16:13:05.071Z","comments":true,"path":"2021/04/25/实现数据结构(树与二叉树)——序列和二叉树/","link":"","permalink":"/2021/04/25/实现数据结构(树与二叉树)——序列和二叉树/","excerpt":"","text":"多个序列确定树给出多个不同的遍历序列, 要求确定二叉树. 先序遍历序列和中序遍历序列先序遍历序列的第一个元素一定是根节点, 然后在中序中依据根节点可以找出左右子树, 然后就可以递归得出树的结构. // CreateTreeByPreAndIn 使用前序遍历和中序遍历创建树结构 func CreateTreeByPreAndIn(preOrder, inOrder []int) *Node { if len(preOrder) == 0 || len(inOrder) == 0 { return nil } data := preOrder[0] index := 0 for index &lt; len(inOrder) { if inOrder[index] == data { break } index++ } inOrderLeft, inOrderRight := inOrder[:index], inOrder[index+1:] preOrderLeft, preOrderRight := preOrder[1:len(inOrderLeft)+1], preOrder[1+len(inOrderLeft):] return &amp;Node{ data: data, left: CreateTreeByPreAndIn(preOrderLeft, inOrderLeft), right: CreateTreeByPreAndIn(preOrderRight, inOrderRight), } } 后序遍历序列和中序遍历序列和以上差不多, 只不过是最后一个节点是根节点, 所以不过多赘述. 层次遍历序列和中序遍历序列和前序序列相似, 在层次序列中, 开头的第一个元素是当前的根节点, 然后依然可以在中序序列中找到左右子树.这个时候就有不同了, 因为层次序列中的左右子树的节点分布是散开的, 并不是连续的, 所以我们需要遍历一遍数组, 将左右子树的节点分开到另外两个列表中 , 然后再递归构建树的结构. // CreateTreeByLevelAndIn 使用层次遍历和中序遍历创建树结构 func CreateTreeByLevelAndIn(levelOrder, inOrder []int) *Node { if len(levelOrder) == 0 || len(inOrder) == 0 { return nil } data := levelOrder[0] index := 0 levelOrderLeft, levelOrderRight := []int{}, []int{} for index &lt; len(inOrder) { if inOrder[index] == data { break } index++ } inOrderLeft, inOrderRight := inOrder[:index], inOrder[index+1:] for _, x := range levelOrder { mark := &quot;right&quot; for _, y := range inOrderLeft { if x == y { levelOrderLeft = append(levelOrderLeft, x) mark = &quot;left&quot; } } if mark == &quot;right&quot; { levelOrderRight = append(levelOrderRight, x) } } return &amp;Node{ data: data, left: CreateTreeByPreAndIn(levelOrderLeft, inOrderLeft), right: CreateTreeByPreAndIn(levelOrderRight, inOrderRight), } } 前序序列和后序序列相同不可以实现 多个序列估计二叉树 pre 和 post 相同: T(LR) (LR)T pre 和 in 相同: T(L)R (L)TR in 和 post 相同: LT(R) L(R)T pre 和 post 相反: TLR LRT pre 和 in 相反: TL(R) LT(R) in 和 post 相反: (L)TR (L)RT","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"golang","slug":"golang","permalink":"/tags/golang/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"记录开发记账网页的流程","slug":"记录开发记账网页","date":"2021-04-23T09:08:15.000Z","updated":"2024-03-02T16:13:05.025Z","comments":true,"path":"2021/04/23/记录开发记账网页/","link":"","permalink":"/2021/04/23/记录开发记账网页/","excerpt":"","text":"记账网页2021.4.23今天中午在 YouTube 上刷到一个记录北京程序员一天的视频. 别的没看到, 就惦记着别人使用一个记账软件记录自己每天的开销, 觉得自己现在学会了一点皮毛, 想要自己动手去制作一个适合自己的网页, 来记录自己的每天的开销. 说做咱就做, 不过现阶段还是以考研为主, 所以我觉得每天就拿出来 2 个小时空余时间来完成这个小项目. 感觉应该不算太耽误时间, 而且每天看汤家凤的视频真的有点… 没精神 . 就当做这个网页来开心开心吧. 第一天, 我决定先制定计划. 首先, 我虽然每天都在用 go 写数据结构, 但是对于 go 的框架还不是很熟悉. 到现在为止还只是使用过 gin, 编写过一个 helloword 的接口. 对于 gorm 等一些东西完全没有概念. 而且我觉得自己完成一个项目, 虽然不会有沟通方面的问题, 但会出现自己技术张不全面的问题. 所以, 我决定先设计好底层. 由于我想要实现的功能比较单一, 而且总体来说数据库读写并不是特别的复杂. 所以我觉得我应该优先设计数据库表, 再编写后端接口, 最后实现前端界面. 不过, 最开始肯定需要分析一下的是: 这个网页的需求. 我认为可以分析为一下几个方面: 能够为每日的开销记账, 应该只用输入最基础的开销, 例如 吃饭、话费、卫生纸啥的. 当然, 每笔账单应该包含备注. 每次的账单应该记录时间, 我认为精确到分钟或者秒不太现实, 因为不可能获取支付宝的 api, 所以可能做到付钱时记录时间, 而且让用户记录支付时间是不科学的. 考虑到用户基本上都是在每天、或者每个星期记账的,所以应该添加一个“记录时刻”的属性. 最后是分析数据, 这个我认为可以以后再讨论, 因为这些是可以前端来实现的. 总结: 我认为我这个项目的后端和数据库所需的心思并不是太多, 而且基本上只用一个数据表就可以记录所有的信息, 因为是给我个人使用的, 所以我觉得不需要账号和密码(其实是我懒). 然后我认为我最近需要学习的就是 gin 框架和 gorm 数据框架, 应该花时间学习一下. 今天的日记就记录到这吧. 2021.4.25这两天主要设计了一个数据库, 然后完成了用户部分的接口设计. 总体来说时间超过了很多, 我觉得我完全就是一个兴趣驱动的人. 我觉得考研对我的兴趣吸引完全不及我去做项目, 所以我基本上就拿出了大量的时间去做项目了. 不过我觉得以后还是得控制一下, 毕竟考研才是目前的主要任务. 分析一下这两天所做的事情. 首先, 设计了项目的数据库表, 我认为只需要两张表, 其实一张表也可以, 但是为了以后方便扩展, 就采用了两张表. 一张表是用户信息表, 用于存储用户的信息, 比如用户名、密码、邮箱啥的, 我想的是邮箱是唯一的, 是不能重复的, 而且如果要做登陆系统的话, 就使用邮箱和密码作为登陆的输入. 第二张表就是记录账单的表了, 这张表主要记录了金额、类型啥的, 感觉暂时也只需要这些吧. 然后就是学习gin和gorm的过程了. 我是从b 站视频和官方文档学习的 , 说实话, 坑还挺多的. 我现在就来详细地说一说: 项目结构的问题, 一开始我跟着视频写, 结果 gin 引擎、gorm 数据库连接、路由配置以及路由函数的处理都写在一个 mian.go 文件中, 感觉非常拥挤, 而且十分不便于管理. 所以我在 GitHub 上找到一个 gin-gorm 项目结构模版, 不过我使用的是2.0 版本, 因为我认为以我的项目的规模来说, 这个版本就已经完全够用了. 然后在这个结构中遇到了许多的坑, 我就很奇怪为啥需要把一个配置写的这么复杂, 不是应该只需要把常量导出就可以了吗? 为啥还是用 init 函数初始化? 真的没搞懂. 然后对于数据库的配置我也没看很懂, 将数据库的所有配置设计成了一个结构体, 然后再将结构体的每个属性拼接成了数据库连接的配置… 好吧, 虽然确实拆分了, 但是对于一个项目来说真的需要这么做吗? 不过, 我个人认为这个项目结构还是非常好用的, 也成功地将每个函数和路由分离了, 能够在 models 编写操作数据库的函数, 然后在 controller 编写 API 函数, 最后加载在 api 的路由中就可以了. 这种由底层逐步上升的感觉比在一个文件中改改写写好多了. 然后就是 gin 和 gorm 的问题了, 可能要归罪于我经常使用 Python 的原因, 对于 Go 的语法还不是非常熟悉.遇到的困难具体为一下几点: 数据库操作的问题, 因为已经很久没写过 sql 语句了, 导致很多时候设计操作数据库函数时并不是非常熟练,而且 gorm 的链式语法也还没有完全掌握, 导致出现很多 bug. gin 接口传值的问题, 在请求头传参和在请求体传参傻傻分不清, 而且在使用 Apifox 的过程中也没很好地认清. 然后就是准备接收 json 格式的参数时, 在调试软件 Apifox 中没有写在请求体中, 最后导致浪费了非常多的时间在改 bug 上. 关于 Go 语言的 err 处理问题, 一开始没有做统一的规划, 在每个函数中都打印了 err, 导致不知道是哪里出现了问题. 现在统一改成了 数据库操作函数将 err 返回, 然后在 api 函数中打印 err 的类型和 err 的内容. 学习到了很多东西, 也成功地将有关 user_info 表的内容实现了, 可喜可贺, 感觉我的进步还是很大的. 2021.4.26今天基本上已经把所有的接口实现了. 感觉这个项目的后端设计并不是非常复杂, 总共一起也只有 10 个接口的样子, 感觉一起写在 main.go 文件中也是能够完成的, 但是为了以后的扩展性, 使用这样的项目结构也不算坏. 今天主要完成的是就是账单方面的接口实现和测试啦. 其实在完成用户方面的接口后, 账单的接口也就不难实现了, 因为逻辑本身就没有太大的区别, 都不过是 CURD 而已. 唯一感觉有点麻烦的是 Go 语言的 time 包没有搞很清楚, 我在测试时输入的时间字段完全没有录入进去, 也不知道前端应该怎么给后端传值. 所以我是使用 string 保存的时间, 没有使用 Go 包中的 time 基础库. 至于格式什么的都交给前端去处理吧, 感觉 js 没有类型, 处理起来应该还挺方便的.(那为啥我感觉后端的事情这么少呀, 突然以后想做后端了) 现在后端要做的事情基本上已经, 剩下的基本上就是前端 Vue 页面设计了. 2021.4.27今天进行了一些简单的前端页面设计, 主要是测试了在页面中调用 api. 结果在过程中一只显示无法访问, 我就很好奇为什么, 无论怎么调用都没有办法… 先后进行了调端口、重启数据库、改变 js 函数调用. 结果发现都没有问题, 最后想起来在上个项目中使用 Django 配置了跨域访问的问题, 这才想起来没有在 Go 中设置, 于是在网络上搜索了一下, 发现编写了一个中间件就可以完成了. 最后在网络的力量下解决了跨域问题.","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"golang","slug":"golang","permalink":"/tags/golang/"},{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"实现常用数据结构(二叉树)——线索化","slug":"实现数据结构(树与二叉树)——线索化","date":"2021-04-23T06:20:15.000Z","updated":"2024-03-02T16:13:04.345Z","comments":true,"path":"2021/04/23/实现数据结构(树与二叉树)——线索化/","link":"","permalink":"/2021/04/23/实现数据结构(树与二叉树)——线索化/","excerpt":"","text":"线索化二叉树是对于遍历二叉树的进一步的改进. 通常我们遍历二叉树, 是将一个二叉树转化为线性结构. 而在我们遍历的过程中, 我们会发现经常需要回溯到父节点, 也就是走了重复的路. 因此不能像完全像线性结构一样, 而二叉树的线索化就是帮助我们找到每一个节点的前驱节点和后序节点, 这样我们就能像遍历线性结构一样遍历二叉树了. 因为深度优先遍历二叉树有三种形式, 分别为中序遍历、先序遍历、后序遍历, 所以对应的线索二叉树的方式也有三种. 中序线索化// InThread 中序线索化二叉树 func (n *Node) InThread() { n.inThread(nil) } func (n *Node) inThread(pre *Node) { if n != nil { n.right.inThread(pre) if n.left == nil { n.left = pre n.lTag = true } if pre != nil &amp;&amp; pre.right == nil { pre.right = n pre.rTag = true } n.left.inThread(n) } } 前序线索化二叉树// PreThread 前序线索化二叉树 func (n *Node) PreThread() { n.preThread(nil) } func (n *Node) preThread(pre *Node) { if n != nil { if n.left == nil { n.left = pre n.lTag = true } if pre != nil &amp;&amp; pre.right == nil { pre.right = n pre.rTag = true } if !n.lTag { n.left.inThread(n) } if !n.rTag { n.right.inThread(n) } } } 后序线索化二叉树// PostThread 后序线索二叉树 func (n *Node) PostThread() { n.postThread(nil) } func (n *Node) postThread(pre *Node) { if n != nil { n.left.inThread(pre) n.right.inThread(pre) if n.left == nil { n.left = pre n.lTag = true } if pre != nil &amp;&amp; pre.right == nil { pre.right = n pre.rTag = true } } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"golang","slug":"golang","permalink":"/tags/golang/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"实现常用数据结构(二叉树)——二叉树基础","slug":"实现数据结构(树与二叉树)","date":"2021-04-22T08:20:15.000Z","updated":"2024-03-02T16:13:05.071Z","comments":true,"path":"2021/04/22/实现数据结构(树与二叉树)/","link":"","permalink":"/2021/04/22/实现数据结构(树与二叉树)/","excerpt":"","text":"树与二叉树树的基础概念树的定义树是 n (n≥0)个结点的有限集。当 n=0 时，称为空树。在任意一棵非空树中应满足: 有且仅有一个特定的称为根的结点. 当 n&gt;1 时，其余结点可分为 m (m&gt;0)个互不相交的有限集, 其中每个集合本身又是一棵树, 并且称为根的子树. 树的性质树具有如下最基本的性质: 树中的结点数等于所有结点的度数之和加 1 度为 m 的树中第 i 层上至多有 m-1 个结点(i≥1) 高度为 h 的 m 叉树至多有(m^h-1)/(m-1)个结点” 具有 n 个结点的 m 叉树的最小高度为[ log(n(m-1)+1)] 二叉树二叉树的定义二叉树是另一种树形结构, 其特点是每个结点至多只有两棵子树(即二叉树中不存在度大于 2 的结点)，并且二又树的子树有左右之分，其次序不能任意颠倒。 与树相似，二叉树也以递归的形式定义。二叉树是 n (n≥0)个结点的有限集合: 或者为空二叉树，即 n=0。 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。 二叉树的存储结构顺序存储二叉树的顺序存储是指用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素, 即将完全二叉树上编号为 i 的结点元素存储在一维数组下标为 i-1 的分量中 依据二叉树的性质, 完全二叉树和满二叉树采用顺序存储比较合适, 树中结点的序号可以唯一地反映结点之间的逻辑关系, 这样既能最大可能地节省存储空间, 又能利用数组元素的下标值确定结点在二叉树中的位置, 以及结点之间的关系. 链式存储由于顺序存储的空间利用率较低, 因此二叉树一般都采用链式存储结构, 用链表结点来存储二叉树中的每个结点.在二叉树中, 结点结构通常包括若干数据域和若干指针域, 二叉链表至少包含 3 个域: 数据域 data、左指针域lchild 和右指针域 rchild. 代码实现二叉树基础, 就是实现二叉树的创建, 然后能够实现中序遍历、前序遍历、后序遍历的递归形式和迭代形式, 以及层序遍历二叉树的方式. type Node struct { data interface{} left *Node right *Node } // InitTree 创建一个二叉树节点 func InitTree() *Node { return &amp;Node{} } // PreOrder 前序递归遍历二叉树 func (n *Node) PreOrder() { if n != nil { fmt.Print(n.data, &quot; &quot;) n.left.PreOrder() n.right.PreOrder() } } // InOrder 中序递归遍历二叉树 func (n *Node) InOrder() { if n != nil { n.left.InOrder() fmt.Print(n.data, &quot; &quot;) n.right.InOrder() } } // PostOrder 后序递归遍历二叉树 func (n *Node) PostOrder() { if n != nil { n.left.PostOrder() n.right.PostOrder() fmt.Print(n.data, &quot; &quot;) } } // ItPreOrder 非递归形式前序遍历 func (n *Node) ItPreOrder() []int { res := []int{} if n == nil { return res } var stack []*Node for cur := n; cur != nil || len(stack) != 0; { if cur != nil { res = append(res, cur.data.(int)) stack = append(stack, cur) cur = cur.left } else { cur = stack[len(stack)-1] stack = stack[:len(stack)-1] cur = cur.right } } return res } // ItInOrder 非递归形式中序遍历 func (n *Node) ItInOrder() []int { res := []int{} if n == nil { return res } var stack []*Node for cur := n; cur != nil || len(stack) != 0; { if cur != nil { stack = append(stack, cur) cur = cur.left } else { cur = stack[len(stack)-1] res = append(res, cur.data.(int)) stack = stack[:len(stack)-1] cur = cur.right } } return res } // ItPostOrder 非递归形式后序遍历 func (n *Node) ItPostOrder() []int { res := []int{} if n == nil { return res } stack := []*Node{} pre := &amp;Node{} stack = append(stack, n) for len(stack) != 0 { cur := stack[len(stack)-1] if (cur.left == nil &amp;&amp; cur.right == nil) || (pre != nil &amp;&amp; (pre == cur.left || pre == cur.right)) { res = append(res, cur.data.(int)) pre = cur stack = stack[:len(stack)-1] } else { if cur.right != nil { stack = append(stack, cur.right) } if cur.left != nil { stack = append(stack, cur.left) } } } return res } // 层序遍历二叉树 func (n *Node) LevelOrder() { queue := []*Node{n} for len(queue) != 0 { item := queue[0] fmt.Print(item.data, &quot; &quot;) queue = queue[1:] if item.left != nil { queue = append(queue, item.left) } if item.right != nil { queue = append(queue, item.right) } } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"golang","slug":"golang","permalink":"/tags/golang/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"论同情心和同理心","slug":"论同情心和同理心","date":"2021-04-20T01:13:15.000Z","updated":"2024-03-02T16:13:04.996Z","comments":true,"path":"2021/04/20/论同情心和同理心/","link":"","permalink":"/2021/04/20/论同情心和同理心/","excerpt":"","text":"论同情心和同理心论同情心和同理心 说起同情心和同理心，就不得不看到其中的差异，一个是“情”一个是“理 ”。 “情”通常是一种主观上的感受，因此我认为同情心是一种对于除自己以外的事物抱有主观上的理解。说明白点就是按照自己的思维去理解其他事物的现状，并以此投射自己的情感。 而“理”在某种意义上来说是偏客观的，是一种广泛适用的道理，因此我认为同理心是一种对于事物站在合理性角度上的理解。说明白点，同理心能让我们理解事物在客观上应该是怎么样的，并且尽量不带自我的主观情感。 感觉还是太抽象了，那不如举几个例子吧。在我理解中，对于夏日的天空有多蓝这个话题，使用同情心来说的话：天空如海边的玻璃汽水般沁人心脾；而使用同理心来描述则是：天空如碧蓝的宝石般透彻蔚蓝。海边的玻璃汽水是主观经历过的事物，它所引导出的是过往的回忆，所以偏向主观；而碧蓝的宝石是珍贵宝物，谈起它人们会立刻想起它的美丽，从而能联想到天空像宝石一般，这就是客观上的认识了。 对于我来说，同情心和同理心的优劣没有区分。可能由于我在读专业是计算机的缘故，平时更偏向于理性，对于同情心稍有缺失。但我认为这两者对于人的一生都是非常重要的。同情心让我更加浪漫，更加富有激情，使自我的感觉更加丰富；而同理心让我更好地认识这个世界，也更好地理解他人。 当然，并不是说人对于一件事物，仅抱有同情心或者同理心，我觉得这是不够的。如果缺失了同情心，则会少了许多烟火气，仿佛事事与自己无关；而少了同理心则会难以客观地认识事物，或许会被自己的情绪所掌控、失去了理智。 我想或许，能够辩证地看待事物，不自大地以为了解事物的全貌，便算做到了同理心；对于事物有自己的偏好，敢爱敢恨不随波逐流也便算做到了同情心吧。 2021 年 4 月 20 日凌晨 3.53 写此日记来记录这次失眠吧 后记感觉我标题取的好…狂妄呀, 我以前初中的时候看过培根散文，里面好多论读书、论英雄啥的。初中写作文的时候也用过论 XX，结果被老师一顿批，哈哈哈，说我起这么庞大的标题但是写的却不深刻。我也不知道我这个写的深不深刻，但是我自己写的，我乐意!","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"思考","slug":"思考","permalink":"/tags/思考/"},{"name":"深夜","slug":"深夜","permalink":"/tags/深夜/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"第12届蓝桥杯Python组复盘","slug":"12届蓝桥杯Python组复盘","date":"2021-04-19T13:51:15.000Z","updated":"2022-04-20T05:27:15.000Z","comments":true,"path":"2021/04/19/12届蓝桥杯Python组复盘/","link":"","permalink":"/2021/04/19/12届蓝桥杯Python组复盘/","excerpt":"","text":"前言以前都是报名第 C++ B 组的, 因为自己本身对 Python 更感兴趣, 所以这次选择报名 Python 试试, 反正钱是由学院出的, 我就当是尝试一下呗. 结果这次就翻车了, 好多题没做出来. 可能是因为 Python 没有分组的原因吧, 或者我被分到了 A 组, 看了一下 C++ A 组的题目, 感觉果然是上当了, 和 A 组的题目基本是一样的, 唉, 只能祈求能拿个奖水一下了. 第一次参加蓝桥杯 Python 组, 不知道怎么书写, 就按照自己舒服的格式来了. 解题 A 卡片 第一时间就想到了用 python 的 collections 库的 Counter 计数, 如果我是参加的 C++ 可能会专门列一个数组用来计数吧. def A(): from collections import Counter cardNum = 2021 cards = [cardNum] * 10 def check(num: int) -&gt; bool: c = Counter(str(num)) for i in c: cards[int(i)] -= c[i] if cards[int(i)] &lt; 0: return False return True index = 1 while True: if not check(index): print(index - 1) return index += 1 B 直线 当时看着就烦, 最讨厌写这种题目了, 于是就放着没写了. 赛后解答没想到意外的还挺简单的, 怎么办, 5 分没有了 我是将所有的直线都化作 y = ax + b 的形式, 这样 a,b 就不会有重复, 别人说的精度问题, 我没有遇到, 可能 python 不存在精度问题吧. def B(): xList = [i for i in range(20)] yList = [i for i in range(21)] points = [(x, y) for x in xList for y in yList] s = set() res = 20 + 21 def getLine(p, q): a = (q[1] - p[1]) / (q[0] - p[0]) b = (p[0] * (p[1] - q[1]) + p[1] * (q[0] - p[0])) / (q[0] - p[0]) return a, b for p in points: for q in points: if p != q and p[0] != q[0] and p[1] != q[1]: s.add(getLine(p, q)) print(len(s) + res) C 货物摆放 我注意到 i，j，k 都是 Num 到因数，而且两两相乘也是 Num 的因数 我的做法就是用一个集合存储 2021041820210418 的所有因子，然后用三重循环暴力需要注意的是一定不能强行遍历到 Num，肯定跑不出来的，在每次存因子时保存对应的因子就好了。因为顺序不同算不同方案，所以直接暴力 😂 def C(): Num = 2021041820210418 factors = set() for i in range(1, Num): if i in factors: break if Num % i == 0: factors.add(i) factors.add(Num // i) res = 0 for i in factors: for j in factors: for k in factors: if i * j * k == Num: res += 1 print(res) D 路径 DP 题, 在 leetcode 上练习了一个多月 DP 的我只想说, 下一个! def D(): import math def lcm(x, y: int) -&gt; int: return x * y // math.gcd(x, y) dp = [float(&#39;inf&#39;)] * 2022 dp[2021] = 0 for i in range(2021, 0, -1): for j in range(i - 1, i - 22, -1): if j &lt;= 0: break dp[j] = min(dp[j], dp[i] + lcm(i, j)) print(dp[1]) E 回路计算 这道题想了一个多小时, 写出来一个肯定暴时间的, Python 跑了 20 分钟, 硬是没跑出来 F 时间 没啥好说的，1 秒=1000 毫秒 考场的时候用样例推一下就好了 def F(): millisecond = int(input()) second = millisecond % (1000 * 60 * 60 * 24) // 1000 hour = second // (60 * 60) minute = second // 60 % 60 second = second % 60 def out(x: int) -&gt; str: s = &quot;&quot; if x &lt; 10: s += &quot;0&quot; s += str(x) return s s = out(hour) + &#39;:&#39; + out(minute) + &#39;:&#39; + out(second) print(s) G 杨辉三角 我没搞懂为啥都说暴内存了，我是直接在原地处理每一层的 def G(): num = int(input()) if num == 1: return 1 pascal = [1, 1] index = 3 while True: print(pascal) l = pascal[:] for i in range(1, len(l)): pascal[i] = l[i] + l[i - 1] pascal.append(1) if num in pascal: index += pascal.index(num) + 1 print(index) return else: index += len(pascal) H 左孩子右兄弟 同样是想了半天, 没想清楚就开始写了, 最后发现算法是错的, 崩溃了呜呜呜 赛后解答 比赛时直接使用的数组存储的, 结果发现要搜索子节点和父节点非常麻烦. 而且当时只考虑了根节点的情况, 然后判断哪个分支最高(捂脸, 我好蠢, 明明是相似的结构). 写到半路发现不对劲, 原本树的高度和变成二叉树后的高度没太大关系, 发现要递归. 最崩溃的是发现存储结构也要改一下, 最后没时间了, 就没写了. 在赛后, 我把我当时的想法分析了一下, 自己设计了一个数据结构. 我用一个 孩子列表 存储每个子节点在数组中的下标, 然后用数组的下标表示节点的编号, 然后在结构体中使用 targetNode 表示父节点的编号. 这样在递归中就可以很好地遍历整个树了. 然后我使用了贪心算法, 我认为要想获得最高的高度, 只需要在原树每一层中选取转化为二叉树后高度最高的分支, 让其作为当前层的最下的一个节点, 这样就能获取最大的高度. (不过我没有证明) def H(): class node(): def __init__(self, targetNode): self.targetNode = targetNode self.childList = [] n = int(input()) tree = [None, node(targetNode=0)] for i in range(2, n + 1): target = int(input()) tree.append(node(targetNode=target)) tree[target].childList.append(i) def getMaxLength(n: node) -&gt; int: if len(n.childList) != 0: return len(n.childList) + max(getMaxLength(tree[_next]) for _next in n.childList) return 1 print(getMaxLength(tree[1]) - 1) I 异或数列 没时间了, 没看题 J 括号序列 没时间了, 没看题","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"/tags/蓝桥杯/"},{"name":"Python","slug":"Python","permalink":"/tags/Python/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"LeetCode——208. 实现 Trie (前缀树)","slug":"leetcode刷题(208. 实现 Trie (前缀树))","date":"2021-04-14T00:47:15.000Z","updated":"2024-03-02T16:13:05.026Z","comments":true,"path":"2021/04/14/leetcode刷题(208. 实现 Trie (前缀树))/","link":"","permalink":"/2021/04/14/leetcode刷题(208. 实现 Trie (前缀树))/","excerpt":"","text":"介绍(以下摘抄自维基百科)在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。 Trie 这个术语来自于 retrieval。根据词源学，trie 的发明者 Edward Fredkin 把它读作 /ˈtriː/“tree”。[1][2]但是，其他作者把它读作/ˈtraɪ/ “try”。 在图示中，键标注在节点中，值标注在节点之下。每一个完整的英文单词对应一个特定的整数。Trie 可以看作是一个确定有限状态自动机，尽管边上的符号一般是隐含在分支的顺序中的。 键不需要被显式地保存在节点中。图示中标注出完整的单词，只是为了演示 trie 的原理。 trie 中的键通常是字符串，但也可以是其它的结构。trie 的算法可以很容易地修改为处理其它结构的有序序列，比如一串数字或者形状的排列。比如，bitwise trie 中的键是一串比特，可以用于表示整数或者内存地址。 leetcode 题目Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 请你实现 Trie 类： Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true；否则，返回 false 。 实现使用数组存储 package myCode // Trie 字典树结构 type Trie struct { size int isWord bool next [26]*Trie } // Constructor 构造函数 func Constructor() Trie { return Trie{} } // Insert 插入一个新的字符串 func (t *Trie) Insert(word string) { if len(word) == 0 { return } cur := t for i := range word { if cur.next[word[i]-&#39;a&#39;] == nil { cur.next[word[i]-&#39;a&#39;] = new(Trie) } cur = cur.next[word[i]-&#39;a&#39;] } if !cur.isWord { cur.isWord = true t.size++ } } // Search 搜索是否存在当前字符串 func (t *Trie) Search(word string) bool { length := len(word) if length == 0 { return false } cur := t for i := 0; i &lt; length; i++ { if cur = cur.next[word[i]-&#39;a&#39;]; cur == nil { return false } } return cur.isWord } // StartsWith 搜索是否存在以当前字符串开头的字符串 func (t *Trie) StartsWith(prefix string) bool { length := len(prefix) if length == 0 { return true } cur := t for i := 0; i &lt; length; i++ { if cur = cur.next[prefix[i]-&#39;a&#39;]; cur == nil { return false } } return true } 使用 map 存储 type Trie struct { isWord bool next map[rune]*Trie } func Constructor() Trie { return Trie{ false, make(map[rune]*Trie), } } func (t *Trie) Insert(word string) { if len(word) == 0 { return } cur := t for _, v := range word { _, ok := cur.next[v] if !ok { cur.next[v] = &amp;Trie{false, make(map[rune]*Trie)} } cur = cur.next[v] } if !cur.isWord { cur.isWord = true } } func (t *Trie) Search(word string) bool { if len(word) == 0 { return false } cur := t for _, v := range word { t1, ok := cur.next[v] if !ok { return false } cur = t1 } return cur.isWord } func (t *Trie) StartsWith(word string) bool { if len(word) == 0 { return true } cur := t for _, v := range word { t1, ok := cur.next[v] if !ok { return false } cur = t1 } return true } 分析总体上来说使用数组存储时间更快, 但是使用 map 存储空间更小. 具体使用哪种方法根据需求改变.","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"golang","slug":"golang","permalink":"/tags/golang/"},{"name":"LeetCode","slug":"LeetCode","permalink":"/tags/LeetCode/"},{"name":"前缀树\\字典树","slug":"前缀树-字典树","permalink":"/tags/前缀树-字典树/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"记第一次接单","slug":"记第一次接单","date":"2021-04-13T06:13:15.000Z","updated":"2024-03-02T16:13:04.774Z","comments":true,"path":"2021/04/13/记第一次接单/","link":"","permalink":"/2021/04/13/记第一次接单/","excerpt":"","text":"前言和 npy 在长沙玩的时候，正愁手头没钱，研究生学长便找我说 “有没有兴趣去帮别人做几个毕业设计”，想着试一试就当积累经验并赚点小钱，于是便开始了第一次接单。 接单的内容接的项目是以微信小程序 + 本地 Spring Boot 服务器结构，具体内容是完成一个吉他分享平台。 刚开始的时候我觉得这不就是一个简单的前后端分离项目嘛。虽然没有做过微信小程序项目，但是大二但时候选修过微信小程序的课，还是有一定基础的知识。再加上听说微信小程序和 Vue 语法差不多，便答应了下来。 具体的需求文档如下： 技术实现由于我负责的是前端微信小程序部分，室友做的是 SpringBoot 后端，所以在此只说前端部分。 技术栈原生微信小程序 + Vant Weapp 组件库 + Colorful 样式库 源码GitHub 感受最终感觉从零开始做一个项目还是挺累的，在这次接单中大致上真正实践了前后端分离。真正认识到了后端不写 Api 描述的恶心之处。 swagger 永远的神！救了我的老命！ 然后项目需求真的要和客户提前交流好，比如的一个就是：开始说的做一个和弦搜索模块，我问他是不是在全部的和弦中搜索（因为我不知道和弦是什么，我以为就是数据库中的所有图谱），客户说是的。于是直接把链接导向了首页搜索的页面，结果在演示的时候客户又说是所有的和弦指法，只用显示一张包含所有吉他指法的图片就可以了 😂，所以交流还是很重要的。 再就是要注意好保护自己的源码，今天客户要我帮他配置项目以应对他老师的检查。我暗自觉得不对劲，我连一分钱都没拿到呢，怎么可能把源码给他配置好。于是找到了我的学长，他也说要先给钱再交货。这次有了经验，觉得保护自己的主导权还是很重要的，不能盲目相信别人。 虽然这个项目从开始到完成只做了几天，但是也感受到了做项目的不易。做项目过程中每天都很累，还容易和 npy 吵架 😂。所以我打算还是专注于考研，等考研事宜尘埃落定了看这些接单的工作把。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"前端","slug":"前端","permalink":"/tags/前端/"},{"name":"微信小程序","slug":"微信小程序","permalink":"/tags/微信小程序/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"实现常用数据结构(串)","slug":"实现数据结构(串)","date":"2021-04-01T09:11:15.000Z","updated":"2024-03-02T16:13:05.010Z","comments":true,"path":"2021/04/01/实现数据结构(串)/","link":"","permalink":"/2021/04/01/实现数据结构(串)/","excerpt":"","text":"定义字符串简称串，计算机上非数值处理的对象基本都是字符串数据。我们常见的信息检索系统 (如搜索引擎)、文本编辑程序(如 Word)、问答系统、自然语言翻译系统等，都是以字符串数据作为处理对象的。 串的存储表示 定长顺序存储 类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。 堆分配存储 堆分配存储表示仍然以一组地址连续的存储单元存放串值的字符序列，但它们的存储空间是在程序执行过程中动态分配得到的。 块链存储 类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性 (每个元素只有一个字符)，在具体实现时，每个结点既可以存放一个字符，也可以存放多个字符。每个结点称为块，整个链表称为块链结构。 KMP 算法Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这三人的姓氏命名此算法。 下面先直接给出 KMP 的算法流程： 假设现在文本串 S 匹配到 i 位置，模式串 P 匹配到 j 位置 如果 j = -1，或者当前字符匹配成功（即 S[i] == P[j]），都令 i++，j++，继续匹配下一个字符； 如果 j != -1，且当前字符匹配失败（即 S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串 P 相对于文本串 S 向右移动了 j - next [j] 位。 换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的 next 值（next 数组的求解会在下文的 3.3.3 节中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于 1。 很快，你也会意识到 next 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如，如果 next [j] = k，代表 j 之前的字符串中有最大长度为 k 的相同前缀后缀。 此也意味着在某个字符失配时，该字符对应的 next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到 next [j] 的位置）。如果 next [j] 等于 0 或 -1，则跳到模式串的开头字符，若 next [j] = k 且 k &gt; 0，代表下次匹配跳到 j 之前的某个字符，而不是跳到开头，且具体跳过了 k 个字符。 转换成代码表示，则是： func getNextList(str string) []int { next := make([]int, len(str)) next[0] = -1 i, j := 0, -1 for i &lt; len(str)-1 { if j == -1 || str[i] == str[j] { j++ i++ next[i] = j } else { j = next[j] } } return next } func KMP(str, target string) int { next := getNextList(target) i, j := 0, 0 for i &lt; len(str) &amp;&amp; j &lt; len(target) { if str[i] == target[j] || next[j] == -1 { i++ j++ } else { j = next[j] } } if j == len(target) { return i - len(target) } return -1 }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"golang","slug":"golang","permalink":"/tags/golang/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"实现常用数据结构(队列与栈)","slug":"实现数据结构(队列与栈)","date":"2021-03-31T06:30:15.000Z","updated":"2024-03-02T16:13:05.071Z","comments":true,"path":"2021/03/31/实现数据结构(队列与栈)/","link":"","permalink":"/2021/03/31/实现数据结构(队列与栈)/","excerpt":"","text":"栈 定义栈(Stack) 是只允许在一端进行插入或删除操作的线性表。首先栈是一种线性表,但限定这种线性表只能在某一端进行插入和删除操作 基础操作 初始化 判断是否为空 进栈 出栈 输出栈的大小 存储结构 顺序结构 链式结构 顺序实现由于可以使用 golang 自带的切片. package Stack import ( &quot;fmt&quot; &quot;sync&quot; ) type Stack struct { list []interface{} mutex sync.Mutex } // 初始化一个栈 func InitStack() *Stack { return &amp;Stack{} } // 进栈 func (s *Stack) Push(value interface{}) { s.mutex.Lock() defer s.mutex.Unlock() s.list = append(s.list, value) } // 出栈 func (s *Stack) Pop() interface{} { s.mutex.Lock() defer s.mutex.Unlock() value := s.list[len(s.list)-1] s.list = s.list[:len(s.list)-1] return value } // 判断是否为空 func (s *Stack) IsEmpty() bool { s.mutex.Lock() defer s.mutex.Unlock() return len(s.list) == 0 } // 输出栈的大小 func (s *Stack) Size() int { s.mutex.Lock() defer s.mutex.Unlock() return len(s.list) } // 打印所有的元素 func (s *Stack) Print() { for i := s.Size() - 1; i &gt;= 0; i-- { fmt.Print(s.list[i], &quot; &quot;) } fmt.Println() } 链式实现使用单链表实现栈, 因此需要创建两个结构体 package StackLink import ( &quot;errors&quot; &quot;fmt&quot; &quot;sync&quot; ) type Node struct { data interface{} next *Node } type StackLink struct { top *Node length int mutex sync.Mutex } // 初始化一个栈 func InitStack() *StackLink { return &amp;StackLink{top: &amp;Node{data: &quot;stack&quot;, next: nil}, length: 0} } // 进栈 func (s *StackLink) Push(value interface{}) { s.mutex.Lock() defer s.mutex.Unlock() node := &amp;Node{data: value, next: s.top.next} s.top.next = node s.length++ } // 出栈 func (s *StackLink) Pop() interface{} { s.mutex.Lock() defer s.mutex.Unlock() if s.top.next == nil { return errors.New(&quot;异常！栈为空，无法推出元素&quot;) } value := s.top.next.data s.top = s.top.next s.length-- return value } // 判断是否为空 func (s *StackLink) IsEmpty() bool { s.mutex.Lock() defer s.mutex.Unlock() return s.length == 0 } // 输出栈的大小 func (s *StackLink) Size() int { s.mutex.Lock() defer s.mutex.Unlock() return s.length } // 打印所有的元素 func (s *StackLink) Print() { cur := s.top for cur.next != nil { fmt.Print(cur.next.data, &quot; &quot;) cur = cur.next } fmt.Println() } 以下是测试的例子以及输出: func main() { s := Stack.InitStack() s.Push(5) s.Print() s.Push(3) s.Push(2) s.Print() fmt.Println(s.Size()) fmt.Println(s.IsEmpty()) fmt.Println(s.Pop()) } // 5 // 2 3 5 // 3 // false // 2 队列 定义队列(Queue) 简称队，也是一种操作受限的线性表， 只允许在表的一端进行插入， 而在表的另一端进行删除。向队列中插入元素称为入队或进队;删除元素称为出队或离队。这和我们日常生活中的排队是一致的， 最早排队的也是最早离队的，其操作的特性是先进先出 (First In First Out, FIFO) 基础操作 初始化 插入 推出 判断是否为空 返回队列大小 存储结构 顺序结构 链式结构 顺序实现由于可以使用 golang 自带的切片来模拟. package Queue import ( &quot;fmt&quot; &quot;sync&quot; ) type Queue struct { queue []interface{} mutex sync.Mutex } // 初始化表 func InitQueue() *Queue { return &amp;Queue{} } // 插入 func (q *Queue) Push(value interface{}) { q.mutex.Lock() defer q.mutex.Unlock() q.queue = append(q.queue, value) } // 推出 func (q *Queue) Pop() interface{} { q.mutex.Lock() defer q.mutex.Unlock() value := q.queue[0] q.queue = q.queue[1:] return value } // 判断是否为空 func (q *Queue) IsEmpty() bool { q.mutex.Lock() defer q.mutex.Unlock() return len(q.queue) == 0 } // 返回队列大小 func (q *Queue) Size() int { q.mutex.Lock() defer q.mutex.Unlock() return len(q.queue) } // 打印所有的元素 func (q *Queue) Print() { for _, x := range q.queue { fmt.Print(x, &quot; &quot;) } fmt.Println() } 链式实现使用单链表实现队列, 因此需要创建两个结构体 package QueueLink import ( &quot;errors&quot; &quot;fmt&quot; &quot;sync&quot; ) type Node struct { data interface{} next *Node } type QueueLink struct { head *Node tail *Node length int mutex sync.Mutex } // 初始化表 func InitQueueLink() *QueueLink { node := &amp;Node{data: &quot;queue&quot;, next: nil} return &amp;QueueLink{head: node, tail: node, length: 0} } // 插入 func (q *QueueLink) Push(value interface{}) { q.mutex.Lock() defer q.mutex.Unlock() node := &amp;Node{data: value, next: nil} q.tail.next = node q.tail = node q.length++ } // 推出 func (q *QueueLink) Pop() interface{} { q.mutex.Lock() defer q.mutex.Unlock() if q.head.next == nil { return errors.New(&quot;异常！队列为空，无法推出元素&quot;) } value := q.head.next.data q.head = q.head.next q.length-- return value } // 判断是否为空 func (q *QueueLink) IsEmpty() bool { q.mutex.Lock() defer q.mutex.Unlock() return q.length == 0 } // 返回队列大小 func (q *QueueLink) Size() int { q.mutex.Lock() defer q.mutex.Unlock() return q.length } // 打印所有的元素 func (q *QueueLink) Print() { cur := q.head for cur.next != nil { fmt.Print(cur.next.data, &quot; &quot;) cur = cur.next } fmt.Println() } 以下是测试的例子以及输出: func main() { q := Queue.InitQueue() q.Push(1) q.Push(3) q.Push(6) q.Print() fmt.Println(q.Pop()) fmt.Println(q.Pop()) fmt.Println(q.IsEmpty()) fmt.Println(q.Size()) } // 1 3 6 // 1 // 3 // false // 1","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"golang","slug":"golang","permalink":"/tags/golang/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"实现常用数据结构(线性表)","slug":"实现数据结构(顺序表)","date":"2021-03-30T14:47:15.000Z","updated":"2024-03-02T16:13:05.023Z","comments":true,"path":"2021/03/30/实现数据结构(顺序表)/","link":"","permalink":"/2021/03/30/实现数据结构(顺序表)/","excerpt":"","text":"线性表按照存储方式大致上分为两种: 顺序表示 链式表示 顺序表示 线性表的顺序存储又称顺序表。它是用–组地址连续的存储单元依次存储线性表中的数据元素,从而使得逻辑上相邻的两个元素在物理位置上也相邻。第 1 个元素存储在线性表的起始位置,第 i 个元素的存储位置后面紧接着存储的是第 i+ 1 个元素，称 i 为元素 a;在线性表中的位序。因此，顺序表的特点是表中元素的逻辑顺序与其物理顺序相同。 基本上可以通过 GO 语言内置的列表来实现. 由于经常使用, 故不做过多的描述, 直接放代码. package Linear_List import ( &quot;errors&quot; ) const Max_Length = 20 type ContiguousList struct { MaxLength int Length int LineListContent []interface{} } func InitLineList() *ContiguousList { return &amp;ContiguousList{ MaxLength: Max_Length, LineListContent: make([]interface{}, 0, Max_Length), } } // 判断是否为空 func (c ContiguousList) IsEmpty() bool { if c.Length == 0 { return true } return false } // 判断是否满 func (c ContiguousList) IsFull() bool { if c.Length == c.MaxLength { return true } return false } // 判断是否越界 func (c ContiguousList) indexOver(i int) bool { if i &lt; 1 || i &gt; c.Length { return true } return false } // 获取指定的数据 func (c ContiguousList) getData(i int) (interface{}, error) { if ok := c.indexOver(i); ok { return &quot;&quot;, errors.New(&quot;查找的索引不在线性表范围内&quot;) } return c.LineListContent[i+1], nil } //删除任意位置的一个数据 func (c *ContiguousList) Delete(i int) (interface{}, error) { if ok := c.indexOver(i); ok { return &quot;&quot;, errors.New(&quot;删除的索引不在线性表内&quot;) } if ok := c.IsEmpty(); ok { return &quot;&quot;, errors.New(&quot;没有可以删除的数据&quot;) } deleteData := c.LineListContent[i-1] for j := i - 1; j &lt; c.Length-1; j++ { c.LineListContent[j] = c.LineListContent[j+1] } c.LineListContent = c.LineListContent[:c.Length-1] c.Length-- return deleteData, nil } // 在末尾推出一个数据 func (c *ContiguousList) Pop() (interface{}, error) { if ok := c.IsEmpty(); ok { return &quot;&quot;, errors.New(&quot;没有可以删除的数据&quot;) } temp := c.LineListContent[c.Length-1] c.LineListContent = c.LineListContent[:c.Length-1] c.Length-- return temp, nil } // 在末尾添加一个数据 func (c *ContiguousList) Append(data interface{}) (bool, error) { if ok := c.IsFull(); ok { return false, errors.New(&quot;线性表已经满了&quot;) } c.LineListContent = append(c.LineListContent, data) c.Length++ return true, nil } // 在任意位置插入一个数据 func (c *ContiguousList) Insert(i int, data interface{}) (bool, error) { if ok := c.IsFull(); ok { return false, errors.New(&quot;线性表已满，无法添加数据&quot;) } if ok := c.indexOver(i); ok { return false, errors.New(&quot;插入点越界&quot;) } _, _ = c.Append(&quot;&quot;) for j := c.Length - 1; j &gt; i-1; j-- { c.LineListContent[j] = c.LineListContent[j-1] } c.LineListContent[i-1] = data return true, nil } 以下是测试的例子以及输出: func main() { cl := Linear_List.InitLineList() _, _ = cl.Append(11) _, _ = cl.Insert(1, 34) _, _ = cl.Append(90) fmt.Println(cl.LineListContent) fmt.Println(cl.Length) _, _ = cl.Delete(2) fmt.Println(cl.LineListContent) cd, err0 := cl.Pop() if err0==nil{ fmt.Println(cd) } fmt.Println(cl.LineListContent) fmt.Println(cl.Length) } // [34 11 90] // 3 // [34 90] // 90 // [34] // 1 顺序表示-例题 剔除数组最小的元素, 空出的位置由最后的元素填补. 数组原地逆序 删除值为 x 的数据元素, 时间 O(x)、空间 O(1) 删除有序列表中给定值于 s-t 中的所有元素 删除无序列表中给定值于 s-t 中的所有元素 从有序列表中删除所有值重复的元素 将两个有序顺序表合并为一个新的有序顺序表 有序列表的二分查找, 查找到的元素与其后继元素交换 我的题解能力有限, 只是初步实现功能. 第一题遍历了一遍顺序表, 找到最小的元素后与最后的元素交换位置, 然后剔除最后的元素. func (c *ContiguousList) DeleteSmallest() error { if c.IsEmpty() { return errors.New(&quot;列表为空&quot;) } min, list := 0, c.LineListContent for i, _ := range list { x := list[i].(int) if list[min].(int) &gt; x { min = i } } list[min], list[c.Length-1] = list[c.Length-1], list[min] _, _ = c.Pop() return nil } 第二题头尾双指针, 同时向中间遍历, 遍历期间不断交换两个指针的值. func (c *ContiguousList) Reverse() { i, j := 0, c.Length-1 if i == j { return } list := c.LineListContent for i &lt; j { list[i], list[j] = list[j], list[i] i++ j-- } } 第三题 or 第四题、第五题和第六题从头到尾进行一次遍历, 使用 num 记录目标值个数, 期间如果当前元素是目标值, 则记录并减少 length 长度;如果不是目标值, 则将其复制到应该存在的位置(根据当前的 i 和 num 决定), 最后只用取长度为 length 的顺序表即可. func (c *ContiguousList) DeleteX(x interface{}) error { if c.IsEmpty() { return errors.New(&quot;列表为空&quot;) } list, num := c.LineListContent, 0 for i, _ := range list { if list[i] == x { //在这里修改条件 num++ c.Length-- } else { list[i-num] = list[i] } } c.LineListContent = list[:c.Length] return nil } 第四题、第五题和第六题我感觉和第三题差不太多, 我的做法是使用第三题的思路, 不过在 for 循环中的 if 的判断条件变了一下, 照样是可以实现 O(n) 和 O(1) 的复杂度的算法. 如果说可能有什么优化的话, 我感觉在第四题中可以使用二分查找搜索 s 和 t 的位置, 然后修改整个列表. 不过我嫌麻烦 😂 就不打算写了. 第五题和第六题我想不出来能怎么优化. 第七题基本思想: 使用两个指针指向两个有序顺序表, 然后依次比较后录入, 最后将剩下的元素录入. func MergeOrderList(c1, c2 *ContiguousList) *ContiguousList { c := InitLineList() l1, l2, it1, it2, le1, le2 := c1.LineListContent, c2.LineListContent, 0, 0, c1.Length, c2.Length for it1 &lt; le1 &amp;&amp; it2 &lt; le2 { if l1[it1].(int) &lt; l2[it2].(int) { c.Append(l1[it1]) it1++ } else { c.Append(l2[it2]) it2++ } } if it1 == le1 { for i := it2; i &lt; le2; i++ { c.Append(l2[it2]) } } else { for i := it1; i &lt; le1; i++ { c.Append(l1[it1]) } } return c } 第八题基础的二分查找, 比较怪的是查找后找到后与后继元素互换位置… 我没怎么搞懂这么做有什么意义… func (c *ContiguousList) BisInsert(x interface{}) { if c.IsEmpty() { c.Append(x) } var mid int left, right, list := 0, c.Length-1, c.LineListContent for left &lt;= right { mid = (right-left)/2 + left if list[mid].(int) == x.(int) { break } else if list[mid].(int) &gt; x.(int) { right = mid - 1 } else { left = mid + 1 } } if left &lt;= right { if mid == c.Length-1 { return } else { list[mid], list[mid+1] = list[mid+1], list[mid] } } else { if mid == c.Length-1 { c.Append(x) } else { c.Insert(mid+2, x) } } } 链式表示 顺序表可以随时存取表中的任意-一个元素，它的存储位置可以用一个简单直观的公式表示，但插入和删除操作需要移动大量元素。链式存储线性表时，不需要使用地址连续的存储单元，即不要求逻辑上相邻的元素在物理位置.上也相邻，它通过“链”建立起数据元素之间的逻辑关系, 因此插入和删除操作不需要移动元素，而只需修改指针，但也会失去顺序表可随机存取的优点。 想要实现线性表的链式表示, 需要自定义一个结点结构, 一部分保存值, 一部分保存下一个元素的地址. type Node struct { data interface{} next *Node } 然后让我们来实现其基本函数 package SinglyLinkedList import &quot;fmt&quot; type Node struct { data interface{} next *Node } func InitLinkList() *Node { return &amp;Node{&quot;The head node&quot;, nil} } // 获取第一个结点 func (n *Node) GetFirstNode() *Node { if n.next == nil { return nil } return n.next } //获取最后一个结点 func (n *Node) GetEndNode() *Node { if n.next == nil { return nil } for n.next != nil { n = n.next } return n } // 在末尾添加一个结点 func (n *Node) EndAppend(data interface{}) bool { tempNode := &amp;Node{data, nil} for n.next != nil { n = n.next } n.next = tempNode return true } // 在开头添加一个结点 func (n *Node) HeadAppend(data interface{}) bool { tempNode := &amp;Node{data, n.next} n.next = tempNode return true } // 查找一个结点, 返回其距离头结点的长度 func (n *Node) GetOneNode(i int) *Node { length := 0 for n.next != nil { length++ if i == length { return n.next } n = n.next } return nil } // 删除一个结点 func (n *Node) Delete(i int) *Node { length := 0 for n.next != nil { length++ if i == length { temp := n.next n.next = n.next.next return temp } n = n.next } return nil } func (n *Node) GetLinkLength() (length int) { for n.next != nil { length++ n = n.next } return length } // 插入一个结点 func (n *Node) Insert(i int, data interface{}) bool { needAppend := &amp;Node{data, nil} if i &gt; n.GetLinkLength() || i &lt; 1 { panic(&quot;插入位置错误&quot;) return false } length := 1 for n.next != nil { if i == length { temp := n.next n.next = needAppend needAppend.next = temp return true } } return false } // 在控制台按顺序打印出所有的元素 func (n *Node) MapTheLinkList() { length := n.GetLinkLength() for i := 0; i &lt; length; i++ { fmt.Println(n.next.data) n = n.next } } // 删除所有元素 func (n *Node) Clear() bool { if n.next == nil { return true } n.next = nil return true } 以下是测试的例子以及输出: func main() { li := SinglyLinkedList.InitLinkList() fmt.Println(li) li.EndAppend(&quot;aaa&quot;) li.HeadAppend(&quot;bbb&quot;) li.EndAppend(&quot;ccc&quot;) li.MapTheLinkList() fmt.Println(*li.GetFirstNode()) fmt.Println(*li.GetEndNode()) fmt.Println(li.GetLinkLength()) fmt.Println(&quot;delete = &quot;, li.Delete(1)) li.MapTheLinkList() li.Clear() fmt.Println(li) } // &amp;{The head node &lt;nil&gt;} // bbb // aaa // ccc // {bbb 0x140000a6048} // {ccc &lt;nil&gt;} // 3 // delete = &amp;{bbb 0x140000a6048} // aaa // ccc // &amp;{The head node &lt;nil&gt;} 更加复杂的双链表以及循环链表, 其实和单链表的原理相差不多, 下次再研究吧. 链式表示-例题 设计一个递归算法，删除不带头结点的单链表 L 中所有值为 x 的结点。 在带头结点的单链表 L 中，删除所有值为 x 的结点，并释放其空间，假设值为 x 的结点不唯一，试编写算法以实现上述操作。 设 L 为带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值。 试编写在带头结点的单链表 L 中删除一个最小值结点的高效算法(假设最小值结点是唯一的)。 试编写算法将带头结点的单链表就地逆置，所谓“就地” 是指辅助空间复杂度为 0(1)。 有一个带头结点的单链表 L,设计一个算法使其元素递增有序。 设在一个带表头结点的单链表中所有元素结点的数据值无序，试编写一个函数，删除表中所有介于给定的两个值(作为函数参数给出)之间的元素的元素(若存在)。 给定两个单链表，编写算法找出两个链表的公共结点。 给定一个带表头结点的单链表，设 head 为头指针，结点结构为(data, next)，data 为整型元素，next 为指针，试写出算法:按递增次序输出单链表中各结点的数据元素,并释放结点所占的存储空间(要求:不允许使用数组作为辅助空间)。 将一个带头结点的单链表 A 分解为两个带头结点的单链表 A 和 B,使得 A 表中含有原表中序号为奇数的元素,而 B 表中含有原表中序号为偶数的元素，且保持其相对顺序不变。 设 C= {a1, b1, a2, b2.,.,an, bn}为线性表，采用带头结点的 hc 单链表存放，设计一个就地算法，将其拆分为两个线性表，使得 A= {a1, a2,…,an}, B= {b1, b2,…,bn}。 在一个递增有序的线性表中，有数值相同的元素存在。若存储方式为单链表，设计算法去掉数值相同的元素,使表中不再有重复的元素,例如(7, 10, 10, 21, 30, 42, 42, 42, 51, 70)将变为(7, 10, 21, 30, 42,51, 70)。 假设有两个按元素值递增次序排列的线性表，均以单链表形式存储。请编写算法将这两个单链表归并为一个按元素值递减次序排列的单链表，并要求利用原来两个单链表的结点存放归并后的单链表。 设 A 和 B 是两个单链表(带头结点),其中元素递增有序。设计一个算法从 A 和 B 中的公共元素产生单链表 C,要求不破坏 A、B 的结点。 已知两个链表 A 和 B 分别表示两个集合，其元素递增排列。编制函数，求 A 与 B 的交集，并存放于 A 链表中。 两个整数序列 A=a1,a2,…,am 和 B= b1, b2,…,bn 已经存入两个单链表中，设计一个算法，判断序列 B 是否是序列 A 的连续子序列。 我的题解第一题 or 第二题/第七题每次判断下一个节点的值是否等于 x, 如果等于则舍弃. 然后使用下一个节点调用该函数. func (n *Node) DeleteX(x interface{}) { if n.next == nil { return } else { if n.next.data == x { n.next = n.next.next } n.next.DeleteX(x) } return } 第二题、第七题与本题基本相似. 第一题只用在前面加上自身的判断即可. 第三题使用递归, 首先使用下一个节点调用函数, 再输出当前节点的值. func (n *Node) PrintTail() { if n.next != nil { n.next.PrintTail() } fmt.Print(n.data, &quot; &quot;) } 第四题思路基本和顺序表相同, 就是使用两个指针, 一个指针用来遍历链表, 一个用来记录最小值 . 不过需要注意的是, 记录最小值需要记录最小节点的前驱节点, 也就是判断 min.next.data 是否为最小, 这样才便于删除. func (n *Node) DeleteMin() { var min, idx *Node min, idx = n, n if idx.next != nil { if idx.next.data.(int) &lt; min.next.data.(int) { min = idx } idx = idx.next } min.next = min.next.next return } 第五题就地逆置的核心思想就是在遍历过程中, 使用头插法依次重新插入一遍节点, 不过需要额外一个指针 next 来标明下一个节点的地址. func (n *Node) Reverse() { var idx, next *Node idx = n.next n.next = nil for idx != nil { next = idx.next // 保存下一个节点 idx.next = n.next n.next = idx // 头插法将当前节点加入到主链表中 idx = next // 处理下一个节点 } } 第六题采用自底向上归并排序的做法, 能够做到时间复杂度为 O(nlgn) 空间复杂度为 O(1) func (n *Node) SortList() *Node { if n == nil { return n } length := n.GetLinkLength() fmt.Println(length) l := n for curI := 1; curI &lt; length; curI &lt;&lt;= 1 { pre, cur := l, l.next for cur != nil { head1 := cur for i := 1; i &lt; curI; i++ { cur = cur.next } head2 := cur.next cur.next = nil cur = head2 for i := 1; i &lt; curI &amp;&amp; cur != nil &amp;&amp; cur.next != nil; i++ { cur = cur.next } var next *Node if cur != nil { next = cur.next cur.next = nil } pre.next = Merge(head1, head2) for pre.next != nil { pre = pre.next } cur = next } } return n } 第八题两个指针分别遍历两个链表, 如果遍历完了就到对方到链表中. 这样如果两个链表有相交, 则必定在指针遍历对方的链表时同时到达相交的位置. 两个结点不断的去对方的轨迹中寻找对方的身影，只要二人有交集，就终会相遇 ❤ func getIntersectionNode(list1, list2 *Node) *Node { l1, l2 := list1, list2 for l1 != l2 { if l1 != nil { l1 = l1.next } else { l1 = list2 } if l2 != nil { l2 = l2.next } else { l2 = list1 } } return l1 } 第九题没啥好说的, 就是调用了第六题的函数 func (n *Node) IncreasePrint() { n.SortList() cur := n for cur.next != nil { fmt.Print(cur.next.data, &quot; &quot;) cur = cur.next } fmt.Println() } 第十题 or 第十一题这道题只用在遍历时使用一个变量记录当前节点的奇偶, 然后分别赋值给两个新链表即可. 需要注意的是最后需要将两个链表的末尾节点的 next 指向 nil, 不然会出现错误. func ParitySplit(n *Node) (odd, even *Node) { odd, even = InitLinkList(), InitLinkList() o, e := odd, even cur, length := n, 0 for cur.next != nil { length++ if length%2 == 0 { e.next = cur.next e = e.next } else { o.next = cur.next o = o.next } cur = cur.next } o.next, e.next = nil, nil return } 而第十一题, 大致上是相同的, 不过注意偶数链表的节点是逆序的, 所以对于偶数链表我们可以使用头插法加入节点, 这样就可以实现逆序. 第十二题如果相同就跳过, 不相同就不管. func (n *Node) RemoveDuplicates() { cur := n.next for cur != nil &amp;&amp; cur.next != nil { if cur.data == cur.next.data { cur.next = cur.next.next } cur = cur.next } } 第十三题合并两个升序链表和合并两个升序顺序表差不多, 不多做赘述. func Merge(list1, list2 *Node) *Node { newList := &amp;Node{} l1, l2, nl := list1, list2, newList for l1 != nil &amp;&amp; l2 != nil { if l1.data.(int) &lt;= l2.data.(int) { nl.next = l1 l1 = l1.next } else { nl.next = l2 l2 = l2.next } nl = nl.next } if l1 != nil { nl.next = l1 } else { nl.next = l2 } return newList.next } 第十四题因为, 如果两个链表存在公共节点, 则公共节点后一定相同. 所以只需要获取两个链表的公共节点即可. func IntersectionNode(list1, list2 *Node) *Node { c := InitLinkList() c.next = getIntersectionNode(list1, list2) return c } 第十五题使用两个指针分别遍历两个链表, 如果相等则将其加入到 A 链表后, 由于都是递增排列, 所以如果小于, 则之后第元素都小于, 因此不存在相等的, 所以 A 的指针移动. 如果大于, 则可能 B 中会存在相等的, 所以 B 的指针移动. func (n *Node) Intersection(another *Node) { l1, l2 := n, another idx := n for l1.next != nil &amp;&amp; l2.next != nil { if l1.next.data.(int) == l2.next.data { idx.next = l1.next idx = idx.next l1 = l1.next l2 = l2.next } else if l1.next.data.(int) &lt; l2.next.data.(int) { l1 = l1.next } else { l2 = l2.next } } idx.next = nil } 第十六题类似于暴力版的字符串匹配, 遍历主链表的每一个元素, 如果相等则代表有机会是连续子序列. 所以创建两个指针遍历两个链表, 如果目标链表的指针到底了, 说明全部匹配, 则返回 true. 如果遍历到主链表的最后一个元素了,则说明无法匹配, 则返回 false func (n *Node) ContinuousSubsequence(target *Node) bool { cur := n for cur.next != nil { if cur.next.data.(int) == target.next.data { l1, l2 := cur.next, target.next for l1 != nil &amp;&amp; l2 != nil { if l1.data.(int) != l2.data.(int) { break } l1, l2 = l1.next, l2.next } if l2 == nil { return true } } cur = cur.next } return false }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"golang","slug":"golang","permalink":"/tags/golang/"},{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"LeetCode——173. 二叉搜索树迭代器","slug":"leetcode刷题(173. 二叉搜索树迭代器)","date":"2021-03-28T08:52:57.000Z","updated":"2024-03-02T16:13:05.071Z","comments":true,"path":"2021/03/28/leetcode刷题(173. 二叉搜索树迭代器)/","link":"","permalink":"/2021/03/28/leetcode刷题(173. 二叉搜索树迭代器)/","excerpt":"","text":"leetcode 刷题(173. 二叉搜索树迭代器)题目实现一个二叉搜索树迭代器类 BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。 boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。 int next()将指针向右移动，然后返回指针处的数字。注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。 你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。 实例输入 [“BSTIterator”, “next”, “next”, “hasNext”, “next”, “hasNext”, “next”, “hasNext”, “next”,”hasNext”] [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] 输出 [null, 3, 7,true, 9, true, 15, true, 20, false] 解释 BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.next();// 返回 3 bSTIterator.next(); // 返回 7 bSTIterator.hasNext(); // 返回 True bSTIterator.next(); //返回 9 bSTIterator.hasNext(); // 返回 True bSTIterator.next(); // 返回 15 bSTIterator.hasNext(); //返回 True bSTIterator.next(); // 返回 20 bSTIterator.hasNext(); // 返回 False 解题我的解法关于这道题, 我首先想到的是在数据传入时, 使用中序遍历保存整个顺序, 然后只用记录目前是遍历到哪一个结点即可. 以下是 Python3 和 Golang 的代码: class BSTIterator: def __init__(self, root: TreeNode): self.queue = [] self.idx = 0 self.inOrder(root) def next(self) -&gt; int: self.idx += 1 return self.queue[self.idx - 1] def hasNext(self) -&gt; bool: if self.idx &lt; len(self.queue): return True return False def inOrder(self, root: TreeNode): if root.left: self.inOrder(root.left) self.queue.append(root.val) if root.right: self.inOrder(root.right) type BSTIterator struct { queue []int idx int } func Constructor(root *TreeNode) BSTIterator { b := BSTIterator{} b.inOrder(root) return b } func (b *BSTIterator) Next() int { b.idx += 1 return b.queue[b.idx-1] } func (b *BSTIterator) HasNext() bool { if b.idx &lt; len(b.queue) { return true } return false } func (b *BSTIterator) inOrder(root *TreeNode) { if root.Left != nil { b.inOrder(root.Left) } b.queue = append(b.queue, root.Val) if root.Right != nil { b.inOrder(root.Right) } } 大佬的解法leetcode 大佬的解法(Python3)在迭代时计算 next 节点的值: 在设计迭代器时, 尽量避免提前把所有的值都取出来, 最好能设计成遍历过程中求 next 节点. 因此使用迭代来实现: 把递归转成迭代, 使用栈实现 迭代总体思路就是: 栈中只保留左节点 代码实现为: class BSTIterator(object): def __init__(self, root): self.stack = [] while root: self.stack.append(root) root = root.left def next(self): cur = self.stack.pop() node = cur.right while node: self.stack.append(node) node = node.left return cur.val def hasNext(self): return len(self.stack) &gt; 0 官方解答(Golang)思想基本相同, 都是通过栈实现每次调用 next 只用常熟时间. type BSTIterator struct { stack []*TreeNode cur *TreeNode } func Constructor(root *TreeNode) BSTIterator { return BSTIterator{cur: root} } func (it *BSTIterator) Next() int { for node := it.cur; node != nil; node = node.Left { it.stack = append(it.stack, node) } it.cur, it.stack = it.stack[len(it.stack)-1], it.stack[:len(it.stack)-1] val := it.cur.Val it.cur = it.cur.Right return val } func (it *BSTIterator) HasNext() bool { return it.cur != nil || len(it.stack) &gt; 0 }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"golang","slug":"golang","permalink":"/tags/golang/"},{"name":"LeetCode","slug":"LeetCode","permalink":"/tags/LeetCode/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"LeetCode——76. 最小覆盖子串","slug":"LeetCode题--最小覆盖子串","date":"2021-02-05T08:22:15.000Z","updated":"2024-03-02T16:13:04.046Z","comments":true,"path":"2021/02/05/LeetCode题--最小覆盖子串/","link":"","permalink":"/2021/02/05/LeetCode题--最小覆盖子串/","excerpt":"","text":"今天在清理以前没做完的 LeetCode 题目时, 发现了这么一道困难题… 于是开始写题时间 . 题目描述给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。 注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。 样例输入：s = “ADOBECODEBANC”, t = “ABC” 输出：”BANC” 写题最开始我想先用暴力解决, 然后慢慢优化.(万一暴力过了呢?😂) 以下是毫无参考意义的暴力解法: # 暴力写法，果然超时了 class Solution: def minWindow(self, s: str, t: str) -&gt; str: sc = Counter(s) tc = Counter(t) length, res = len(s), s def isHas(x: Counter, y: Counter) -&gt; bool: for item in y: if y[item] &gt; x[item]: return False return True if isHas(sc, tc): for i in range(length): for j in range(i, length + 1): print(&#39;s[i:j]: &#39;, s[i:j], end=&quot; &quot;) if res in s[i:j]: print(&#39;continue&#39;) continue idx = Counter(s[i:j]) if isHas(idx, tc): if len(res) &gt; len(s[i:j]): res = s[i:j] print(&#39;success&#39;) continue print(&#39;has but not less&#39;) print(&#39;not has&#39;) else: return &#39;&#39; return res 思路很暴力, 就是遍历所有子串. 去其中符合条件的最小的, 如果以前的答案包含在子串中 , 则这个子串不考虑. 然后想到了滑动窗口来优化, 于是走上了漫漫改 bug 之路. 发现自己写的滑动窗口还是超时了… 好丢人 # 没想到自己写的滑动窗口还是超时了...心累 class Solution: def minWindow(self, s: str, t: str) -&gt; str: length, res, left, right = len(s), s, 0, 0 def isHas(x: str, y: str) -&gt; bool: x, y = Counter(x), Counter(y) for item in y: if y[item] &gt; x[item]: return False return True if not isHas(s, t): return &#39;&#39; else: while right &lt;= length: si = s[left:right] print(&#39;si: &#39;, si) if isHas(si, t): while isHas(si, t): left += 1 si = s[left:right] print(&#39; left loop: &#39;, si) res = res if len(res) &lt; len(s[left - 1:right]) else s[left - 1:right] print(&quot; res: &quot;, res) right += 1 return res 自己最终改良的滑动窗口, 提交后终于是过了, 但是时间不是很理想, 只有 20% # 自己改良的滑动窗口，每次更新不重新生成Counter对象了，改为修改Counter对象的值... 这么想我刚才好蠢， # 但总算是能过了... 不容易呀 class Solution: def minWindow(self, s: str, t: str) -&gt; str: length, res, left, right = len(s), s, 0, 1 sc, tc = Counter(s), Counter(t) def isHas(x: Counter, y: Counter) -&gt; bool: for item in y: if y[item] &gt; x[item]: return False return True if not isHas(sc, tc): return &#39;&#39; else: sc = Counter() while right &lt;= length: sc[s[right - 1]] += 1 print(&#39;si: &#39;, s[left:right]) if isHas(sc, tc): while isHas(sc, tc): sc[s[left]] -= 1 left += 1 print(&#39; left loop: &#39;, s[left:right]) res = res if len(res) &lt; len(s[left - 1:right]) else s[left - 1:right] print(&quot; res: &quot;, res) right += 1 return res 最后学习题解大佬的解法. # 大佬的滑动窗口和我的滑动窗口为啥差别这么大呢。 # 瞬间 99.84% tql class Solution: def minWindow(self, s: str, t: str) -&gt; str: need = defaultdict(int) for c in t: need[c] += 1 needCnt = len(t) i = 0 res = (0, float(&#39;inf&#39;)) for j, c in enumerate(s): if need[c] &gt; 0: needCnt -= 1 need[c] -= 1 if needCnt == 0: # 步骤一：滑动窗口包含了所有T元素 while True: # 步骤二：增加i，排除多余元素 c = s[i] if need[c] == 0: break need[c] += 1 i += 1 if j - i &lt; res[1] - res[0]: # 记录结果 res = (i, j) need[s[i]] += 1 # 步骤三：i增加一个位置，寻找新的满足条件滑动窗口 needCnt += 1 i += 1 return &#39;&#39; if res[1] &gt; len(s) else s[res[0]:res[1] + 1] # 如果res始终没被更新过，代表无满足条件的结果","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"LeetCode","slug":"LeetCode","permalink":"/tags/LeetCode/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"/tags/滑动窗口/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Go源码学习(Gin 服务器端web框架)","slug":"Go源码学习(Gin 服务器端web框架)","date":"2021-01-28T09:07:15.000Z","updated":"2024-03-02T16:13:04.422Z","comments":true,"path":"2021/01/28/Go源码学习(Gin 服务器端web框架)/","link":"","permalink":"/2021/01/28/Go源码学习(Gin 服务器端web框架)/","excerpt":"","text":"Go 源码学习 –Gin 框架学习 Go 真是一个不可思议的事情, 不得不说果然配置环境是后端最难的事情. 我曾经为了 Java 环境困扰了一个星期, 如今也为 Go 的 module 模式配置了半天. 但是不得不说 Go 也是一个很魔幻的语言, 我第一次知道可以这么简单地创建一个后端服务器, 基本上学习 Gin 框架只用了 2 个小时… 差不多后端基础功能就知道是个怎么回事了. 但是学得这么快, 总感觉心里不踏实. 其实在学习的过程中, 基本都是使用大佬编写的轮子 . 然后感觉自己也没学什么东西, 于是打算开始学习源码, 来攀登巨人的高峰! 一个简单的 Demofunc main() { r := gin.Default() r.Run() } 由此我们可以看到, Gin 的基础功能可以分为两个阶段: Default()函数用来创建实例; Run()函数用来运行服务器. Gin 框架非常简洁, 仅仅使用了两个函数就能实现一个简单的服务器功能. 对比其他语言的后端框架可以称得上是精简了. 正是因为 Gin 已经帮我们把功能封装完毕了, 我们才需要去深入了解其原理. gin.Default()gin.Default()创建了一个Engine实例, 然后使用了Logger和Recovery中间件.gin.Default()和gin.New() 功能类似. 实际上, gin.Default()函数只是在调用了gin.New()基础上使用了engine.Use(Logger(),Recovery()), 接下来查看 gin.Defualt 源码. // 默认返回一个引擎实例, 并且已经连接了Logger和Recovery中间件. func Default() *Engine { debugPrintWARNINGDefault() engine := New() engine.Use(Logger(), Recovery()) return engine } 这里我们可以看到Default()函数实际上就是调用了New()函数, 所以我们不妨来看看New()函数. // New返回了一个新的空白Engine实例, 不附加任何中间件. func New() *Engine { debugPrintWARNINGNew() engine := &amp;Engine{ RouterGroup: RouterGroup{ Handlers: nil, basePath: &quot;/&quot;, root: true, }, FuncMap: template.FuncMap{}, RedirectTrailingSlash: true, RedirectFixedPath: false, HandleMethodNotAllowed: false, ForwardedByClientIP: true, AppEngine: defaultAppEngine, UseRawPath: false, RemoveExtraSlash: false, UnescapePathValues: true, MaxMultipartMemory: defaultMultipartMemory, trees: make(methodTrees, 0, 9), delims: render.Delims{Left: &quot;{{\", Right: \"}}&quot;}, secureJsonPrefix: &quot;while(1);&quot;, } engine.RouterGroup.engine = engine engine.pool.New = func() interface{} { return engine.allocateContext() } return engine } 可以看到实际上是初始化并返回了一个 Engine 对象. 再来看看Use()函数. // Use将全局中间件附加到路由器。 即通过Use()连接中间件. // 将每个请求都包含在处理程序链中, 甚至404、405，静态文件... // 例如, 这对于日志或者错误管理中间件是一个正确的位置. func (engine *Engine) Use(middleware ...HandlerFunc) IRoutes { engine.RouterGroup.Use(middleware...) engine.rebuild404Handlers() engine.rebuild405Handlers() return engine } 可以看到, 实际上也是调用了engine.RouterGroup.Use()函数来存放中间件. 我们不妨看看这个函数: // 将中间件存放在Group中, 并返回这个Group func (group *RouterGroup) Use(middleware ...HandlerFunc) IRoutes { group.Handlers = append(group.Handlers, middleware...) return group.returnObj() } Run()// Run()函数将路由器附加到 http.Server上, 并开始侦听和处理请求. // 这是http.ListenAndServe(addr, router)的快捷使用方法 // 注意: 该方法将无限期阻止调用goroutine, 除非发生错误 func (engine *Engine) Run(addr ...string) (err error) { defer func() { debugPrintError(err) }() address := resolveAddress(addr) debugPrint(&quot;Listening and serving HTTP on %s\\n&quot;, address) err = http.ListenAndServe(address, engine) return } 在 Go 中只要实现 ServeHTTP 就可以, 所以我们看一看: // ServeHTTP符合http.Handler接口 func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { c := engine.pool.Get().(*Context) c.writermem.reset(w) c.Request = req c.reset() engine.handleHTTPRequest(c) engine.pool.Put(c) } 这个函数描述了处理的流程: 请求来了, 从engine.pool中获取一个空的context, 丢入engine.handelHTTPRequest()中处理, 然后回收. 我们查看一下这个函数. func (engine *Engine) handleHTTPRequest(c *Context) { httpMethod := c.Request.Method rPath := c.Request.URL.Path unescape := false if engine.UseRawPath &amp;&amp; len(c.Request.URL.RawPath) &gt; 0 { rPath = c.Request.URL.RawPath unescape = engine.UnescapePathValues } if engine.RemoveExtraSlash { rPath = cleanPath(rPath) } // 查找给定HTTP方法的树的根 t := engine.trees for i, tl := 0, len(t); i &lt; tl; i++ { if t[i].method != httpMethod { continue } root := t[i].root // 在树中查找路由 value := root.getValue(rPath, c.Params, unescape) if value.handlers != nil { c.handlers = value.handlers c.Params = value.params c.fullPath = value.fullPath c.Next() c.writermem.WriteHeaderNow() return } if httpMethod != &quot;CONNECT&quot; &amp;&amp; rPath != &quot;/&quot; { if value.tsr &amp;&amp; engine.RedirectTrailingSlash { redirectTrailingSlash(c) return } if engine.RedirectFixedPath &amp;&amp; redirectFixedPath(c, root, engine.RedirectFixedPath) { return } } break } if engine.HandleMethodNotAllowed { for _, tree := range engine.trees { if tree.method == httpMethod { continue } if value := tree.root.getValue(rPath, nil, unescape); value.handlers != nil { c.handlers = engine.allNoMethod serveError(c, http.StatusMethodNotAllowed, default405Body) return } } } c.handlers = engine.allNoRoute serveError(c, http.StatusNotFound, default404Body) } 大致的流程就是从路由里找出 handler, 然后进行处理. 其中路由使用 httprouter 实现，使用的数据结构是基数树(radix tree).","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"golang","slug":"golang","permalink":"/tags/golang/"},{"name":"Gin","slug":"Gin","permalink":"/tags/Gin/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Vue + Django 实现在线音频分析平台(三)","slug":"在线音频分析平台(三)","date":"2021-01-21T02:07:15.000Z","updated":"2024-03-02T16:13:05.001Z","comments":true,"path":"2021/01/21/在线音频分析平台(三)/","link":"","permalink":"/2021/01/21/在线音频分析平台(三)/","excerpt":"","text":"在线音频分析平台(后端设计)源码展示于 github: 前端项目:https://github.com/Zranshi/Audio-analysis-web-client后端项目:https://github.com/Zranshi/Audio-analysis-web-server 本章节我们主要探讨本项目的前端设计的部分. 本项目的后端主要做了两件事, 一是处理来自前端的 http 请求. 二是处理音频文件,将数据保存并返回响应. http 请求以及响应我们的上网流程大致来说是这样的： 我们打开浏览器，在地址栏输入我们想访问的网址，比如https://zranshi.github.io (当然你也可能从收藏夹里直接打开网站，但本质上都是一样的) 浏览器知道我们想要访问那个网址后，它在后台帮我们做了很多事情，主要就是把我们的访问意图包装成一个 http 请求，发给我们想要访问的网址所对应的服务器。通俗点说就是浏览器帮我们通知网站的服务器，说有人来访问你啦，访问的请求都写在 http 里了，你按照要求处理后告诉我，我再帮你回应他！ 网站服务器处理了 http 请求，然后生成一段 http 响应给浏览器，浏览器解读这个响应，把相关的内容在浏览器里显示出来，于是我们就看到了网站的内容。比如你访问了 GitHub 主页https://github.com 服务器接收到这个请求后他就知道用户访问的是首页，首页显示的是全部仓库列表，于是它从数据库里把仓库数据取出来，生成一个写着这些数据的 html 文档，包装到 http 响应里发给浏览器，浏览器解读这个响应，把 html 文档显示出来，我们就看到了仓库列表的内容。 因此，django 作为一个 web 框架，它的使命就是处理流程中的第二步，接收浏览器发来的 http 请求，返回相应的 http 响应。于是引出这么几个问题： 1.Django 如何接收 http 请求？Django 通过生成的文件目录下的 urls.py 文件来指定接收 http 请求. 可以在 urlpatterns 中配置接收请求的地址, Django 接收到请求后, 会从前往后依次匹配是否符合模式对应. 并在第一次匹配时返回响应. urlpatterns = [ path(&#39;admin/&#39;, admin.site.urls), url(r&#39;^get_wav/$&#39;, get_wav, name=&#39;get_wav&#39;), url(r&#39;^show_data/$&#39;, show_data, name=&#39;show_data&#39;), ] 注意在匹配过程中, Django 使用正则表达式来进行匹配的. 并且当用户输入 127.0.0.1:8000 时, Django 会自动将域名和端口号去掉, 然后将剩下的字符串于列表中的元素匹配. 2.Django 如何处理这个 http 请求？Django 每一个 view 函数的第一个参数都是 request . 因此我们在 view 的函数中处理 http 请求. 例如我们获取了一个音频文件上传的请求, 如果我们需要将它作为文件保存起来, 我可以在函数中将 request 请求的数据写入文件中. @require_http_methods([&#39;POST&#39;]) def get_wav(request): response = {} myFile = None for i in request.FILES: myFile = request.FILES[i] if myFile: dir_path = os.path.join(os.path.join(BASE_DIR, &#39;static&#39;), &#39;profiles&#39;) # 文件写入 with open(os.path.join(dir_path, &#39;test.wav&#39;), &#39;wb+&#39;) as destination: for chunk in myFile.chunks(): destination.write(chunk) response[&#39;state&#39;] = &#39;success&#39; else: response[&#39;state&#39;] = &#39;error&#39; return JsonResponse(response) 3.Django 如何生成 http 响应？在以上代码中, 我们可以看到最后返回了一个 JsonResponse 对象. 故而我们可以通过字典的形式将响应保存, 然后转换为 Json 返回给页面. 不仅仅是 Json 文件, Django 响应可以返回 HttpResponse 类及其子类, 具体可以返回: HttpResponse 类: 返回字符串 JsonResponse 类: 返回 Json 类型文件 StreamingResponse 类: 流式响应，返回大的文本文件 FileResponse 类: 流式响应，返回大的二进制文件 解决跨域问题什么是跨域请求所谓的跨域请求就是指：当前发起请求的域与该请求指向的资源所在的域不一样。这里的域指的是这样的一个概念：我们认为若协议 + 域名 + 端口号均相同，那么就是同域。 举个例子：假如一个域名为 aaa.cn 的网站，它发起一个资源路径为 aaa.cn/books/getBookInfo 的 axios 请求，那么这个请求是同域的，因为资源路径的协议、域名以及端口号与当前域一致（例子中协议名默认为 http，端口号默认为 80）。但是，如果发起一个资源路径为 bbb.com/pay/purchase 的 axios 请求，那么这个请求就是跨域请求，因为域不一致，与此同时由于安全问题，这种请求会受到同源策略限制。 由于使用了前后端分离的架构, 前端项目和后端项目不在同一个端口中. 故而会存在跨域问题, 需要设置来进行解决. 解决方法为了解决跨域问题, 我使用 django-cors-headers 插件来进行解决. 需要在 setting.py 中添加配置, 并将需要提交请求的地址添加进入白名单(白名单也可以使用正则表达式匹配) # 注册应用 INSTALLED_APPS = [ ... &#39;corsheaders&#39;, ... ] # 注册中间件 MIDDLEWARE = [ ... &#39;corsheaders.middleware.CorsMiddleware&#39;, ... ] #设置白名单 CORS_ORIGIN_WHITELIST = ( &#39;http://localhost:8080&#39;, &#39;http://127.0.0.1:8080&#39;, )","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"},{"name":"Django","slug":"Django","permalink":"/tags/Django/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Vue + Django 实现在线音频分析平台(二)","slug":"在线音频分析平台(二)","date":"2021-01-20T00:53:15.000Z","updated":"2024-03-02T16:13:05.071Z","comments":true,"path":"2021/01/20/在线音频分析平台(二)/","link":"","permalink":"/2021/01/20/在线音频分析平台(二)/","excerpt":"","text":"在线音频分析平台(前端设计)源码展示于 github: 前端项目:https://github.com/Zranshi/Audio-analysis-web-client后端项目:https://github.com/Zranshi/Audio-analysis-web-server 本章节我们主要探讨本项目的前端设计的部分. 由于我们需求的功能大致上是 上传-&gt;处理-&gt;展示 的流程, 所以需要我们完成: 上传文件、接收数据、展示处理后的信息, 这三个方面. 文件上传文件上传的大部分操作都在 &lt;el-upload&gt; 有响应的参数可以配置, 在此只讲解需要自己编写的钩子函数. 通过官方文档我们可以看到, &lt;el-upload&gt; 有如下几个钩子函数: 我仅使用了 before-upload、on-success 和 on-remove . 其中, before-upload 用于在上传之前进行判断, 在满足所有条件以后, 返回 true 则可以使上传操作正常进行, 如果为 false 则上传操作终止. 在此我们分别判断文件是否为 wav 类型, 是否小于 30MB , 上传列表个数是否 小于 1 . 如果不满足条件则会弹出错误窗口提醒用户. 每次上传成功后, 会触发 on-success 钩子, 因此我们可以在这个函数中将上传列表中的文件放入上传字典中. 之所以不把这个操作放在 before-upload 中进行, 是因为如果运行页面时服务器没有开启, 文件也将被放入上传字典中, 并且无法在页面上显示删除操作, 从而造成 bug, 但如果是将静态文件放入服务器中, 将没有影响. 在此之外, 为了保存每次上传的列表, 我使用了一个字典来保存每次上传文件的名称, 如果名称相同则会覆盖已有的文件. 如果不同, 则会增加新的键值对. 并且使用 Object.keys(this.fileDict).length 来获取字典的长度,并加以判断. 之所以选择用字典来保存上传文件的列表, 是因为我发现如果使用列表保存, 会使得删除时需要遍历一般整个列表才可以完成操作, 而字典则有很好的时间复杂度. on-remove 是为了在删除上传列表的某个文件时, 能够同步地删除字典中的键值对. methods: { before_upload(file) { const isMav = file.type === &#39;audio/x-wav&#39; || file.type === &#39;audio/wav&#39;; const isLt30M = file.size / 1024 / 1024 &lt; 30; const isNum = Object.keys(this.fileDict).length &lt; 1; if (!isMav) { this.$message.error(&#39;上传文件只能是wav音频文件格式！&#39;); } else if (!isLt30M) { this.$message.error(&#39;最大上传30MB大小的文件！&#39;); } else if (!isNum) { this.$message.error(`最多上传 1 个文件`); } return isMav &amp;&amp; isLt30M &amp;&amp; isNum }, handle_remove(file) { delete this.fileDict[`${file.name}`] }, handle_success(response, file) { this.fileDict[`${file.name}`] = file.name; }, }, 数据传输前端与后端进行数据传输一般使用 axios 封装和拦截请求请求. 虽然我被没有需要设置的地方, 但为了使代码看得更加简洁, 我还是进行了基础的封装. 其中 axios.js 封装和劫持了 http 数据, data.js 用来封装 api 接口. 为了封装 http 请求, 我们创建一个 HttpRequest 类来封装. 其中固定不变的参数写在构造函数中, 需要进行配置的参数可以在 getInsideConfig 中进行项目级配置. 对于每个不同的请求, 通过形参 options 来进行设置.对于所有的配置, 我使用 Object.assign() 函数来将配置结合起来. ( Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。 ) 对于每个请求, 我们都可以对其在 interceptors 函数中进行拦截. 但由于本项目没有过多的需求, 细节部分请自行设置. 由于我们总是要返回一个 axios 对象, 我们可以将该对象通过 request 函数生成, 并结合来所有配置的参数以及拦截. 最后返回 axios 对象. class HttpRequest { constructor(baseUrl) { this.baseUrl = baseUrl; this.queue = {}; } getInsideConfig() { return { baseUrl: this.baseUrl, header: { // 请求头配置 }, }; } interceptors(instance) { instance.interceptors.request.use(config =&gt; { // 处理config return config; }); instance.interceptors.response.use( res =&gt; { // 处理响应 return res; }, error =&gt; { // 请求出问题了，处理问题 console.log(error); return { error: &#39;网络出错了&#39; }; } ); } request(options) { // 创造实例对象 const instance = axios.create(); options = Object.assign(this.getInsideConfig(), options); this.interceptors(instance, options.url); return instance(options); } } 由于本项目现阶段只需要编写连个 api 接口, 一个是上传文件的 get_wav , 这个接口已经被封装在&lt;el-upload&gt; 中. 所以我只需要在 data.js 中封装获取数据的 show_data. export const show_data = () =&gt; { return axios.request({ url: `${axios.baseUrl}/show_data/`, method: &#39;get&#39;, }); }; 接下来就可以在页面中调用了. 由于数据量可能过大, 为了防止点击按钮后页面停滞不动, 我采用了异步调用的方式. async get_data() { let res = await show_data() res = res[&#39;data&#39;] // wav音频文件信息部分 this.audio_parmas = res[&#39;audio_params&#39;]; // 波形图部分 this.wave_data_l = res[&#39;data&#39;][0]; this.wave_data_r = res[&#39;data&#39;][1]; this.x = res[&#39;time&#39;]; // 频谱图部分 this.xfp = res[&#39;xfp&#39;]; this.freq = res[&#39;freq&#39;]; }, 展示数据关于数据展示, 我觉得有困难的无非就是两点. 一是数据的传输, 包括从后端将处理的数据传输到前端, 和将数据从父组件中传入到子组件; 二是实现图表的动态绑定, 能够在传入数据时修改图表并能够自适应窗口的改变. 由于前后端之间的数据传输已经在上节讲述过了, 这里我们探讨父组件向子组件的传值. 父组件注册子组件后, 可以在子组件标签中判定自定义属性: &lt;!--波形图，横轴为时间，纵轴为幅度--&gt; &lt;waveform title=&quot;音频分析波形图&quot; :data_l=&quot;wave_data_l&quot; :data_r=&quot;wave_data_r&quot; :x=&quot;x&quot; v-if=&quot;radio === &#39;1&#39;&quot; &gt;&lt;/waveform&gt; &lt;!--频谱图，横轴为频率，纵轴为幅度--&gt; &lt;spectrogram title=&quot;音频分析频谱图&quot; :data=&quot;xfp&quot; :x=&quot;freq&quot; v-if=&quot;radio === &#39;2&#39;&quot;&gt;&lt;/spectrogram&gt; 以 v-bind 方式将值绑定到子组件. 然后子组件在 props 属性中接收 props: { title: {type: String, default: &#39;未赋值的标题&#39;}, x: {type: Array}, data: {type: Array}, }, 由于主组件的数据修改无法影响到 echart 实例的数据, 因此实现动态数据绑定需要我们自己完成. 我们可以使用 watch 来监听数据的变化, 如果变化了, 就将 option 更新, 然后调用 echart.setOption 函数即可实现 echart 图表的更新了. watch: { data: { handler() { this.option.series[0].data = this.data; this.option.xAxis.data = this.x; this.chart.setOption(this.option); }, } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"},{"name":"Django","slug":"Django","permalink":"/tags/Django/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Vue + Django 实现在线音频分析平台(一)","slug":"在线音频分析平台(一)","date":"2021-01-19T07:03:15.000Z","updated":"2024-03-02T16:13:05.043Z","comments":true,"path":"2021/01/19/在线音频分析平台(一)/","link":"","permalink":"/2021/01/19/在线音频分析平台(一)/","excerpt":"","text":"在线音频分析平台 (需求分析设计, 页面设计)源码展示于 github: 前端项目:https://github.com/Zranshi/Audio-analysis-web-client后端项目:https://github.com/Zranshi/Audio-analysis-web-server 本章节中我们主要探讨本项目的需求分析以及项目设计还有页面设计等部分. 需求分析设计总体来说, 就是设计一个在线音频分析平台, 但是平台这么空洞的话, 不说清楚的话谁知道具体有什么功能呢. 所以打算在开始写代码之前, 先研究一下需要什么功能, 才好开始编写项目. 具我和做人工智能的学长甲方讨论, 大致的需求分为一下几点: 有一个还算良好的页面设计 具有上传音频文件的功能(现阶段仅限.wav 类型文件) 能够分析音频文件的数据, 包括展示音频文件的数据参数 能够通过图表的形式展示音频文件数据, 具体分为一下几种图: 波形图. 横轴为时间, 纵轴为幅度 频谱图. 横轴为频率, 纵轴为响度 语谱图. 横轴为时间, 纵轴为频率, 还需要在图上用 RGB 颜色表示能量强度 (1.0 版本未实现) 功率图. 横轴为频率, 纵轴为功率 (1.0 版本未实现) 能够将分析音频文件的图表用图片保存到本地 能够差异化表示不同的文件, 以此分析特征差异 (1.0 版本未实现) 这么看下来, 这些需求还是挺复杂的. 但其实在前端 Vue 和后端 Django 的基础知识掌握以后, 最复杂的应该只是怎么获得图表文件数据上面, 就连绘制图表都有一定的重复性, 可以通过 Vue 组件来简单实现复用. 技术栈Vue + Django + EChart + Axios + Element-ui + Numpy 其中 Vue 用来制作前端页面 Django 用来搭建服务器 Axios 用来发送请求, 使前后端数据交流 使用 Element-ui 的组件, 方便页面设计 Numpy 用来进行数据处理 所需的技术说完了, 现在让我们正式开始制作在线音频分析平台 页面设计相信 Vue 和 node.js 的安装不必多说, 在此已经假设您已经成功安装 Vue 和 node.js 并能够使用 Vue Cli 创建项目了. 那让我们正式开始前端项目的编写! 1.页面布局首先展示我设计的页面: 由此可以体现出 UI 库的好处了, 大部分组件都不需要我自己编写, 可以使用现成的 UI 组件来设计自己喜欢的页面. 那么我们现在就开始来设计页面吧!! 在 view 文件夹中创建 home.vue 页面, 由于我们的项目只需要一个页面, 因此所有的内容都是写在这个页面中的. 首先设计布局, 我是使用的 element-ui 的布局容器将页面分成了上下两部分. 上部分是标题,在 &lt;el-header&gt;中; 下部分是业务逻辑处理部分, 在 &lt;el-main&gt; 中. 接下来可以看到的就是 图表类型选择、上传文件 和 文件信息 这三个组件了 . 这三个组件是使用基础布局( 也就是 &lt;el-row&gt; 和 &lt;el-col&gt; )来进行布局的. 有关于布局的相关知识请查看布局 然后让我们依次介绍每个组件: 2.图表类型选择图表类型选择 使用了 element-ui 中的 &lt;el-radio&gt; , 由于每次只选择一种图表, 所以使用单选框最为实用. &lt;el-col :span=&quot;5&quot;&gt; &lt;template&gt; &lt;p&gt;&lt;/p&gt; &lt;el-radio v-model=&quot;radio&quot; label=&quot;1&quot;&gt;波形图&lt;/el-radio&gt; &lt;el-radio v-model=&quot;radio&quot; label=&quot;2&quot;&gt;频谱图&lt;/el-radio&gt; &lt;/template&gt; &lt;/el-col&gt; 其中 v-model 绑定的数据可以随着选择某个单选项的 label 而改变. 具体用法请查阅单选框 3.上传文件上传文件 使用了 element-ui 中的 &lt;el-upload&gt; , 用于文件的上传. &lt;el-col :span=&quot;14&quot; style=&quot;display: flex; justify-content: center;&quot;&gt; &lt;el-upload class=&quot;upload-demo&quot; drag ref=&quot;upload&quot; multiple action=&quot;http://127.0.0.1:8000/get_wav/&quot; accept=&quot;.wav&quot; name=&quot;file&quot; :limit=&quot;1&quot; :file-list=&quot;fileList&quot; :auto-upload=&quot;true&quot; &gt; &lt;i class=&quot;el-icon-upload&quot;&gt;&lt;/i&gt; &lt;div class=&quot;el-upload__text&quot;&gt;将文件拖到此处，或&lt;em&gt;点击上传&lt;/em&gt;&lt;/div&gt; &lt;div class=&quot;el-upload__tip&quot; slot=&quot;tip&quot;&gt; 只能上传 1 个wav文件,若要重新上传,请删除当前文件或刷新页面！ &lt;/div&gt; &lt;/el-upload&gt; &lt;/el-col&gt; 其中 action 参数为后端接收上传文件的地址. 其余需要修改的请查看上传 4.文件信息展示文件信息展示 使用了 element-ui 的 &lt;el-card&gt; 用于将信息聚合在卡片容器中展示 . &lt;el-col :span=&quot;5&quot;&gt; &lt;div&gt; &lt;el-button type=&quot;primary&quot; round @click=&quot;show_data&quot; &gt;上传文件&lt;i class=&quot;el-icon-upload el-icon--right&quot;&gt;&lt;/i&gt; &lt;/el-button&gt; &lt;/div&gt; &lt;br /&gt;&lt;br /&gt; &lt;div&gt; &lt;el-card class=&quot;card&quot;&gt; &lt;b style=&quot;display: flex; justify-content: center&quot;&gt;wav文件信息&lt;/b&gt; &lt;p&gt;声道数量 : {{ audio_parmas[0] }}&lt;/p&gt; &lt;p&gt;量化位数 : {{ audio_parmas[1] }}&lt;/p&gt; &lt;p&gt;采样频率 : {{ audio_parmas[2] }}&lt;/p&gt; &lt;p&gt;采样点数 : {{ audio_parmas[3] }}&lt;/p&gt; &lt;/el-card&gt; &lt;/div&gt; &lt;/el-col&gt; 5.图表展示我使用 EChart 来绘制图表, ECharts 是一个使用 JavaScript 实现的开源可视化库，涵盖各行业图表，满足各种需求. 这里我是用 Vue 的组件来将 Echart 封装成一个个组件, 达到复用的效果. &lt;div&gt; &lt;el-card class=&quot;box-card&quot;&gt; &lt;!--波形图，横轴为时间，纵轴为幅度--&gt; &lt;line-graph title=&quot;音频分析波形图&quot; :data_l=&quot;wave_data_l&quot; :data_r=&quot;wave_data_r&quot; :x=&quot;x&quot; v-if=&quot;radio === &#39;1&#39;&quot; &gt; &lt;/line-graph&gt; &lt;!--频谱图，横轴为频率，纵轴为幅度--&gt; &lt;bar-graph title=&quot;音频分析频谱图&quot; :data=&quot;xfp&quot; :x=&quot;freq&quot; v-if=&quot;radio === &#39;2&#39;&quot;&gt;&lt;/bar-graph&gt; &lt;/el-card&gt; &lt;/div&gt;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"/tags/Vue/"},{"name":"Django","slug":"Django","permalink":"/tags/Django/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"纯音乐分享Maria and the Violin's String","slug":"纯音乐《Maria and the Violin's String》分享","date":"2021-01-05T03:43:14.000Z","updated":"2024-02-24T12:27:19.235Z","comments":true,"path":"2021/01/05/纯音乐《Maria and the Violin's String》分享/","link":"","permalink":"/2021/01/05/纯音乐《Maria and the Violin's String》分享/","excerpt":"","text":"《Maria and the Violin’s String》推荐一首最近常听的纯音乐《Maria and the Violin’s String》歌曲封面以及作者如下 喜欢这首纯音乐是因为，它很容易使人沉浸在自己正在做的事情当中，不是很能分辨出哪些乐器构造出了这首纯音乐。我想大概有钢琴，小提琴。很多纯音乐都是由重复的乐章构成的，这首也是，但是重复却不无聊，每个乐章是相同的音却有不同的力量。 乐曲一开始即是重复的旋律，就像一个人走在长长的尽头闪着光亮的走廊，怀着憧憬激动的心，开始了他的旅程。如同人生一般，走在路上。后来几种乐器一同奏响，彼此交织，就像孤独的人生之旅中遇上的同伴们，彼此成长，一起前行。再后来主乐器声音更加突出，不再是几种乐器一同奏响。像极了参与我们的人生，陪伴我们一段旅程之后而走的人们，我们终究会一个人走在路上。如此往复，有人到来，有人失去。最后缓慢而悠长的乐曲，似一个年迈的老人，回顾着他的一生，充满了不舍，多彩而又难忘。 或许重复即为人生，得到和失去也为并行不悖的。 以上为个人听歌之想，好的乐曲还需要自己去聆听，去寻找。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"音乐","slug":"音乐","permalink":"/tags/音乐/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"关系型数据库期末复习","slug":"数据库基础复习","date":"2020-12-23T11:02:47.000Z","updated":"2024-03-02T16:13:04.022Z","comments":true,"path":"2020/12/23/数据库基础复习/","link":"","permalink":"/2020/12/23/数据库基础复习/","excerpt":"","text":"关系传统的集合运算：并、差、交、笛卡儿积、笛卡儿积的逆运算（除） 专门的的关系运算：选择、投影、连接（等值连接、自然连接） 五种基本运算：并、差、笛卡儿积、选择、投影 选择选择是对单个表的运算，逻辑条件限制单个表中的特定元组，并将其选择出来。 投影投影是从单个表中选取相应的若干属性列，形成新的关系。投影后会自动消除重复的元组 连接连接是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。 连接运算中有两种最为重要也最为常用的连接，一种是等值连接，另一种是自然连接。等值连接是选取 A，B 中属性值相等的元组。自然连接要求比较的分量必须是同名的属性组，选取相同属性名值相同的项相连接，并且在结果中把重复的属性列去掉。其中，公共属性值不相同的元组会被舍弃，这些被舍弃的元组成为悬浮元组 如果保存悬浮元组，其它属性上填写（NULL），则称为外连接。 除运算R 除以 S 的结果为 T 则 T 包含所有在 R 但不在 S 中的属性及其值，且 T 的元组与 S 的元组的所有组合都在 R 中。 数据库设计E-R 图E-R 图又称实体关系图，是一种提供了实体，属性和联系的方法，用来描述现实世界的概念模型。通俗点讲就是，当我们理解了实际问题的需求之后，需要用一种方法来表示这种需求，概念模型就是用来描述这种需求。 E-R 图中的基本元素1）实体实际问题中客观存在的并且可以相互区别的事物称为实体。实体是现实世界中的对象，可以具体到人，事，物。 2）属性实体所具有的某一个特性称为属性，在 E-R 图中属性用来描述实体。 3）实体集具有相同属性的实体的集合称为实体集。 4）键在描述实体集的所有属性中，可以唯一标识每个实体的属性称为键。键也是属于实体的属性，作为键的属性取值必须唯一且不能“空置”。 5）联系世界上任何事物都不是孤立存在的，事物内部和事物之间都有联系的，实体之间的联系通常有 3 种类型：一对一联系，一对多联系，多对多联系。 E-R 图绘画规范1）矩形框：表示实体，在框中记入实体名。 2）菱形框：表示联系，在框中记入联系名。 3）椭圆形框：表示实体或联系的属性，将属性名记入框中。对于主属性名，则在其名称下划一下划线。 4）连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。（对于一对一联系，要在两个实体连线方向各写 1； 对于一对多联系，要在一的一方写 1，多的一方写 N；对于多对多关系，则要在两个实体连线方向各写 N，M) 关系范式分类1NF定义：设 R 是一个关系模式，如果 R 中的每一个属性 A 的值域中的每个值都是不可分解的，则称 R 是属于第一范式的，记作 R ∈ 1NF。 完成第一范式（1NF），就是将所有数据项都分解成不可再分的最小数据项就可以了。例如将关系 SA（姓名，工资）关系，改为 SA（姓名，基本工资，奖金，补贴）即可。 2NF定义：如果关系 R ∈ 1NF，并且 R 中每一个非主属性完全函数依赖于任一个候选码，则 R ∈ 2NF。 从定义可以看出，若某个 1NF 的关系的主码只由一个列组成，那么这个关系就是 2NF 关系。但是，如果主码是由多个属性列共同组成的复合主码，并且存在非主属性对属性的部分函数依赖，则这个关系不是 2NF 关系。 分解：可以用模式分解的方法将非 2NF 的关系模式分解为多个 2NF 的关系模式。去掉部分函数依赖关系的分解过程如下： 用组成主码的属性集合的每一个子集作为主码构成一个表。 对于每个表，将依赖于此主码的属性放置到此表中。 3NF定义：如果关系 R ∈ 2NF，并且 R 中每一个非主属性对任何候选码都不存在传递函数依赖，则 R ∈ 3NF 。 从定义中可以看出，如果存在非主属性对主码的传递依赖，则相应的关系模式就不是 3NF。 分解：去掉传递函数依赖的分解过程如下： 对于不是候选码的每个决定因子，从关系模式中删除依赖于该决定因子的属性。 新建一个关系模式，新的关系模式中应包含在原表中所有依赖于该决定因子的属性。 将决定因子作为新关系模式的主码。 BCNF（仅作了解）BCNF，全称为 Boyce Codd Normal Form，中文叫巴斯范式/鲍依斯-科得范式，是由 Boyce 和 Codd 提出的,比 3NF 又进了一步,通常认为是修正的第三范式。 满足条件： 所有非主属性对每一个候选键都是完全函数依赖； 所有的主属性对每一个不包含它的候选键，也是完全函数依赖； 没有任何属性完全函数依赖于非候选键的任何一组属性。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"sql","slug":"sql","permalink":"/tags/sql/"},{"name":"关系型数据库","slug":"关系型数据库","permalink":"/tags/关系型数据库/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"面向对象方法学概念汇总","slug":"面向对象方法学","date":"2020-12-22T12:59:47.000Z","updated":"2024-03-02T16:13:05.018Z","comments":true,"path":"2020/12/22/面向对象方法学/","link":"","permalink":"/2020/12/22/面向对象方法学/","excerpt":"","text":"1.软件开发方法学的基本方法 软件工程和瀑布方法学 新方法学：螺旋式、迭代式、递增式、合并式 面向对象方法学：UML、RUP、XP 2.简述重定义与重载的区别重载(Overload) 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。重写(Override) 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。 override（重写） 方法名、参数、返回值相同。 子类方法不能缩小父类方法的访问权限。 子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。 存在于父类和子类之间。 方法被定义为 final 不能被重写。 overload（重载） 参数类型、个数、顺序至少有一个不相同。 不能重载只有返回值不同的方法名。 存在于父类和子类、同类中。 3.发现对象属性有哪些策略 按一般常识这个对象应该有哪些属性对象的某些属性，按一般常识就可以知道，例如人的姓名、职业、地址、电话等属性，但要注意，按照一般常识发现的属性未必都有用应该在审查时去掉。 在当前的问题域中，这个对象应该有哪些属性对象的某些属性，只有认真研究问题域才能得到例如商品的条形码。 根据系统责任的要求，这个对象应具有哪些属性 建立这个对象是为了保存和管理哪些信息 对象为了在服务中实现其功能，需要增设哪些属性 对象有哪些需要区别的状态，是否增加一个属性来区别这些状态 用什么属性来表示整体-部分结构和实例连接 4.你是如何理解多态的官方版： 接口的多种不同的实现方式即为多态。 多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术。 我们在程序中定义的引用变量所指向的具体类型和通过该引用变量的方法调用在编程的时候并不确定，当处于运行期间才确定。就是这个引用变量究竟指向哪一个实例对象，在编译期间是不确定的，只有运行期才能确定，这样不用修改源码就可以把变量绑定到不同的类实例上，让程序拥有了多个运行状态，这就是多态。 人话版： 允许将子类类型的指针赋值给父类类型的指针，把不同的子类对象都当作父类来看。比如你家有亲属结婚了，让你们家派个人来参加婚礼，邀请函写的是让你爸来，但是实际上你去了，或者你妹妹去了，这都是可以的，因为你们代表的是你爸，但是在你们去之前他们也不知道谁会去，只知道是你们家的人。可能是你爸爸，可能是你们家的其他人代表你爸参加。这就是多态。 5.面向对象有哪些设计原则 单一职责原则（Single Responsibility Principle）每一个类应该专注于做一件事情。 里氏替换原则（Liskov Substitution Principle）超类存在的地方，子类是可以替换的。 依赖倒置原则（Dependence Inversion Principle）实现尽量依赖抽象，不依赖具体实现。 接口隔离原则（Interface Segregation Principle）应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。 迪米特法则（Law Of Demeter）又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。 开闭原则（Open Close Principle）面向扩展开放，面向修改关闭。 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。 6.简述 OOA 的主要任务是什么 确定对象和类。这里所说的对象是对数据及其处理方式的抽象，它反映了系统保存和处理现实世界中某些事物的信息的能力。类是多个对象的共同属性和方法集合的描述，它包括如何在一个类中建立一个新对象的描述。 确定结构（structure）。结构是指问题域的复杂性和连接关系。类成员结构反映了泛化-特化关系，整体-部分结构反映整体和局部之间的关系。 确定主题（subject）。主题是指事物的总体概貌和总体分析模型。 确定属性（attribute）。属性就是数据元素，可用来描述对象或分类结构的实例，可在图中给出，并在对象的存储中指定。 确定方法（method）。方法是在收到消息后必须进行的一些处理方法：方法要在图中定义，并在对象的存储中指定。对于每个对象和结构来说，那些用来增加、修改、删除和选择一个方法本身都是隐含的（虽然它们是要在对象的存储中定义的，但并不在图上给出），而有些则是显示的。 7.抽象类与接口的联系与区别比较图片 相同点： 都不能被实例化。 接口的实现类和抽象类的子类只有全部实现了接口或者抽象类中的方法后才可以被实例化。 不同点： 接口只能定义抽象方法不能实现方法，抽象类既可以定义抽象方法，也可以实现方法。 单继承，多实现。接口可以实现多个，只能继承一个抽象类。 接口强调的是功能，抽象类强调的是所属关系。 接口中的所有成员变量 为 public static final， 静态不可修改，当然必须初始化。接口中的所有方法都是 public abstract 公开抽象的。而且不能有构造方法。抽象类就比较自由了，和普通的类差不多，可以有抽象方法也可以没有，可以有正常的方法，也可以没有。 8.简述方法覆盖（重定义）的三种情况9.简述你是如何理解封装的封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节，但可以通过该对象对外的提供的接口来访问该对象。 官方版：封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。 10.你是如何理解对象的概念所谓对象就是真实世界中的实体，对象与实体是一一对应的，也就是说现实世界中每一个实体都是一个对象，它是一种具体的概念。对象有以下特点： 对象具有属性和行为。 对象具有变化的状态。 对象具有唯一性。 对象都是某个类别的实例。 一切皆为对象，真实世界中的所有事物都可以视为对象。 11.深拷贝与浅拷贝的联系与区别浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。深拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，无论该字段是值类型的还是引用类型，都复制独立的一份。当你修改其中一个对象的任何内容时，都不会影响另一个对象的内容。 12.简述建立用例模型的步骤 标识系统参与者 标识系统用例 用例的关系 系统用例的细节 前置条件与后置条件 辅助需求 用例的优先级 13.简述面向对象的特点 抽象：指将具有一致的数据结构和行为的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。 封装：把对象的属性和操作结合成一个独立的系统单位，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 继承：继承是指一种能力，它可以使用现有类的所有功能，并在无需重新编写原来类的情况下对这些功能进行扩展。通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。 多态：不同的子类对象调用相同的方法，产生不同的执行结果。面向对象系统的多态性是指统一操作作用于不同的类的实例，将产生不同的执行结果，即是不同的类的对象收到相同的消息时得到不同的结果。实现多态，有两种方式，覆盖和重载。覆盖在运行时决定，重载是在编译时决定。并且覆盖和重载的机制不同。 14.什么是消息（message）消息就是向对象发出的服务请求。它包含了提供服务的对象标识、服务(方法)标识、输人信息和回答信息等。 面向对象方法的一个原则就是通过消息进行对象之间的通信。初学面向对象方法的人往往把消息等同于函数调用，事实上两者之间存在区别。消息可以包括同步消息和异步消息，如果消息是异步的，则一个对象发送消息后，就继续自己的活动，不等待消息接收者返回控制，而函数调用往往是同步的，消息的发送者要等待接收者返回。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"面向对象方法学","slug":"面向对象方法学","permalink":"/tags/面向对象方法学/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Python设计网上书店信息管理系统","slug":"网上书店信息管理系统","date":"2020-12-12T12:56:47.000Z","updated":"2024-03-02T16:13:05.071Z","comments":true,"path":"2020/12/12/网上书店信息管理系统/","link":"","permalink":"/2020/12/12/网上书店信息管理系统/","excerpt":"","text":"课程需求分析课题意义近年来，随着 Internet 的迅速发展，互联网已日益成为收集提供信息的最佳渠道。于是网上购物开始流行起来，越来越多的商家在网上建起在线商店，向消费者展现出一种新颖的购物理念。网络书店系统提供网上购书的渠道，在其商务活动中起着举足轻重的作用。而网络书店的后台信息管理无疑是重中之重。有了一个好的信息管理系统，不仅能方便地查阅网上书店的收入营收情况，更是能有效地分析用户数据情况，得到有效的的改善。该课程设计要求设计一个网络书店信息管理系统，数据库中要求包含书籍、订单和用户的一些信息。同时还要设计它们之间的关系，如用户与购买书籍之间的关系等，最后还要对数据进行查询，如查询书籍、订单和用户的信息等。本人们通过该课程设计，应该达到的目的是把数据库理论知识更加的巩固加深，加强动手能力与实践能力，学以致用，与现实生活中的应用充分的结合起来。 课题目的应用对数据库系统原理的理论学习，通过上机实践的方式将理论知识与实践更好的结合起来，巩固所学知识。 数据库应用课程实践实践和巩固在课堂教学中学习的关于数据库的有关知识，熟练掌握对数据库的创建、基本操作、程序系统的建立和调试以及系统评价。 数据库原理软件设计实践实践和巩固在课堂教学中学习的关于关系数据库原理的有关知识和数据库系统的建立方法，熟练掌握对于给定实际问题，为了建立一个关系数据库信息管理系统，必须得经过系统调研、需求分析、概念设计、逻辑设计、物理设计、系统调试、维护以及系统评价的一般过程。 系统分析总体需求简单介绍需求分析阶段是数据库应用系统开发的最重要阶段。需求分析要求应用系统的开发人员按照系统的思想，根据收集的资料，对系统目标进行分析，对业务的信息需求、功能需求以及管理中存在的问题等进行分析，抽取本质的、整体的需求，为设计一个结构良好的数据库应用系统的逻辑模型奠定坚实的基础。网上书店信息管理系统是网上书店不可缺少的一部分。一个功能齐全、简单易用的信息管理系统不仅能有效减轻管理人员的工作量，其内容对网上书店的决策者来说也非常重要。因此，网上书店信息管理系统应该能够为用户提供足够的信息和快速的查询手段。然而，人们一直使用传统的手动方式来管理文件、统计数据和查询数据。随着科学技术的不断进步，计算机科学越来越成熟。它强大的功能已经被人们深深地认识到。它已经进入人类社会的各个领域，发挥着越来越重要的作用。作为计算机应用的一部分，利用计算机管理网上书店信息具有人工管理无法比拟的优势。本系统完成网上书店中书籍、订单和用户的信息查询和创建。 用户总体业务构造网上书店信息管理系统，包括 3 个主要部分：书籍信息的管理；订单信息的管理；用户的管理；各部分具体的内容： 书籍信息的管理包括：管理员管理书籍信息，如若要加入新书，则创建新书，并返回相应的出版商。 订单信息的管理包括：管理员管理订单信息，可以通过录入订单中的用户和书籍编号，直接插入数据。 用户信息的管理包括：后台管理员管理用户信息，如若有用户需求创建新用户。则可以批改审核后然后创建新用户。 数据库设计概念结构设计实体概念设计就是通过对需求分析阶段所得到的信息需求进行综合、归纳与抽象，形成一个独立于具体数据库管理系统的概念模型，主要的手段为 ER 图。在概念设计阶段，主要采用的设计手段目前还是实体联系模型(E-R Model)。绘制 E-R 图的关键是确定 E-R 图的各种结构，包括实体、属性和联系。大部分的流行建模工具(PowerDesigner、Oracle Designer、ERwin 等)也都包含了对 E-R 设计手段的支持。要建立系统的 E-R 模型的描述，需进一步从数据流图和数据字典中提取系统所有的实体及其属性。这种提出实体的指导原则如下： 属性必须是不可分的数据项，即属性中不能包含其它的属性或实体 E-R 图中的关联必须是实体之间的关联，属性不能和其它实体之间有关联由前面分析得到的数据流图和数据字典，可以抽象得到实体主要有 4 个：图书、订单、用户和出版商。 1. 图书实体属性有：书籍编号、书籍类型、书籍名称、作者、书籍单价、出版商编号。 2. 订单实体属性有：订单编号、用户编号、书籍编号、支付方式、购买日期、用户姓名、书籍名称。 3. 用户实体属性有：用户编号、用户名称、用户电话、用户性别、用户年龄。 4. 出版商实体属性有：出版商编号、出版商地址、出版商电话、出版商名称。 逻辑结构设计关系模式在概念设计阶段得到的数据模型，是独立于具体 DBMS 产品的信息模型。在逻辑设计阶段就是将这种模型进一步转化为某一种（某些类）DBMS 产品支持的数据模型。目前大部分的流行的数据库管理系统(SQL Server、Sybase、Oracle、DB2 等)基本上都是基于关系的数据模型，包括该系统将采用的 MySQL 数据库系统，因此，应将概念设计阶段的 E-R 图模型转化为关系数据模型。首先，书籍实体以及他们的联系。用户与书籍之间的是多对多的联系类型，因此，将书籍、用户联系分别设计成如下的关系模式： 书籍(书籍编号，书籍类型，书籍名称，作者，书籍单价，出版商编号) 用户(用户编号，用户名称，用户电话，用户性别，用户年龄) 并加入订单来保存多对多联系： 订单(订单编号，用户编号，书籍编号，支付方式，购买日期，用户姓名，书籍名称) 出版商实体和书籍之间是一对多的联系类型，所以只要两个关系表就可表示，其中出版商编号可以放到书籍的实体中： 出版商(出版商编号，出版商地址，出版商电话，出版商名称) 详细设计Python 连接数据库MySQLdb 是提供 Python 数据库 API 的流行 MySQL 数据库服务器的接口，能够执行 SQL 语句。它由一组用 Python 语言编写的类和接口组成。各种不同类型的数据库都有相应的实现，本文中的代码都是采用 MySQL 数据库实现的。连接数据库代码如下： class Db: def __init__(self, database: str): &quot;&quot;&quot; 初始化，输入数据库名字 :param database: &quot;&quot;&quot; self.host = &quot;localhost&quot; self.user = &quot;root&quot; self.password = &quot;zyf1593577852&quot; self.database = database print(&#39;正在连接&#39; + self.database + &#39;数据库...&#39;) self.mdb = MySQLdb.connect( host=self.host, user=self.user, passwd=self.password, database=self.database, ) print(&#39;连接成功！&#39;) return 登陆界面登录界面代码主要包括验证和主窗口设计以及各功能按钮的设计，用户输入密码后可以点击 “确定”按钮，调用数据库信息进行登录验证，验证成功后进入用户主界面； 登录界面设计代码def get_login(): &quot;&quot;&quot; 获取登录界面 :return: &quot;&quot;&quot; login_col = [ [sg.Image(filename=&#39;title_little.png&#39;)], ] col1 = [ [sg.Text(&#39;输入管理员账号：&#39;)], [sg.Text(&#39;输入管理员密码：&#39;)], ] col2 = [ [sg.InputText(k=&#39;manager_id&#39;, size=(30, 1))], [sg.InputText(k=&#39;manager_pw&#39;, size=(30, 1))], ] login = [ [sg.Column(login_col, justification=&#39;center&#39;)], [sg.Column(col1), sg.Column(col2)], [sg.Button(&#39;确定&#39;, k=&#39;check&#39;)], ] return login 登陆界面逻辑设计代码def check(): &quot;&quot;&quot; 验证管理员账号和密码是否正确 id:root password: password :return: &quot;&quot;&quot; global flag win_login = sg.Window(&#39;管理员登录&#39;, layout=get_login(), finalize=True) while True: event1, value1 = win_login.read() print(event1, value1) if event1 == sg.WIN_CLOSED: break elif event1 == &#39;check&#39;: if value1[&#39;manager_id&#39;] == &#39;root&#39; and value1[&#39;manager_pw&#39;] == &#39;password&#39;: flag = &#39;Verified&#39; sg.popup(&#39;验证成功&#39;) win_login._active_windows = False break else: flag = &#39;验证失败&#39; sg.popup(flag) win_login[&#39;manager_id&#39;].update(&#39;&#39;) win_login[&#39;manager_pw&#39;].update(&#39;&#39;) win_login.close() 登录界面验证代码if __name__ == &quot;__main__&quot;: flag = &#39;&#39; check() if flag == &#39;Verified&#39;: main() 主界面模块系统管理员登录后将进入主界面，可以选择接下来要进行的操作，点击按钮后主页面不会消失，可以同时打开多个操作页面。关闭主页面时会结束程序。 主界面设计代码def get_main(): &quot;&quot;&quot; 获取主界面 :return: &quot;&quot;&quot; main_col = [ [sg.Image(filename=&#39;title_large.png&#39;)], ] main_col2 = [ [sg.Text(&#39;1.图书管理&#39;), sg.Button(&#39;书籍创建&#39;, k=&#39;书籍创建&#39;), sg.Button(&#39;书籍查询&#39;, k=&#39;书籍查询&#39;)], [sg.Text(&#39;2.订单管理&#39;), sg.Button(&#39;订单创建&#39;, k=&#39;订单创建&#39;), sg.Button(&#39;订单查询&#39;, k=&#39;订单查询&#39;)], [sg.Text(&#39;3.用户管理&#39;), sg.Button(&#39;用户创建&#39;, k=&#39;用户创建&#39;), sg.Button(&#39;用户查询&#39;, k=&#39;用户查询&#39;)], ] main = [ [sg.Column(main_col, justification=&#39;center&#39;)], [sg.Text(&#39;欢迎使用网上书店信息管理系统，这里为您提供书籍管理服务&#39;)], [sg.Text(&#39;您可以使用该系统来管理网上书店的相关信息。&#39;)], [sg.Text(&#39;具体有如下几种操作：&#39;)], [sg.Column(main_col2, justification=&#39;left&#39;)], ] return main 主界面逻辑设计代码def main(): &quot;&quot;&quot; 主界面 可以跳转到操作界面，并且主界面不会消失 界面逻辑： 主页面-&gt;书籍查询 主页面-&gt;书籍创建 主页面-&gt;订单查询 主页面-&gt;订单创建 主页面-&gt;用户查询 主页面-&gt;用户创建 :return: &quot;&quot;&quot; global kind, find_str win_main = sg.Window(&#39;主页面&#39;, layout=get_main(), finalize=True) while True: event, value = win_main.read() print(event, value) if event == sg.WIN_CLOSED: break elif event == &#39;书籍查询&#39; or event == &#39;订单查询&#39; or event == &#39;用户查询&#39;: pass elif event == &#39;书籍创建&#39;: pass elif event == &#39;订单创建&#39;: pass elif event == &#39;用户创建&#39;: pass 查询模块查询界面可以查询书籍、订单和用户的信息。可以输入相应的编号来查询，也可以输入相应的姓名来进行查询。如果输入栏中没有输入，则默认搜索全部实例。最终返回结果为编号和名称的结果的交集。 搜索界面设计代码def get_find(kind: str): &quot;&quot;&quot; 获取查找页面 kind为查找操作执行的表的名称 :param kind: :return: &quot;&quot;&quot; global heading, find_id, find_name if kind == &#39;book&#39;: heading = [&#39;书籍编号&#39;, &#39;类型&#39;, &#39;名称&#39;, &#39;作者&#39;, &#39;单价&#39;] find_id = &#39;输入书籍编号：&#39; find_name = &#39;输入书籍的名称&#39; elif kind == &#39;orders&#39;: heading = [&#39;订单编号&#39;, &#39;用户姓名&#39;, &#39;书籍名称&#39;, &#39;支付方式&#39;, &#39;购买日期&#39;] find_id = &#39;输入订单编号：&#39; find_name = &#39;输入订单中用户的名称&#39; elif kind == &#39;customer&#39;: heading = [&#39;用户编号&#39;, &#39;用户姓名&#39;, &#39;用户电话&#39;, &#39;用户性别&#39;, &#39;用户年龄&#39;] find_id = &#39;输入用户编号：&#39; find_name = &#39;输入用户的姓名&#39; result = [[&#39; &#39;] * 5] * 1 find_col1 = [ [sg.Image(filename=&#39;title_little.png&#39;)], ] find_col2 = [ [sg.Text(&#39;填入所需查找的值，如果没有填入，则默认搜索所有实体。&#39;)], [sg.Text(find_id), sg.InputText(k=&#39;find_id&#39;, size=(10, 1)), sg.Text(find_name), sg.InputText(k=&#39;find_name&#39;, size=(10, 1)), sg.Ok()], ] find = [ [sg.Column(find_col1, justification=&#39;center&#39;)], [sg.Column(find_col2, justification=&#39;center&#39;)], [sg.Table(values=result, k=&#39;find_table&#39;, headings=heading,auto_size_columns=True, justification=&#39;left&#39;, background_color=&#39;white&#39;, text_color=&#39;black&#39;,num_rows=20, tooltip=&#39;find_table&#39;), ], ] return find 搜索页面逻辑设计代码elif event == &#39;书籍查询&#39; or event == &#39;订单查询&#39; or event == &#39;用户查询&#39;: if event == &#39;书籍查询&#39;: kind = &#39;book&#39; find_str = &#39;书籍查询&#39; elif event == &#39;订单查询&#39;: kind = &#39;orders&#39; find_str = &#39;查询订单&#39; elif event == &#39;用户查询&#39;: kind = &#39;customer&#39; find_str = &#39;查询用户&#39; win_find = sg.Window( find_str, layout=get_find(kind), finalize=True) print(&#39;你正在访问&#39; + kind + &#39;表&#39;) while True: event, value = win_find.read() print(event, value) if event == sg.WIN_CLOSED: break elif event == &#39;Ok&#39;: find_id = value[&#39;find_id&#39;] if value[&#39;find_id&#39;] != &#39;&#39; else None find_name = value[&#39;find_name&#39;] if value[&#39;find_name&#39;] != &#39;&#39; else None res = db.Find(kind=kind, id=find_id, name=find_name) win_find[&#39;find_table&#39;].update(res) Python 数据库操作代码def Find(self, kind: str, id=None, name=None): &quot;&quot;&quot; kind 为需要查询的类型，有book、orders、customer三种类型 id 为需要查询的编号，如果不填写则返回全部实体 name 为需要查询的名称，如果不填写则返回全部实体 结果为id 和 name 为交集 :param kind: :param id: :param name: :return: &quot;&quot;&quot; cursor = self.mdb.cursor() kind_id = res = kind_name = &#39;&#39; if kind == &#39;book&#39;: kind_id = &#39;bid&#39; kind_name = &#39;bname&#39; res = &#39;bid,bkind,bname,author,bprice&#39; elif kind == &#39;orders&#39;: kind_id = &#39;oid&#39; kind_name = &#39;cname&#39; res = &#39;oid,cname,bname,pay_way,odate&#39; elif kind == &#39;customer&#39;: kind_id = &#39;cid&#39; kind_name = &#39;cname&#39; res = &#39;cid,cname,cphone,csex,cage&#39; sql = &#39;&#39;&#39;select {_res} from {_kind} &#39;&#39;&#39;.format(_kind=kind, _res=res) if id or name: sql += &#39;where &#39; if id: sql += kind_id + &#39; = &#39; + id if name: if id: sql += &#39; and &#39; sql += kind_name + &#39; = \\&#39;%s\\&#39;&#39; % name cursor.execute(sql) res = [] results = cursor.fetchall() for item in results: res.append(list(item)) return res 创建模块创建界面可以创建书籍、订单和用户的实例。每次创建需要输入相应实例的详细信息，某些信息（如编号，和订单中的用户姓名和书籍名称不用填写）。如果输入栏中没有输入，则会认为输入格式错误。创建书籍时会依据出版商编号返回出版商基本信息。 创建界面设计代码def get_book_create(): &quot;&quot;&quot; 获取书籍创建界面 :return: &quot;&quot;&quot; image_col = [ [sg.Image(filename=&#39;title_little.png&#39;)], ] col1 = [ [sg.Text(&#39;输入书籍类型：&#39;)], [sg.Text(&#39;输入书籍名称：&#39;)], [sg.Text(&#39;输入书籍作者：&#39;)], [sg.Text(&#39;输入书籍单价：&#39;)], [sg.Text(&#39;输入出版商编号：&#39;)], ] col2 = [ [sg.InputText(k=&#39;bkind&#39;)], [sg.InputText(k=&#39;bname&#39;)], [sg.InputText(k=&#39;author&#39;)], [sg.InputText(k=&#39;bprice&#39;)], [sg.InputText(k=&#39;pid&#39;)], ] book_create = [ [sg.Column(image_col, justification=&#39;center&#39;)], [sg.Text(&#39;创建一个书籍实体：&#39;)], [sg.Column(col1), sg.Column(col2)], [sg.Ok()], ] return book_create 创建界面逻辑代码elif event == &#39;书籍创建&#39;: win_book_create = sg.Window(&#39;书籍创建&#39;, layout=get_book_create(), finalize=True) while True: event, value = win_book_create.read() print(event, value) if event == sg.WIN_CLOSED: break elif event == &#39;Ok&#39;: bkind = value[&#39;bkind&#39;] if value[&#39;bkind&#39;] != &#39;&#39; else None bname = value[&#39;bname&#39;] if value[&#39;bname&#39;] != &#39;&#39; else None author = value[&#39;author&#39;] if value[&#39;author&#39;] != &#39;&#39; else None bprice = value[&#39;bprice&#39;] if value[&#39;bprice&#39;] != &#39;&#39; else None pid = value[&#39;pid&#39;] if value[&#39;pid&#39;] != &#39;&#39; else None res = db.create_book(bkind=bkind, bname=bname, author=author, bprice=bprice, pid=pid) publisher = db.Find_publisher(pid=pid) if res == -1: sg.popup(&#39;输入信息格式不正确！&#39;) else: sg.popup(&#39;操作成功!&#39;, &#39;请尽快联系出版商!&#39;, &#39;\\n出版商名称：&#39; + publisher[0][0],&#39;出版商电话：&#39; + publisher[0][2], &#39;出版商地址：&#39; + publisher[0][1]) Python 数据库操作代码def create_book(self, bkind=None, bname=None, author=None, bprice=None, pid=None): &quot;&quot;&quot; 创建书籍实体 将会自动设置书籍实体的编号 :param bkind: :param bname: :param author: :param bprice: :param pid: :return: &quot;&quot;&quot; cursor = self.mdb.cursor() if bkind and bname and author and bprice and pid: res = self.Find(&#39;book&#39;) bid = str(len(res) + 1) string = &quot;&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;&quot; % (bid, bkind, bname, author, bprice, pid) sql = &#39;INSERT INTO book (bid,bkind,bname,author,bprice,pid) VALUES (%s)&#39; % string print(&#39;sql:&#39;, sql) cursor.execute(sql) self.mdb.commit() return 1 else: return -1 def Find_publisher(self, pid): &quot;&quot;&quot; 根据出版商编号查找出版商信息 :param pid: :return: &quot;&quot;&quot; cursor = self.mdb.cursor() sql = &#39;&#39;&#39;select pname,paddress,pphone from publisher where pid = &#39;%s&#39; &#39;&#39;&#39; % pid cursor.execute(sql) res = [] results = cursor.fetchall() for item in results: res.append(list(item)) return res 总结在课程设计设计过程中，本人学到的知识是有限的，面对的实践应用是多种多样的，所学很可能无法满足所用，必须在实践中、在应用中不断学习不断提高，这次完成设计的过程中本人学到了许多从前闻所未闻的知识和技能。课程设计是培养学生综合运用所学知识,发现,提出,分析和解决实际问题,锻炼实践 能力的重要环节,是对学生实际工作能力的具体训练和考察过程。本次课程设计虽然很 辛苦，实在是受益匪浅。本来这门课的知识学的就不够扎实，本次课程设计，在设计过 程中碰到了很多问题，刚开始要设计的时候，还真不知道从哪里下手但最终在图书、同学和老师的帮助下都得到了解决，让我学会了好多书本上没有的东西，通过本次课程设 计我也能将课本上的知识融会贯通，起到了很好的辅助学习的效果。理论和实践的相结合是学习最有效的方法。在设计的过程中发现了自己的不足之处，对以前所学过的知识理解得不够深刻，掌握得不够牢固，通过这次课程设计之后，一定把以前所学过的知识重新温故。通过这次课程设计使我懂得了理论与实际相结合是很重要的，只有理论知识是远远不够的，只有把所学的理论知识与实践相结合起来，从理论中得出结论，才能真正为社会服务，从而提高自己的实际动手能力和独立思考的能力。由于我的知识浅薄，经验不足及资历尚浅，因此在该程序的设计方面还有很多不足，比如功能过少，只是简单的实现了数据的添加，对数据的删除和查询等操作均未实现，因此需要今后更加深入的学习和努力总之，这次设计是本人受益匪浅。对本人以后的工作、学习打下了坚实的基础。尤其是软件的设计过程和思路的开拓益处更多。 致谢经过了这次的学习和实践，此次课程设计终于完成，虽然这次设计网上书店信息管理系统可能还有待改善，但无论其设计如何，至少让本人学到了很多本人所忽略以及以前未触及的东西。在此，对学校提供此次课程设计表示感谢，还有为此次课程设计出谋划策的老师们，是你们让本人们所学有一定的方向性。在此要感谢我的同学的帮助。在开始编写程序的时候，我看到别人的程序功能非常的详细，而且界面非常的漂亮，总希望自己的程序也多一些功能更加的完善。但是渐渐的我发现编写一个优秀的程序决不是一蹴而就的事情，需要长时间的积累和经验而这个方面又是我的弱项。因此在同学的帮助下，我认识到自己的不足和劣势，不要贪图大而全，只要尽我所能，编制一个实用简单的程序也是一件很不容易的事情。在同学的帮助和自己的努力之下，我终于做出了一个简单的程序。虽然程序的功能简单，而且我想在实际的运用中，肯定会有所不足因为学生信息管理系统工作的内容非常的丰富，我涉及到的仅仅是学生信息管理的一部分简单内容，离实际的客户需求肯定还有一定的差距。但是它毕竟代表着我对这段时间所学的知识的掌握。 Python 源代码Windows.py(表现层)import PySimpleGUI as sg def get_login(): &quot;&quot;&quot; 获取登录界面 :return: &quot;&quot;&quot; login_col = [ [sg.Image(filename=&#39;title_little.png&#39;)], ] col1 = [ [sg.Text(&#39;输入管理员账号：&#39;)], [sg.Text(&#39;输入管理员密码：&#39;)], ] col2 = [ [sg.InputText(k=&#39;manager_id&#39;, size=(30, 1))], [sg.InputText(k=&#39;manager_pw&#39;, size=(30, 1))], ] login = [ [sg.Column(login_col, justification=&#39;center&#39;)], [sg.Column(col1), sg.Column(col2)], [sg.Button(&#39;确定&#39;, k=&#39;check&#39;)], ] return login def get_main(): &quot;&quot;&quot; 获取主界面 :return: &quot;&quot;&quot; main_col = [ [sg.Image(filename=&#39;title_large.png&#39;)], ] main_col2 = [ [sg.Text(&#39;1.图书管理&#39;), sg.Button(&#39;书籍创建&#39;, k=&#39;书籍创建&#39;), sg.Button(&#39;书籍查询&#39;, k=&#39;书籍查询&#39;)], [sg.Text(&#39;2.订单管理&#39;), sg.Button(&#39;订单创建&#39;, k=&#39;订单创建&#39;), sg.Button(&#39;订单查询&#39;, k=&#39;订单查询&#39;)], [sg.Text(&#39;3.用户管理&#39;), sg.Button(&#39;用户创建&#39;, k=&#39;用户创建&#39;), sg.Button(&#39;用户查询&#39;, k=&#39;用户查询&#39;)], ] main = [ [sg.Column(main_col, justification=&#39;center&#39;)], [sg.Text(&#39;欢迎使用网上书店信息管理系统，这里为您提供书籍管理服务&#39;)], [sg.Text(&#39;您可以使用该系统来管理网上书店的相关信息。&#39;)], [sg.Text(&#39;具体有如下几种操作：&#39;)], [sg.Column(main_col2, justification=&#39;left&#39;)], ] return main def get_find(kind: str): &quot;&quot;&quot; 获取查找页面 kind为查找操作执行的表的名称 :param kind: :return: &quot;&quot;&quot; global heading, find_id, find_name if kind == &#39;book&#39;: heading = [&#39;书籍编号&#39;, &#39;类型&#39;, &#39;名称&#39;, &#39;作者&#39;, &#39;单价&#39;] find_id = &#39;输入书籍编号：&#39; find_name = &#39;输入书籍的名称&#39; elif kind == &#39;orders&#39;: heading = [&#39;订单编号&#39;, &#39;用户姓名&#39;, &#39;书籍名称&#39;, &#39;支付方式&#39;, &#39;购买日期&#39;] find_id = &#39;输入订单编号：&#39; find_name = &#39;输入订单中用户的名称&#39; elif kind == &#39;customer&#39;: heading = [&#39;用户编号&#39;, &#39;用户姓名&#39;, &#39;用户电话&#39;, &#39;用户性别&#39;, &#39;用户年龄&#39;] find_id = &#39;输入用户编号：&#39; find_name = &#39;输入用户的姓名&#39; result = [[&#39; &#39;] * 5] * 1 find_col1 = [ [sg.Image(filename=&#39;title_little.png&#39;)], ] find_col2 = [ [sg.Text(&#39;填入所需查找的值，如果没有填入，则默认搜索所有实体。&#39;)], [sg.Text(find_id), sg.InputText(k=&#39;find_id&#39;, size=(10, 1)), sg.Text(find_name), sg.InputText(k=&#39;find_name&#39;, size=(10, 1)), sg.Ok()], ] find = [ [sg.Column(find_col1, justification=&#39;center&#39;)], [sg.Column(find_col2, justification=&#39;center&#39;)], [sg.Table(values=result, k=&#39;find_table&#39;, headings=heading, auto_size_columns=True, justification=&#39;left&#39;, background_color=&#39;white&#39;, text_color=&#39;black&#39;, num_rows=20, tooltip=&#39;find_table&#39;), ], ] return find def get_book_create(): &quot;&quot;&quot; 获取书籍创建界面 :return: &quot;&quot;&quot; image_col = [ [sg.Image(filename=&#39;title_little.png&#39;)], ] col1 = [ [sg.Text(&#39;输入书籍类型：&#39;)], [sg.Text(&#39;输入书籍名称：&#39;)], [sg.Text(&#39;输入书籍作者：&#39;)], [sg.Text(&#39;输入书籍单价：&#39;)], [sg.Text(&#39;输入出版商编号：&#39;)], ] col2 = [ [sg.InputText(k=&#39;bkind&#39;)], [sg.InputText(k=&#39;bname&#39;)], [sg.InputText(k=&#39;author&#39;)], [sg.InputText(k=&#39;bprice&#39;)], [sg.InputText(k=&#39;pid&#39;)], ] book_create = [ [sg.Column(image_col, justification=&#39;center&#39;)], [sg.Text(&#39;创建一个书籍实体：&#39;)], [sg.Column(col1), sg.Column(col2)], [sg.Ok()], ] return book_create def get_orders_create(): &quot;&quot;&quot; 获取订单创建界面 :return: &quot;&quot;&quot; image_col = [ [sg.Image(filename=&#39;title_little.png&#39;)], ] col1 = [ [sg.Text(&#39;输入订单中书籍编号：&#39;)], [sg.Text(&#39;输入订单中用户编号：&#39;)], [sg.Text(&#39;输入支付方式：&#39;)], [sg.Text(&#39;输入购买日期：&#39;)], ] col2 = [ [sg.InputText(k=&#39;bid&#39;)], [sg.InputText(k=&#39;cid&#39;)], [sg.InputText(k=&#39;pay_way&#39;)], [sg.InputText(k=&#39;odate&#39;)], ] orders_create = [ [sg.Column(image_col, justification=&#39;center&#39;)], [sg.Text(&#39;创建一个订单实体：&#39;)], [sg.Column(col1), sg.Column(col2)], [sg.Ok()], ] return orders_create def get_customer_change(): &quot;&quot;&quot; 获取用户创建界面 :return: &quot;&quot;&quot; image_col = [ [sg.Image(filename=&#39;title_little.png&#39;)], ] col1 = [ [sg.Text(&#39;输入用户姓名：&#39;)], [sg.Text(&#39;输入用户电话：&#39;)], [sg.Text(&#39;输入用户性别：&#39;)], [sg.Text(&#39;输入用户年龄：&#39;)], ] col2 = [ [sg.InputText(k=&#39;cname&#39;)], [sg.InputText(k=&#39;cphone&#39;)], [sg.InputText(k=&#39;csex&#39;)], [sg.InputText(k=&#39;cage&#39;)], ] customer_change = [ [sg.Column(image_col, justification=&#39;center&#39;)], [sg.Text(&#39;创建一个用户实体：&#39;)], [sg.Column(col1), sg.Column(col2)], [sg.Ok()], ] return customer_change main.py(功能层)from db import Db from windows import * def check(): &quot;&quot;&quot; 验证管理员账号和密码是否正确 id:root password: password :return: &quot;&quot;&quot; global flag win_login = sg.Window(&#39;管理员登录&#39;, layout=get_login(), finalize=True) while True: event1, value1 = win_login.read() print(event1, value1) if event1 == sg.WIN_CLOSED: break elif event1 == &#39;check&#39;: if value1[&#39;manager_id&#39;] == &#39;root&#39; and value1[&#39;manager_pw&#39;] == &#39;password&#39;: flag = &#39;Verified&#39; sg.popup(&#39;验证成功&#39;) win_login._active_windows = False break else: flag = &#39;验证失败&#39; sg.popup(flag) win_login[&#39;manager_id&#39;].update(&#39;&#39;) win_login[&#39;manager_pw&#39;].update(&#39;&#39;) win_login.close() def main(): &quot;&quot;&quot; 主界面 可以跳转到操作界面，并且主界面不会消失 界面逻辑： 主页面-&gt;书籍查询 主页面-&gt;书籍创建 主页面-&gt;订单查询 主页面-&gt;订单创建 主页面-&gt;用户查询 主页面-&gt;用户创建 :return: &quot;&quot;&quot; global kind, find_str win_main = sg.Window(&#39;主页面&#39;, layout=get_main(), finalize=True) while True: event, value = win_main.read() print(event, value) if event == sg.WIN_CLOSED: break elif event == &#39;书籍查询&#39; or event == &#39;订单查询&#39; or event == &#39;用户查询&#39;: if event == &#39;书籍查询&#39;: kind = &#39;book&#39; find_str = &#39;书籍查询&#39; elif event == &#39;订单查询&#39;: kind = &#39;orders&#39; find_str = &#39;查询订单&#39; elif event == &#39;用户查询&#39;: kind = &#39;customer&#39; find_str = &#39;查询用户&#39; win_find = sg.Window( find_str, layout=get_find(kind), finalize=True) print(&#39;你正在访问&#39; + kind + &#39;表&#39;) while True: event, value = win_find.read() print(event, value) if event == sg.WIN_CLOSED: break elif event == &#39;Ok&#39;: find_id = value[&#39;find_id&#39;] if value[&#39;find_id&#39;] != &#39;&#39; else None find_name = value[&#39;find_name&#39;] if value[&#39;find_name&#39;] != &#39;&#39; else None res = db.Find(kind=kind, id=find_id, name=find_name) win_find[&#39;find_table&#39;].update(res) elif event == &#39;书籍创建&#39;: win_book_create = sg.Window(&#39;书籍创建&#39;, layout=get_book_create(), finalize=True) while True: event, value = win_book_create.read() print(event, value) if event == sg.WIN_CLOSED: break elif event == &#39;Ok&#39;: bkind = value[&#39;bkind&#39;] if value[&#39;bkind&#39;] != &#39;&#39; else None bname = value[&#39;bname&#39;] if value[&#39;bname&#39;] != &#39;&#39; else None author = value[&#39;author&#39;] if value[&#39;author&#39;] != &#39;&#39; else None bprice = value[&#39;bprice&#39;] if value[&#39;bprice&#39;] != &#39;&#39; else None pid = value[&#39;pid&#39;] if value[&#39;pid&#39;] != &#39;&#39; else None res = db.create_book(bkind=bkind, bname=bname, author=author, bprice=bprice, pid=pid) publisher = db.Find_publisher(pid=pid) if res == -1: sg.popup(&#39;输入信息格式不正确！&#39;) else: sg.popup( &#39;操作成功!&#39;, &#39;请尽快联系出版商!&#39;, &#39;\\n出版商名称：&#39; + publisher[0][0], &#39;出版商电话：&#39; + publisher[0][2], &#39;出版商地址：&#39; + publisher[0][1]) elif event == &#39;订单创建&#39;: win_orders_create = sg.Window(&#39;订单创建&#39;, layout=get_orders_create(), finalize=True) while True: event, value = win_orders_create.read() print(event, value) if event == sg.WIN_CLOSED: break elif event == &#39;Ok&#39;: bid = value[&#39;bid&#39;] if value[&#39;bid&#39;] != &#39;&#39; else None cid = value[&#39;cid&#39;] if value[&#39;cid&#39;] != &#39;&#39; else None pay_way = value[&#39;pay_way&#39;] if value[&#39;pay_way&#39;] != &#39;&#39; else None odate = value[&#39;odate&#39;] if value[&#39;odate&#39;] != &#39;&#39; else None res = db.create_orders(bid=bid, cid=cid, pay_way=pay_way, odate=odate) if res == -1: sg.popup(&#39;输入信息格式不正确！&#39;) else: sg.popup(&#39;操作成功！&#39;) elif event == &#39;用户创建&#39;: win_customer_change = sg.Window(&#39;用户创建&#39;, layout=get_customer_change(), finalize=True) while True: event, value = win_customer_change.read() print(event, value) if event == sg.WIN_CLOSED: break elif event == &#39;Ok&#39;: cname = value[&#39;cname&#39;] if value[&#39;cname&#39;] != &#39;&#39; else None cphone = value[&#39;cphone&#39;] if value[&#39;cphone&#39;] != &#39;&#39; else None csex = value[&#39;csex&#39;] if value[&#39;csex&#39;] != &#39;&#39; else None cage = value[&#39;cage&#39;] if value[&#39;cage&#39;] != &#39;&#39; else None res = db.create_customer(cname=cname, cphone=cphone, csex=csex, cage=cage) if res == -1: sg.popup(&#39;输入信息格式不正确！&#39;) else: sg.popup(&#39;操作成功！&#39;) if __name__ == &quot;__main__&quot;: db = Db(&#39;books&#39;) flag = &#39;&#39; check() if flag == &#39;Verified&#39;: main() db.py(数据层)import MySQLdb class Db: def __init__(self, database: str): &quot;&quot;&quot; 初始化，输入数据库名字 :param database: &quot;&quot;&quot; self.host = &quot;localhost&quot; self.user = &quot;root&quot; self.password = &quot;zyf1593577852&quot; self.database = database print(&#39;正在连接&#39; + self.database + &#39;数据库...&#39;) self.mdb = MySQLdb.connect( host=self.host, user=self.user, passwd=self.password, database=self.database, ) print(&#39;连接成功！&#39;) return def Find_publisher(self, pid): &quot;&quot;&quot; 根据出版商编号查找出版商信息 :param pid: :return: &quot;&quot;&quot; cursor = self.mdb.cursor() sql = &#39;&#39;&#39;select pname,paddress,pphone from publisher where pid = &#39;%s&#39; &#39;&#39;&#39; % pid cursor.execute(sql) res = [] results = cursor.fetchall() for item in results: res.append(list(item)) return res def Find(self, kind: str, id=None, name=None): &quot;&quot;&quot; kind 为需要查询的类型，有book、orders、customer三种类型 id 为需要查询的编号，如果不填写则返回全部实体 name 为需要查询的名称，如果不填写则返回全部实体 结果为id 和 name 为交集 :param kind: :param id: :param name: :return: &quot;&quot;&quot; cursor = self.mdb.cursor() kind_id = res = kind_name = &#39;&#39; if kind == &#39;book&#39;: kind_id = &#39;bid&#39; kind_name = &#39;bname&#39; res = &#39;bid,bkind,bname,author,bprice&#39; elif kind == &#39;orders&#39;: kind_id = &#39;oid&#39; kind_name = &#39;cname&#39; res = &#39;oid,cname,bname,pay_way,odate&#39; elif kind == &#39;customer&#39;: kind_id = &#39;cid&#39; kind_name = &#39;cname&#39; res = &#39;cid,cname,cphone,csex,cage&#39; sql = &#39;&#39;&#39;select {_res} from {_kind} &#39;&#39;&#39;.format(_kind=kind, _res=res) if id or name: sql += &#39;where &#39; if id: sql += kind_id + &#39; = &#39; + id if name: if id: sql += &#39; and &#39; sql += kind_name + &#39; = \\&#39;%s\\&#39;&#39; % name cursor.execute(sql) res = [] results = cursor.fetchall() for item in results: res.append(list(item)) return res def create_book(self, bkind=None, bname=None, author=None, bprice=None, pid=None): &quot;&quot;&quot; 创建书籍实体 将会自动设置书籍实体的编号 :param bkind: :param bname: :param author: :param bprice: :param pid: :return: &quot;&quot;&quot; cursor = self.mdb.cursor() if bkind and bname and author and bprice and pid: res = self.Find(&#39;book&#39;) bid = str(len(res) + 1) string = &quot;&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;&quot; % (bid, bkind, bname, author, bprice, pid) sql = &#39;INSERT INTO book (bid,bkind,bname,author,bprice,pid) VALUES (%s)&#39; % string print(&#39;sql:&#39;, sql) cursor.execute(sql) self.mdb.commit() return 1 else: return -1 def create_orders(self, bid=None, cid=None, pay_way=None, odate=None): &quot;&quot;&quot; 创建订单实体 将会自动设置订单实体的编号 以及根据书籍编号和用户编号设置书籍名称和用户名称 :param bid: :param cid: :param pay_way: :param odate: :return: &quot;&quot;&quot; cursor = self.mdb.cursor() if bid and cid and pay_way and odate: res = self.Find(&#39;book&#39;, id=bid) bname = res[0][2] res = self.Find(&#39;customer&#39;, id=cid) cname = res[0][1] res = self.Find(&#39;orders&#39;) oid = str(len(res) + 1) string = &quot;&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;&quot; % (oid, bid, cid, pay_way, odate, bname, cname) sql = &#39;INSERT INTO orders (oid,bid,cid,pay_way,odate,bname,cname) VALUES (%s)&#39; % string print(&#39;sql:&#39;, sql) cursor.execute(sql) self.mdb.commit() return 1 else: return -1 def create_customer(self, cname=None, cphone=None, csex=None, cage=None): &quot;&quot;&quot; 创建用户实体 将会自动设置用户实体的编号 :param cname: :param cphone: :param csex: :param cage: :return: &quot;&quot;&quot; cursor = self.mdb.cursor() if cname and cphone and csex and cage: res = self.Find(&#39;customer&#39;) cid = str(len(res) + 1) string = &quot;&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;&quot; % (cid, cname, cphone, csex, cage) sql = &#39;INSERT INTO customer (cid,cname,cphone,csex,cage) VALUES (%s)&#39; % string print(&#39;sql:&#39;, sql) cursor.execute(sql) self.mdb.commit() return 1 else: return -1","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"PySimpleGUI","slug":"PySimpleGUI","permalink":"/tags/PySimpleGUI/"},{"name":"MySQL","slug":"MySQL","permalink":"/tags/MySQL/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"PySimpleGUI演示多线程","slug":"Python多线程","date":"2020-12-10T11:40:06.000Z","updated":"2024-03-02T16:13:05.071Z","comments":true,"path":"2020/12/10/Python多线程/","link":"","permalink":"/2020/12/10/Python多线程/","excerpt":"","text":"一. 实验目标设计 通过 Python 完成线程的创建。创建两个线程，一个线程每 0.1 秒对一个变量加 1，一个线程每 0.1 秒对一个变量减 1。实时在界面中显示出来，可以通过“结束进程”按钮停止线程运行。 通过 Python 完成互斥线程的演示。创建两个线程，共同操作同一个变量，一个每 0.1 秒加 1，另一个每 0.1秒减 1；一个线程每次循环对共享变量 x 做 100 次加 1 操作，另一个线程不断循环，每次循环对共享变量 x 做 100 次减 1 操作。实时在界面中显示出来，可以通过“结束进程”按钮停止线程运行。 通过 Python 完成非互斥线程的演示。创建两个线程，共同操作同一个变量。一个每 0.1 秒加 1，另一个每 0.15 秒减 1（为了能将加减体现在界面上）；实时在界面中显示出来，可以通过“结束进程”按钮停止线程运行。 二. 实验详细设计1. 界面设计界面采用 Python 的 PySimpleGUI 库，PySimpleGUI 库是一个简单的界面库，能够简单地在 layout 中设计图形界面。主要 Python 代码： layout = [ [sg.Text(&#39;线程自加文本框: &#39;), sg.InputText(default_text=&#39;0&#39;, key=&#39;data1&#39;)], [sg.Text(&#39;线程自减文本框: &#39;), sg.InputText(default_text=&#39;0&#39;, key=&#39;data2&#39;)], [sg.Text(&#39;线程互斥文本框: &#39;), sg.InputText(default_text=&#39;0&#39;, key=&#39;data3&#39;)], [sg.Text(&#39;线程非互斥文本框:&#39;), sg.InputText(default_text=&#39;0&#39;, key=&#39;data4&#39;)], [sg.Button(&quot;创建线程&quot;, k=&#39;创建&#39;)], [sg.Button(&quot;演示线程互斥&quot;, k=&#39;线程互斥&#39;)], [sg.Button(&#39;演示非线程互斥&#39;, k=&#39;非线程互斥&#39;)], [sg.Button(&#39;结束线程&#39;, k=&#39;结束线程&#39;)], [sg.Quit()], ] window = sg.Window(&#39;线程实验演示&#39;, layout=layout, finalize=True) 2. 界面事件与多线程交互界面事件通过点击按钮实现，在主循环中，PySimpleGUI 有 window.read()函数来获取界面事件和输入值。之后通过判断事件(event) 来判断执行哪个事件。线程创建通过指定函数的形式，使用 threading 模块的 Thread 类创建线程，并通过 start 函数运行主要 Python 代码： while True: event, value = window.read() if event == &#39;Quit&#39; or event == sg.WIN_CLOSED: break elif event == &#39;创建&#39;: x, y = threading.Thread(target=run1), threading.Thread(target=run2) flag = True x.start() y.start() elif event == &#39;线程互斥&#39;: x, y = threading.Thread(target=run3), threading.Thread(target=run4) flag = True x.start() y.start() elif event == &#39;非线程互斥&#39;: x, y = threading.Thread(target=run5), threading.Thread(target=run6) flag = True x.start() time.sleep(0.5) y.start() elif event == &#39;结束线程&#39;: flag = False 3. 创建线程设计当 event 等于“创建线程”时，flag 会被置为 True，并创建两个线程，操作两个数据框的值，每 0.1 秒更新值。当 event 等于“结束进程”时，会见 flag 置为 Flase，线程也随之停止。主要 Python 代码： def run1(): &#39;&#39;&#39; 创建线程1 并通过flag控制是否运行 每次处理数据完成后，都将更新界面显示 0.1秒循环一次 &#39;&#39;&#39; while flag: nums[0] += 1 window[&#39;data1&#39;].update(nums[0]) time.sleep(0.1) def run2(): &#39;&#39;&#39;创建线程2 并通过flag控制是否运行 每次处理数据完成后，都将更新界面显示 0.1秒循环一次 &#39;&#39;&#39; while flag: nums[1] -= 1 window[&#39;data2&#39;].update(nums[1]) time.sleep(0.1) 4. 互斥线程演示设计当 event 等于“创建线程”时，flag 会被置为 True，并创建两个线程，操作同一个数据框的值。并引入全局信号量 lock，如果 lock 等于 True，线程 1 运行，如果 lock 等于 False，线程 2 运行。设置 0 和 100 为分界点。主要 Python 代码： def run3(): &#39;&#39;&#39;互斥线程1 0-100时，启动线程，自加，并更新内容 100-0时，空循环 &#39;&#39;&#39; global lock while flag: if lock: nums[2] += 1 window[&#39;data3&#39;].update(nums[2]) time.sleep(0.01) if nums[2] == 100: lock = False def run4(): &#39;&#39;&#39;互斥线程2 100-0时，启动线程，自加，并更新内容 0-100时，空循环 &#39;&#39;&#39; global lock while flag: if not lock: nums[2] -= 1 window[&#39;data3&#39;].update(nums[2]) time.sleep(0.01) if nums[2] == 0: lock = True 5. 非互斥线程演示设计当 event 等于“创建线程”时，flag 会被置为 True，并创建两个线程，操作同一个数据框的值。为了能方便地观察是否成功，每次改变值都会在控制台打印当前值，并且自加为 0.1 秒一循环，自减为 0.15 秒一循环。主要 Python 代码： def run5(): &#39;&#39;&#39;非互斥线程1 自加，0.1秒一个循环 &#39;&#39;&#39; while flag: nums[3] += 1 print(nums[3] , end=&quot; &quot;) window[&#39;data4&#39;].update(nums[3]) time.sleep(0.1) def run6(): &#39;&#39;&#39;非互斥线程2 自减，0.15秒一个循环 &#39;&#39;&#39; while flag: nums[3] -= 1 print(nums[3] , end=&quot; &quot;) window[&#39;data4&#39;].update(nums[3]) time.sleep(0.15) 总结通过这次实验，我学会了很多知识。包括但不限于，使用 Python 创建线程对象，控制线程互斥和非互斥关系，使我受益匪浅。在这次实验中，我遇到过非常多的困难： PySimpleGUI 是一个在 Github 上全新的开源项目，反馈社区并不完善，遇到许多困难，只能查找开发文档。 由于基于 Tkinter 开发，导致多线程开发时偶尔会出现”RuntimeError: main thread is not in main loop”的错误，后来查找文档发现是 Tkinter 的主线程无法等待子线程过长的时间。后来设置为子线程和主线程同时运行，解决了问题。 非互斥线程运行结果显示不明显。于是调整自加和自减的运行时间，并在控制台打印出每次改变的结果。 总而言之，通过这次实验，我学会了许多技术，但最重要的是学会了解决问题的方法。期待自己未来更大的进步。 全部源码import time import threading import PySimpleGUI as sg from mttkinter import mtTkinter as tk def run1(): &#39;&#39;&#39;创建线程1 并通过flag控制是否运行 每次处理数据完成后，都将更新界面显示 0.1秒循环一次 &#39;&#39;&#39; while flag: nums[0] += 1 window[&#39;data1&#39;].update(nums[0]) time.sleep(0.1) def run2(): &#39;&#39;&#39;创建线程2 并通过flag控制是否运行 每次处理数据完成后，都将更新界面显示 0.1秒循环一次 &#39;&#39;&#39; while flag: nums[1] -= 1 window[&#39;data2&#39;].update(nums[1]) time.sleep(0.1) def run3(): &#39;&#39;&#39;互斥线程1 0-100时，启动线程，自加，并更新内容 100-0时，空循环 &#39;&#39;&#39; global lock while flag: if lock: nums[2] += 1 window[&#39;data3&#39;].update(nums[2]) time.sleep(0.01) if nums[2] == 100: lock = False def run4(): &#39;&#39;&#39;互斥线程2 100-0时，启动线程，自加，并更新内容 0-100时，空循环 &#39;&#39;&#39; global lock while flag: if not lock: nums[2] -= 1 window[&#39;data3&#39;].update(nums[2]) time.sleep(0.01) if nums[2] == 0: lock = True def run5(): &#39;&#39;&#39;非互斥线程1 自加，0.1秒一个循环 &#39;&#39;&#39; while flag: nums[3] += 1 print(nums[3], end=&quot; &quot;) window[&#39;data4&#39;].update(nums[3]) time.sleep(0.1) def run6(): &#39;&#39;&#39;非互斥线程2 自减，0.15秒一个循环 &#39;&#39;&#39; while flag: nums[3] -= 1 print(nums[3], end=&quot; &quot;) window[&#39;data4&#39;].update(nums[3]) time.sleep(0.15) if __name__ == &#39;__main__&#39;: nums = [0]*4 layout = [ [sg.Text(&#39;线程自加文本框: &#39;), sg.InputText(default_text=&#39;0&#39;, key=&#39;data1&#39;)], [sg.Text(&#39;线程自减文本框: &#39;), sg.InputText(default_text=&#39;0&#39;, key=&#39;data2&#39;)], [sg.Text(&#39;线程互斥文本框: &#39;), sg.InputText(default_text=&#39;0&#39;, key=&#39;data3&#39;)], [sg.Text(&#39;线程非互斥文本框:&#39;), sg.InputText(default_text=&#39;0&#39;, key=&#39;data4&#39;)], [sg.Button(&quot;创建线程&quot;, k=&#39;创建&#39;)], [sg.Button(&quot;演示线程互斥&quot;, k=&#39;线程互斥&#39;)], [sg.Button(&#39;演示非线程互斥&#39;, k=&#39;非线程互斥&#39;)], [sg.Button(&#39;结束线程&#39;, k=&#39;结束线程&#39;)], [sg.Quit()], ] window = sg.Window(&#39;线程实验演示&#39;, layout=layout, finalize=True) x, y = None, None flag = False lock = True while True: event, value = window.read() if event == &#39;Quit&#39; or event == sg.WIN_CLOSED: break elif event == &#39;创建&#39;: x, y = threading.Thread(target=run1), threading.Thread(target=run2) flag = True x.start() y.start() elif event == &#39;线程互斥&#39;: x, y = threading.Thread(target=run3), threading.Thread(target=run4) flag = True x.start() y.start() elif event == &#39;非线程互斥&#39;: x, y = threading.Thread(target=run5), threading.Thread(target=run6) flag = True x.start() time.sleep(0.5) y.start() elif event == &#39;结束线程&#39;: flag = False","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"线程","slug":"线程","permalink":"/tags/线程/"},{"name":"PySimpleGUI","slug":"PySimpleGUI","permalink":"/tags/PySimpleGUI/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"PySimpleGUI演示多进程","slug":"python进程和线程","date":"2020-11-26T12:29:06.000Z","updated":"2024-03-02T16:13:04.081Z","comments":true,"path":"2020/11/26/python进程和线程/","link":"","permalink":"/2020/11/26/python进程和线程/","excerpt":"","text":"界面设计界面设计使用了PySimpleGUI 库,详情使用方式请查阅https://pysimplegui.readthedocs.io/en/latest/ 主进程layout = [ [sg.Multiline(key=&#39;date&#39;, size=(50, 10))], [sg.Button(&quot;发送消息&quot;, k=&#39;发送&#39;)], [sg.Button(&quot;将数据写入内存&quot;, k=&#39;写入内存&#39;)], [sg.Button(&quot;写数据到管道文件&quot;, k=&#39;写入文件&#39;)], [sg.Quit()], ] window = sg.Window(&#39;主进程&#39;, layout, finalize=True) 子进程layout = [ [sg.Multiline(key=&#39;date&#39;, size=(50, 10))], [sg.Button(&quot;接收消息&quot;, k=&#39;接收&#39;)], [sg.Button(&quot;从内存读取数据&quot;, k=&#39;读取内存&#39;)], [sg.Button(&quot;从管道文件中读取数据&quot;, k=&#39;读取文件&#39;)], [sg.Quit()], ] window = sg.Window(&#39;子进程&#39;, layout=layout, finalize=True) 用消息队列传递发送： if event == &#39;发送&#39;: que.put(value) print(&#39;成功发送&#39;) 接收： if event == &#39;接收&#39;: string += &#39;通过队列消息获得：&#39; message = que.get() string += message[&#39;date&#39;] window[&#39;date&#39;].update(string) print(&#39;成功接收&#39;) 用内存映像文件传递发送： if event == &#39;写入内存&#39;: with open(&#39;test.dat&#39;, &#39;wb&#39;)as f: message = bytes(value[&#39;date&#39;], encoding=&#39;utf-8&#39;) f.write(message) print(&#39;写入成功&#39;) 接收： if event == &#39;读取内存&#39;: string += &#39;通过共享内存获得：&#39; with open(&#39;test.dat&#39;, &#39;r+b&#39;) as f: mm = mmap.mmap(f.fileno(), 0) message = mm.read() message = str(message, encoding=&#39;utf-8&#39;) string += message window[&#39;date&#39;].update(string) print(&#39;读取成功&#39;) 用管道文件传递发送： if event == &#39;写入文件&#39;: conn.send(value) print(&#39;写入成功&#39;) 接收： if event == &#39;读取文件&#39;: string += &#39;通过读取管道文件获得：&#39; message = conn.recv() string += message[&#39;date&#39;] window[&#39;date&#39;].update(string) print(&#39;读取成功&#39;) 全部源码import PySimpleGUI as sg from multiprocessing import Pipe, Process, Queue import mmap def run_process2(que, conn): layout = [ [sg.Multiline(key=&#39;date&#39;, size=(50, 10))], [sg.Button(&quot;接收消息&quot;, k=&#39;接收&#39;)], [sg.Button(&quot;从内存读取数据&quot;, k=&#39;读取内存&#39;)], [sg.Button(&quot;从管道文件中读取数据&quot;, k=&#39;读取文件&#39;)], [sg.Quit()], ] window = sg.Window(&#39;子进程&#39;, layout=layout, finalize=True) window.make_modal() string = &#39;&#39; while True: event, value = window.read() if event == sg.WIN_CLOSED or event == &#39;Quit&#39;: break print(&#39;子进程: &#39;, event) if event == &#39;接收&#39;: string += &#39;通过队列消息获得：&#39; message = que.get() string += message[&#39;date&#39;] window[&#39;date&#39;].update(string) print(&#39;成功接收&#39;) if event == &#39;读取内存&#39;: string += &#39;通过共享内存获得：&#39; with open(&#39;test.dat&#39;, &#39;r+b&#39;) as f: mm = mmap.mmap(f.fileno(), 0) message = mm.read() message = str(message, encoding=&#39;utf-8&#39;) string += message window[&#39;date&#39;].update(string) print(&#39;读取成功&#39;) if event == &#39;读取文件&#39;: string += &#39;通过读取管道文件获得：&#39; message = conn.recv() string += message[&#39;date&#39;] window[&#39;date&#39;].update(string) print(&#39;读取成功&#39;) window.close() def run_process1(que, conn): layout = [ [sg.Multiline(key=&#39;date&#39;, size=(50, 10))], [sg.Button(&quot;发送消息&quot;, k=&#39;发送&#39;)], [sg.Button(&quot;将数据写入内存&quot;, k=&#39;写入内存&#39;)], [sg.Button(&quot;写数据到管道文件&quot;, k=&#39;写入文件&#39;)], [sg.Quit()], ] window = sg.Window(&#39;主进程&#39;, layout, finalize=True) window.make_modal() while True: event, value = window.read() if event == sg.WIN_CLOSED or event == &#39;Quit&#39;: break print(&#39;主进程: &#39;, event, value) if event == &#39;发送&#39;: que.put(value) print(&#39;成功发送&#39;) if event == &#39;写入内存&#39;: with open(&#39;test.dat&#39;, &#39;wb&#39;)as f: message = bytes(value[&#39;date&#39;], encoding=&#39;utf-8&#39;) f.write(message) print(&#39;写入成功&#39;) if event == &#39;写入文件&#39;: conn.send(value) print(&#39;写入成功&#39;) window.close() if __name__ == &quot;__main__&quot;: que = Queue(1) conn1, conn2 = Pipe(True) p1 = Process(target=run_process1, args=(que, conn1)) p2 = Process(target=run_process2, args=(que, conn2)) p1.start() p2.start() p1.join() p2.join()","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"PySimpleGUI","slug":"PySimpleGUI","permalink":"/tags/PySimpleGUI/"},{"name":"进程","slug":"进程","permalink":"/tags/进程/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"leetcode打卡","slug":"leetcode打卡","date":"2020-11-18T14:37:36.000Z","updated":"2024-03-02T16:13:05.071Z","comments":true,"path":"2020/11/18/leetcode打卡/","link":"","permalink":"/2020/11/18/leetcode打卡/","excerpt":"","text":"2020.11.18 T134题目在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i + 1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 - 1。 代码class Solution: def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&gt; int: a = [] for i in range(len(gas)): a.append(gas[i] - cost[i]) if sum(a) &lt; 0: return -1 start, money = 0, 0 for i in range(len(a)): money += a[i] if money &lt; 0: start = i + 1 money = 0 return start 分析 有一个环形路上有 n 个站点； 每个站点都有一个好人或一个坏人； 好人会给你钱，坏人会收你一定的过路费，如果你带的钱不够付过路费，坏人会跳起来把你砍死； 问：从哪个站点出发，能绕一圈活着回到出发点? 首先考虑一种情况：如果全部好人给你 的钱加起来 小于 坏人收的过路费之和，那么总有一次你的钱不够付过路费，你的结局注定会被砍死。 假如你随机选一点 start 出发，那么你肯定会选一个有好人的站点开始，因为开始的时候你没有钱，遇到坏人只能被砍死； 现在你在 start 出发，走到了某个站点 end，被 end 站点的坏人砍死了，说明你在 [start, end) 存的钱不够付 end 点坏人的过路费，因为 start 站点是个好人，所以在 (start, end) 里任何一点出发，你存的钱会比现在还少，还是会被 end 站点的坏人砍死； 于是你重新读档，聪明的选择从 end + 1 点出发，继续你悲壮的征程； 终于有一天，你发现自己走到了尽头(下标是 n - 1)的站点而没有被砍死； 此时你犹豫了一下，那我继续往前走，身上的钱够不够你继续走到出发点 Start? 当然可以，因为开始已经判断过，好人给你的钱数是大于等于坏人要的过路费的，你现在攒的钱完全可以应付[0, start) 这一段坏人向你收的过路费。 这时候你的嘴角微微上扬，眼眶微微湿润，因为你已经知道这个世界的终极奥秘：Start 就是这个问题的答案。 2020.11.23 T72题目给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 代码class Solution: def minDistance(self, word1: str, word2: str) -&gt; int: len1, len2 = len(word1), len(word2) if len1 * len2 == 0: return len1 + len2 dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(len1 + 1): dp[i][0] = i for i in range(len2 + 1): dp[0][i] = i for i in range(1, len1 + 1): for j in range(1, len2 + 1): left = dp[i - 1][j] + 1 down = dp[i][j - 1] + 1 left_down = dp[i - 1][j - 1] if word1[i - 1] != word2[j - 1]: left_down += 1 dp[i][j] = min(left, down, left_down) for i in range(0, len1): for j in range(0, len2): print(dp[i][j], end=&quot; &quot;) print() return dp[len1][len2] 分析 问题 1：如果 word1[0..i - 1] 到 word2[0..j - 1] 的变换需要消耗 k 步，那 word1[0..i] 到 word2[0..j]的变换需要几步呢？ 答：先使用 k 步，把 word1[0..i - 1] 变换到 word2[0..j - 1]，消耗 k 步。再把 word1[i] 改成 word2[j]，就行了。如果 word1[i] == word2[j]，什么也不用做，一共消耗 k 步，否则需要修改，一共消耗 k + 1 步。 问题 2：如果 word1[0..i - 1] 到 word2[0..j] 的变换需要消耗 k 步，那 word1[0..i] 到 word2[0..j] 的变换需要消耗几步呢？ 答：先经过 k 步，把 word1[0..i - 1] 变换到 word2[0..j]，消耗掉 k 步，再把 word1[i] 删除，这样，word1[0..i] 就完全变成了 word2[0..j] 了。一共 k + 1 步。 问题 3：如果 word1[0..i] 到 word2[0..j - 1] 的变换需要消耗 k 步，那 word1[0..i] 到 word2[0..j] 的变换需要消耗几步呢？ 答：先经过 k 步，把 word1[0..i] 变换成 word2[0..j - 1]，消耗掉 k 步，接下来，再插入一个字符 word2[j], word1[0..i] 就完全变成了 word2[0..j] 了。 从上面三个问题来看，word1[0..i] 变换成 word2[0..j] 主要有三种手段，用哪个消耗少，就用哪个。 2020.11.24 T587题目在一个二维的花园中，有一些用(x, y) 坐标表示的树。由于安装费用十分昂贵，你的任务是先用最短的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。 代码class Solution: def outerTrees(self, points: List[List[int]]) -&gt; List[List[int]]: n = len(points) if n &lt; 3: return points points.sort(key=lambda x: (x[0], x[1])) def cross(a, b, c): return (b[0] - a[0]) * \\ (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0]) low = [] for p in points: while len(low) &gt; 1 and cross(low[-2], low[-1], p) &lt; 0: low.pop() low.append((p[0], p[1])) up = [] for p in reversed(points): while len(up) &gt; 1 and cross(up[-2], up[-1], p) &lt; 0: up.pop() up.append((p[0], p[1])) return list(set(low[:-1] + up[:-1])) 分析 节选自 CSDN 用户九茶 分析链接：https://blog.csdn.net/Bone_ACE/article/details/46239187 2020.11.29 T15题目给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 代码class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: l = len(nums) nums.sort() result = set() for x in range(l-2): if nums[x] &gt; 0: break if x &gt;= 1 and nums[x] == nums[x-1]: continue a, b = x+1, l-1 while a &lt; b: if nums[a]+nums[b] &lt; -nums[x]: a += 1 elif nums[a]+nums[b] &gt; -nums[x]: b -= 1 else: result.add((nums[x], nums[a], nums[b])) a += 1 b -= 1 result = list(result) for i in range(len(result)): result[i] = list(result[i]) return result 分析 对于这道题，如果采用暴力三重循环的解法，肯定是会超时的，所以需要另辟蹊径。 我们观察可知，这道题如果只用一重循环，是可以转化为 leetcode 第一题两数相加，因此我们只用遍历数组一次，然后采用双指针首尾遍历一次就可以找到结果了。 但是需要注意的是，这道题要返回的是所有满足条件的不重复三元组，所以先用 set 保存，可以自动去重，最后再将 set 变为 list 返回。(需要注意的是，set 中不能存 list，所以用 tuple 保存) 2020.12.3 T236题目给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 代码class Solution: def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;: if root in (None, p, q): return root L = self.lowestCommonAncestor(root.left, p, q) R = self.lowestCommonAncestor(root.right, p, q) return R if None == L else L if None == R else root 分析左子树或自己含 p 就返回 p，右子树或自己含 q 就返回 q，左右子树返回一 p 一 q 则返回自己，如果某子树返回了答案（另一子树必然返回 None），则返回答案，剩下就是两个子树都返回空，则返回空。 经过逻辑化简： 先分析自己，自己是 p,q,None 中的一者，自然返回自己 然后分析左右子树的返回值，如果其中一个是 None，则返回另一个，作为传递，无论是传递最终的答案，还是传递 p 和 q 如果左右子树返回 p 和 q，当然返回 root","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"/tags/算法/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"每天一个电脑小知识","slug":"每天一个电脑小知识","date":"2020-11-11T14:53:47.000Z","updated":"2024-03-02T16:13:05.023Z","comments":true,"path":"2020/11/11/每天一个电脑小知识/","link":"","permalink":"/2020/11/11/每天一个电脑小知识/","excerpt":"","text":"快捷键系列编辑操作1.ctrl+c 复制 2.ctrl+x 剪切 3.ctrl+v 粘贴 4.ctrl+z 撤销 5.ctrl+f 查找 6.ctrl+w 关闭窗口 网页系列js 控制视频倍速播放 步骤： 1.视频播放期间，按下 F12，进入开发者界面 2.点击开发者界面的 Console 进入控制台 3.复制以下代码，并粘贴在底端的 &gt; 后，并按下回车键 4.你就会发现视频像飞起来一样啦 d=====(￣ ▽ ￣*)b var video = document.querySelector(&quot;video&quot;); // 设置播放倍率 video.playbackRate = 10; // 设置为10倍速(可以修改) 随意修改网页元素 步骤： 1.视频播放期间，按下 F12，进入开发者界面 2.点击开发者界面的 Console 进入控制台 3.复制document.body.contentEditable=true，并粘贴在最后一行的 &gt; 后，并按下回车键 4.你就会发现你可以像修改文档一样修改网页元素啦( o=^•ェ•)o ┏━┓ Windows 操作系统系列编写博客 步骤： 首先要知道写博客是编写文件，所以需要使用工具。然后要让博客发布在网络上，需要一个程序员男朋友。由此可得：男朋友=工具 找到一个编写博客的工具。博客的文本形式一般是 markdown 文件，这里推荐Typora来编写 markdown 文本。 学会怎么编写 markdown 文本。一般可以按照 word 文档形式来编辑，有疑惑的部分可以观看教程。 最后，将编写好的 markdown 文件交给工具让男朋友就可以啦 o(￣ ▽ ￣)ブ","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"},{"name":"Windows","slug":"Windows","permalink":"/tags/Windows/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"b站跑团资源收录","slug":"COC跑团","date":"2020-11-11T04:05:21.000Z","updated":"2024-03-02T16:13:04.454Z","comments":true,"path":"2020/11/11/COC跑团/","link":"","permalink":"/2020/11/11/COC跑团/","excerpt":"","text":"COC 跑团 跑团是对 TRPG（桌上角色扮演游戏）的一种俗称，是一种流行的桌上游戏形式。游戏往往由三五人组成，其中一人担当游戏的主持人，另外几人担当玩家。进行跑团游戏时，常用到的游戏道具有地图、骰子和规则书等。 视频资源收录（追番）帷幕之下(未完结)&lt;&lt; 高颜值 | 神级画师 | 剧情二次创作 | cp | 拖更一年 &gt;&gt; 序章传送门：帷幕之下 P0-序幕-四位演员与名为阿尔姆的舞台 失落的黑莱尔(已完结)&lt;&lt; 动漫人物 | 搞笑 | 无厘头 &gt;&gt; 序章传送门：失落的黑莱尔 01：我是不会带帝王蟹调查克苏鲁的 THEY ARE NUTS!!血色婚礼（未完结）&lt;&lt; cp | 磕男男 CP！ | 磕男男 CP！ | 磕男男 CP！&gt;&gt; 序章传送门：【克苏鲁神话 TRPG】THEY ARE NUTS!!血色婚礼【第一话】","categories":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}],"tags":[{"name":"COC跑团","slug":"COC跑团","permalink":"/tags/COC跑团/"},{"name":"视频资源","slug":"视频资源","permalink":"/tags/视频资源/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}]},{"title":"Markdown教程","slug":"markdown教程","date":"2020-11-08T07:37:36.000Z","updated":"2024-03-02T16:13:05.071Z","comments":true,"path":"2020/11/08/markdown教程/","link":"","permalink":"/2020/11/08/markdown教程/","excerpt":"","text":"markdown 是一种学习成本很低的标记语言，也就是传说中的，易上手且易精通的语言。最近刚刚搭建好网站，也是第一次尝试写博客，打算趁此机会写一篇博客，并边写边学习 markdown 语言。 Markdown 说明Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 Markdown 编写的文档后缀为 .md, 或.markdown。 markdown 标题markdown 标题有两种格式：一种是标题底下加分割线： 一级标题 =========== 二级标题 ------------ 或者是# + 空格： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 markdown 段落格式markdown 字体markdown 可以使用以下几种字体： *斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ___粗斜体文本___ 显示效果分别为：斜体： 斜体文本 斜体文本 粗体： 粗体文本 粗体文本 粗斜体： 粗斜体文本 markdown 分割线*** * * * ***** - - - ---------- markdown 特殊字体删除线文本 ~~删除线文本~~ 下划线文本 &lt;u&gt;下划线文本&lt;/u&gt; 注脚^脚注 创建脚注格式类似这样 [^脚注]。 [^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！ markdown 列表markdown 无序列表无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容： * 第一项 - 第一点 + 第一项 * 第一点 - 第一项 + 第二点 第一项 第一点 第一项 第一点 第一项 第一点 markdown 有序列表有序列表使用数字并加上 . 号来表示，如： 1. 第一项 2. 第二项 第一项 第二项 markdown 列表嵌套1. 第一项： - 第一项的第一个元素 - 第一项的第二个元素 2. 第二项： 第一项： 第一项的第一个元素 第一项的第二个元素 第二项： markdown 分块&gt; 最外层 &gt; &gt; 第一层嵌套 &gt; &gt; &gt; 第二层嵌套 最外层 第一层嵌套 第二层嵌套 与列表一起使用* 第一项 &gt;成为更好的自己 &gt;才能守护最好的你 第一项 成为更好的自己才能守护最好的你 markdown 代码分为代码块和代码片：代码片是用反引号括起来的文字： `这是一段代码片` 这是一段代码片 markdown 链接这是一个连接[ranshi](https://github.com/Zranshi) 这是一个连接ranshi 高级链接我们可以通过变量来设置一个链接，变量赋值在文档末尾进行： 这个链接用 r 作为网址变量 [github][r] 这个链接用 s 作为网址变量 [ranshi][s] 然后在文档的结尾为变量赋值（网址） [r]: https://github.com/ [s]: https://github.com/Zranshi 这个链接用 r 作为网址变量 github 这个链接用 s 作为网址变量 ranshi 然后在文档的结尾为变量赋值（网址） markdown 图片Markdown 图片语法格式如下： ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 &quot;可选标题&quot;) markdown 高级table| Item | Value | Qty | | :------- | -------: | :---: | | Computer | 1600 USD | 5 | | Phone | 12 USD | 12 | | Pipe | 1 USD | 234 | Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 CheckboxYou can use - [ ] and - [x] to create checkboxes, for example: - [x] Item1 - [ ] Item2 - [ ] Item3 Item1 Item2 Item3","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"markdown说明","slug":"markdown说明","permalink":"/tags/markdown说明/"},{"name":"博客编写指导","slug":"博客编写指导","permalink":"/tags/博客编写指导/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2024-02-24T12:27:19.230Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura 主题English document 基于 WordPress 主题Sakura修改成 Hexo 的主题。 demo 预览 正在开发中…… 交流群若你是使用者，加群 QQ: 801511924 若你是创作者，加群 QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine 评论 fancy-box 相册 pjax 支持，音乐不间断 aplayer 音乐播放器 多级导航菜单（按现在大部分 hexo 主题来说，这也算是个特性了） 赞赏作者如果喜欢 hexo-theme-sakura 主题，可以考虑资助一下哦~非常感激！ paypal |Alipay 支付宝 |WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理 233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些 source 的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行 npm i安装依赖。 2、主题配置博客根目录下的_config 配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用 hexo b 发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config 配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: { path: /categories/技术/, fa: fa-code }, 生活: { path: /categories/生活/, fa: fa-file-text-o }, 资源: { path: /categories/资源/, fa: fa-cloud-download }, 随想: { path: /categories/随想/, fa: fa-commenting-o }, 转载: { path: /categories/转载/, fa: fa-book }, }, } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: { path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: { path: /bangumi/, fa: fa-film faa-vertical }, 歌单: { path: /music/, fa: fa-headphones }, 图集: { path: /tags/图集/, fa: fa-photo }, }, } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench, submenus: { 我？: { path: /about/, fa: fa-meetup }, 主题: { path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: { path: /lab/, fa: fa-cogs }, }, } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - { url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png } - { url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg, } - { url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg } # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: { url: http://github.com/honjun, img: /img/social/github.png } sina: { url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png } wangyiyun: { url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png } zhihu: { url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png } email: { url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg } wechat: { url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png } # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: { url: http://github.com/honjun, fa: fa-github, color: 333 } weibo: { url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39 } qq: { url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe } # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml 里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把 404 图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue 或群里提出来），现在是没设置的话会使用那种倒立小狗 404 哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置 如留言板页面页面，位于 source下的 comment 下，打开 index.md 如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件 hexo-tag-bili 和 hexo-tag-fancybox_img。其中 hexo-tag-bili 用来在文章或单页面中插入 B 站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img 用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来To be continued…","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]}]}